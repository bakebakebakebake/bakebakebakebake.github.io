<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Johnson 全源最短路径算法</title>
    <url>/posts/e277c2ae/</url>
    <content><![CDATA[<h1 id="简单来说就是-spfa-与-dijkstra-连用"><a href="#简单来说就是-spfa-与-dijkstra-连用" class="headerlink" title="简单来说就是 [[spfa]] 与 [[dijkstra]] 连用"></a>简单来说就是 [[spfa]] 与 [[dijkstra]] 连用</h1><p>$Johnson$ 算法则通过另外一种方法来给每条边重新标注边权。</p>
<p>我们新建一个虚拟节点（在这里我们就设它的编号为 $0$）。从这个点向其他所有点连一条边权为 $0$ 的边。</p>
<p>接下来用 $Bellman-Ford$ 算法求出从 $0$ 号点到其他所有点的最短路，记为 $h_i$。</p>
<p>假如存在一条从 $u$ 点到 $v$ 点，边权为 $w$ 的边，则我们将该边的边权重新设置为 $w+h_u-h_v$。</p>
<p>接下来以每个点为起点，跑 $n$ 轮 $Dijkstra$ 算法即可求出任意两点间的最短路了。</p>
<p>一开始的 $Bellman-Ford$ 算法并不是时间上的瓶颈，若使用 $priority_queue$ 实现 $Dijkstra$ 算法，该算法的时间复杂度是 $O(nm\log m)$。</p>
<blockquote>
<p>负环判断中存在的常见误区<br>需要注意的是，以 $S$ 点为源点跑 $Bellman-Ford$ 算法时，如果没有给出存在负环的结果，只能说明从 $S$ 点出发不能抵达一个负环，而不能说明图上不存在负环。</p>
<p>因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为 $0$ 的边，然后以超级源点为起点执行 $Bellman-Ford$ 算法。</p>
</blockquote>
<h2 id="1-【模板】全源最短路（Johnson）"><a href="#1-【模板】全源最短路（Johnson）" class="headerlink" title="1 【模板】全源最短路（Johnson）"></a>1 <a href="https://www.luogu.com.cn/problem/P5905">【模板】全源最短路（Johnson）</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> v, w, next;</span><br><span class="line">&#125; a[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">5010</span>],dis[<span class="number">5010</span>],h[<span class="number">5010</span>],cnt[<span class="number">5010</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">5010</span>];</span><br><span class="line"><span class="type">int</span> edge;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++edge].v = v;</span><br><span class="line">    a[edge].w = w;</span><br><span class="line">    a[edge].next = head[u];</span><br><span class="line">    head[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i;i=a[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = a[i].v, w = a[i].w;</span><br><span class="line">            <span class="keyword">if</span>(h[v]&gt;h[u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                h[v] = h[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    cnt[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[v]&gt;n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pll t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = t.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i;i=a[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = a[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+a[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + a[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n;u++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i;i=a[i].next)</span><br><span class="line">            a[i].w += h[u] - h[a[i].v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dijkstra</span>(i);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[j]==inf)</span><br><span class="line">                ans += j * inf;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += j * (dis[j] + h[j] - h[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/posts/ad32db8f/</url>
    <content><![CDATA[<h2 id="1-P3375-【模板】KMP-洛谷"><a href="#1-P3375-【模板】KMP-洛谷" class="headerlink" title="1 P3375 【模板】KMP - 洛谷"></a>1 <a href="https://www.luogu.com.cn/problem/P3375">P3375 【模板】KMP - 洛谷</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="type">int</span> ne[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="comment">// ne[0] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; s2.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s2[i] != s2[j])</span><br><span class="line">            j = ne[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s2[i] == s2[j])</span><br><span class="line">            j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s1.<span class="built_in">length</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s1[i] != s2[j])</span><br><span class="line">            j = ne[j - <span class="number">1</span>]; <span class="comment">// 不断前移j指针，直到成功匹配或移到头为止</span></span><br><span class="line">        <span class="keyword">if</span> (s1[i] == s2[j])</span><br><span class="line">            j++; <span class="comment">// 当前位匹配成功，j指针右移</span></span><br><span class="line">        <span class="keyword">if</span> (j == s2.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i - j + <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//输出对应匹配的位置</span></span><br><span class="line">            <span class="comment">// 对s1[i - j + 1 .. i]进行一些操作</span></span><br><span class="line">            j = ne[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s2.<span class="built_in">length</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ne[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 算法求强连通分量</title>
    <url>/posts/8443763e/</url>
    <content><![CDATA[<p><a href="https://oi.wiki/graph/lca/">最近公共祖先 - OI Wiki</a><br>(塔杨算法)<br>Robert E. Tarjan（罗伯特·塔扬，1948~），生于美国加州波莫纳，计算机科学家。</p>
<p>Tarjan 发明了很多算法和数据结构。不少他发明的算法都以他的名字命名，以至于有时会让人混淆几种不同的算法。比如</p>
<ul>
<li>求各种连通分量的 Tarjan 算法，</li>
<li>求 LCA（Lowest Common Ancestor，最近公共祖先）的 Tarjan 算法。</li>
<li>并查集、Splay、Toptree 也是 Tarjan 发明的。</li>
</ul>
<h2 id="连通分量的-Tarjan-算法"><a href="#连通分量的-Tarjan-算法" class="headerlink" title="连通分量的 Tarjan 算法"></a>连通分量的 Tarjan 算法</h2><h3 id="DFS-生成树"><a href="#DFS-生成树" class="headerlink" title="DFS 生成树"></a>DFS 生成树</h3><p><img data-src="https://static.cdn.menci.xyz/oi-wiki/graph/images/dfs-tree.svg?h=xHCEwA" alt="300"><br><mark style="background: #FF5582A6;">返祖边</mark> <mark style="background: #ADCCFFA6;">横叉边</mark> <mark style="background: #FFF3A3A6;">前向边</mark></p>
<ul>
<li>返祖边与树边必构成环</li>
<li>横叉边可能与树边构成环</li>
<li><p>前向边无用</p>
<h3 id="Tarjan-算法求强连通分量"><a href="#Tarjan-算法求强连通分量" class="headerlink" title="Tarjan 算法求强连通分量"></a>Tarjan 算法求强连通分量</h3><p>  强连通分量 SCC(strongly connected component)<br>在 Tarjan 算法中为每个结点 $u$ 维护了以下几个变量：</p>
</li>
</ul>
<p>$\textit{dfn}_u$：深度优先搜索遍历时结点 u 被搜索的次序。<br>$\textit{low}_u$：在 u 的子树中能够回溯到的最早的已经在栈中的结点。设以 u 为根的子树为 $\textit{Subtree}_u$。$\textit{low}_u$ 定义为以下结点的$\textit{dfn}$ 的最小值：$\textit{Subtree}_u$ 中的结点；从 $\textit{Subtree}_u$ 通过一条不在搜索树上的边能到达的结点。<br>一个结点的子树内结点的 dfn 都大于该结点的 dfn。</p>
<p>从根开始的一条路径上的 dfn 严格递增，low 严格非降。</p>
<p>按照深度优先搜索算法搜索的次序对图中所有的结点进行搜索，维护每个结点的 <code>dfn</code> 与 <code>low</code> 变量，且让搜索到的结点入栈。每当找到一个强连通元素，就按照该元素包含结点数目让栈中元素出栈。在搜索过程中，对于结点 $u$ 和与其相邻的结点 $v$（$v$ 不是 $u$ 的父节点）考虑 3 种情况：</p>
<ol>
<li>v 未被访问：继续对 v 进行深度搜索。在回溯过程中，用 $\textit{low}_v$ 更新 $\textit{low}_u$。因为存在从 $u$ 到 $v$ 的直接路径，所以 $v$ 能够回溯到的已经在栈中的结点，$u$ 也一定能够回溯到。</li>
<li>v 被访问过，已经在栈中：根据 low 值的定义，用 \textit{dfn}_v 更新 \textit{low}_u。</li>
<li>v 被访问过，已不在栈中：说明 v 已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。<br>将上述算法写成伪代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TARJAN_SEARCH</span>(<span class="type">int</span> u)</span><br><span class="line">    vis[u]=<span class="literal">true</span></span><br><span class="line">    low[u]=dfn[u]=++dfncnt</span><br><span class="line">    push u to the stack</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">each</span> (u,v) then <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> v hasn<span class="number">&#x27;</span>t been searched then</span><br><span class="line">            <span class="built_in">TARJAN_SEARCH</span>(v) <span class="comment">// 搜索</span></span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]) <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> v has been in the stack then</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v])<span class="comment">//low[v]&lt;-&gt;dfn[v]</span></span><br></pre></td></tr></table></figure>
对于一个连通分量图，我们很容易想到，在该连通图中有且仅有一个 u 使得 $\textit{dfn}_u=\textit{low}_u$。该结点一定是在深度遍历的过程中，该连通分量中第一个被访问过的结点，因为它的 dfn 和 low 值最小，不会被该连通分量中的其他结点所影响。</li>
</ol>
<p>因此，在回溯的过程中，判定 $\textit{dfn}_u=\textit{low}_u$ 是否成立，如果成立，则栈中 $u$ 及其上方的结点构成一个 SCC。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>$O(n+m)$<br>oi.wiki 模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dfn[N], low[N], dfncnt, s[N], in_stack[N], tp;</span><br><span class="line"><span class="type">int</span> scc[N], sc;  <span class="comment">// 结点 i 所在 SCC 的编号</span></span><br><span class="line"><span class="type">int</span> sz[N];       <span class="comment">// 强连通 i 的大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  low[u] = dfn[u] = ++dfncnt, s[++tp] = u, in_stack[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i; i = e[i].nex) &#123;<span class="comment">//链式前向星的存图方式</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;v = e[i].t;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(v);</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (in_stack[v]) &#123;</span><br><span class="line">      low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">    ++sc;</span><br><span class="line">    <span class="keyword">while</span> (s[tp] != u) &#123;</span><br><span class="line">      scc[s[tp]] = sc;</span><br><span class="line">      sz[sc]++;</span><br><span class="line">      in_stack[s[tp]] = <span class="number">0</span>;</span><br><span class="line">      --tp;</span><br><span class="line">    &#125;</span><br><span class="line">    scc[s[tp]] = sc;</span><br><span class="line">    sz[sc]++;</span><br><span class="line">    in_stack[s[tp]] = <span class="number">0</span>;</span><br><span class="line">    --tp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="董晓算法模板："><a href="#董晓算法模板：" class="headerlink" title="董晓算法模板："></a>董晓算法模板：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N],instk[N],siz[N],scc[N],stk[N],top,tot,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tot;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    instk[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instk[y]) &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk[top--];</span><br><span class="line">            instk[y] = <span class="number">0</span>;</span><br><span class="line">            scc[y] = cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多组数据清空</span></span><br><span class="line">	<span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(scc, <span class="number">0</span>, <span class="keyword">sizeof</span> scc);</span><br><span class="line">    <span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="keyword">sizeof</span> siz);</span><br><span class="line">    <span class="built_in">memset</span>(instk, <span class="number">0</span>, <span class="keyword">sizeof</span> instk);</span><br><span class="line">    <span class="built_in">memset</span>(stk, <span class="number">0</span>, <span class="keyword">sizeof</span> stk);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        e[i].<span class="built_in">clear</span>();</span><br><span class="line">    cnt = <span class="number">0</span>, tot = <span class="number">0</span>, top = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算入度出度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(scc[i]!=scc[v])</span><br><span class="line">            &#123;</span><br><span class="line">                out[scc[i]]++;</span><br><span class="line">                in[scc[v]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//董晓模板各个变量的作用</span></span><br><span class="line"><span class="number">1.</span> vector&lt;<span class="type">int</span>&gt; e[N]: 存储了图中每个节点的邻接节点列表。</span><br><span class="line"><span class="number">2.</span> <span class="type">int</span> dfn[N]: 用于记录每个节点被遍历到的时间戳（深度优先搜索的遍历顺序）。</span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> low[N]: 用于记录每个节点能够回溯到的最早的时间戳。</span><br><span class="line"><span class="number">4.</span> <span class="type">int</span> instk[N]: 用于记录每个节点是否在栈中。</span><br><span class="line"><span class="number">5.</span> <span class="type">int</span> siz[N]: 用于记录每个强连通分量的大小。</span><br><span class="line"><span class="number">6.</span> <span class="type">int</span> scc[N]: 用于记录每个节点所属的强连通分量编号。</span><br><span class="line"><span class="number">7.</span> <span class="type">int</span> stk[N]: 用于模拟栈的操作，在tarjan算法中用于存储遍历过的节点。</span><br><span class="line"><span class="number">8.</span> <span class="type">int</span> top: 用于记录栈顶的位置。</span><br><span class="line"><span class="number">9.</span> <span class="type">int</span> tot: 用于记录当前遍历的时间戳。</span><br><span class="line"><span class="number">10.</span> <span class="type">int</span> cnt: 用于记录强连通分量的个数。</span><br></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul>
<li><a href="https://loj.ac/p/10091">LibreOJ</a> [[受欢迎的牛]] <a href="https://www.luogu.com.cn/problem/P2341">P 2341 [USACO 03 FALL / HAOI 2006] 受欢迎的牛 G - 洛谷</a>(一样的题)</li>
<li><a href="https://poj.org/problem?id=1236">Site Unreachable</a> [[Network of Schools]] <a href="https://www.luogu.com.cn/problem/P2746">P 2746 [USACO 5.3] 校园网 Network of Schools - 洛谷</a><br><a href="https://www.luogu.com.cn/problem/P2812">P 2812 校园网络【[USACO]Network of Schools 加强版】 - 洛谷</a>(三个题是一样的)</li>
<li><a href="https://www.luogu.com.cn/problem/P2863">P 2863 [USACO 06 JAN] The Cow Prom S - 洛谷</a>(模板) [[P2863 The Cow Prom S - 洛谷]]</li>
<li>[[Proving Equivalences]] </li>
<li>[[The Largest Clique]]</li>
</ul>
<h2 id="tarjan-算法求-lca-见-lca"><a href="#tarjan-算法求-lca-见-lca" class="headerlink" title="tarjan 算法求 lca 见 [[lca]]"></a>tarjan 算法求 lca 见 [[lca]]</h2><p><a href="https://www.bilibili.com/video/BV19J411J7AZ?p=5&amp;spm_id_from=pageDriver&amp;vd_source=cb670d82714ee9baee22c33ef083884d">5_code实现_哔哩哔哩_bilibili</a></p>
<p>![[../../../images/Z-attachment/Pasted image 20231222162051.png]]</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>bitset</title>
    <url>/posts/9dd4d1cb/</url>
    <content><![CDATA[<p><mark style="background: #FF5582A6;">在某些题有奇效</mark></p>
<h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a><a href="https://www.luogu.com.cn/blog/fusu2333/fu-su-di-bitset-qian-tan#:~:text=bitset%E6%98%AF%E4%B8%80%E4%B8%AA01%E4%B8%B2%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%BD%8D%E5%8D%A0%E4%B8%80%E4%B8%AAbit%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%8D%95%E7%82%B90%2F1%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB%E4%BB%A5%E5%8F%8A%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%E3%80%82,%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E7%94%A8%E6%B3%95%E6%98%AF%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E8%BF%87%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%B8%80%E4%B8%AA%E6%A1%B6%E3%80%82%20%E5%90%8C%E6%97%B6%E4%B8%A4%E4%B8%AAbitset%E5%8F%96%E6%88%96%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BC%98%E7%A7%80%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8B%E8%8E%B7%E5%BE%97%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82">bitset</a></h1><h2 id="1-Bitset-的构造函数："><a href="#1-Bitset-的构造函数：" class="headerlink" title="1 Bitset 的构造函数："></a>1 Bitset 的构造函数：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.默认构造函数 :0</span></span><br><span class="line">bitset&lt;10&gt; a;			<span class="comment">//a:0000000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.用一个数值初始化</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)当用一个数值去构造的时候，其实就是将数值在内存中的存储方式显示出来。(数值在内存中是以补码形式存储的)</span><br><span class="line">(<span class="number">2</span>)若bitset的位数n小于数值的位数,只取数值(小端的)前n位初始化给<span class="function">bitset</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">a</span><span class="params">(<span class="number">-16</span>)</span></span>;		<span class="comment">//-16的补码为11111111.....10000,a有4位,因此a:0000</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;5&gt; <span class="title">a</span><span class="params">(<span class="number">17</span>)</span></span>;		 <span class="comment">//17的补码为00000000.....10001,a有5位,因此a:10001</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="number">-8</span>)</span></span>;		<span class="comment">//-8的补码为 11111111.....11000,a有6位,因此a:111000</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;7&gt; <span class="title">a</span><span class="params">(<span class="number">8</span>)</span></span>;			 <span class="comment">//8的补码为 00000000.....01000,a有7位,因此a:0001000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.用字符串string 或者 char[]初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以string为例,char[]与其用法相同 </span></span><br><span class="line"></span><br><span class="line">string b = <span class="string">&quot;100101111&quot;</span>;	<span class="comment">//这里特别注意，bitset的size和字符串长度不匹配的时候如何构造</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;3&gt; <span class="title">a</span><span class="params">(b)</span></span>;			<span class="comment">//a:100			  //当bitset的size小于等于字符串长度，取字符串的前size位</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(b)</span></span>;			<span class="comment">//a:100101</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;9&gt; <span class="title">a</span><span class="params">(b)</span></span>;			<span class="comment">//a:100101111</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;12&gt; <span class="title">a</span><span class="params">(b)</span></span>;		<span class="comment">//a:000100101111  //当bitset的size大于字符串长度，进行补零</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>运算符重载[], 支持下标从 0 开始访问, 与数组类似</p>
<p>注意 : 下标小的是小端</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;4&gt; a;	<span class="comment">//a:0000(默认构造函数)</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//a:0101</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;7&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;1001101&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    cout &lt;&lt; b[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//输出:1011001</span></span><br></pre></td></tr></table></figure>
<h2 id="2-Bitset-的成员函数："><a href="#2-Bitset-的成员函数：" class="headerlink" title="2 Bitset 的成员函数："></a>2 Bitset 的成员函数：</h2><blockquote>
<p><code>count</code> <code>size</code> <code>test</code> <code>any</code> <code>none</code> <code>all</code> <code>set</code> <code>reset</code> <code>flip</code> <code>to_string( )</code> <code>to_ulong( )</code> <code>to_ullong( )</code> 等。</p>
<ul>
<li>count 返回 bitset 中 1 的个数</li>
<li>size 返回 size 大小</li>
<li>test 返回某一位 (下标)是否为 1<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span> <span class="params">(<span class="type">size_t</span> pos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//用例：</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;011101&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">test</span>(<span class="number">0</span>) &lt;&lt; endl;	<span class="comment">//1	(true)</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">test</span>(<span class="number">1</span>) &lt;&lt; endl;	<span class="comment">//0	(false)</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">test</span>(<span class="number">5</span>) &lt;&lt; endl;	<span class="comment">//0 (false)</span></span><br></pre></td></tr></table></figure></li>
<li>any 只要有一位是 1, 就返回 true, 否则返回 false</li>
<li>none 若全为 0, 返回 true, 否则返回 false<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">none</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//用例：</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;(<span class="string">&quot;0000&quot;</span>).<span class="built_in">none</span>() &lt;&lt; endl;	<span class="comment">//1	(true)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;(<span class="string">&quot;0001&quot;</span>).<span class="built_in">none</span>() &lt;&lt; endl;	<span class="comment">//0	(false)</span></span><br></pre></td></tr></table></figure></li>
<li><p>all 若全为 1, 返回 true, 否则返回 false</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">all</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//用例：</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;(<span class="string">&quot;1111&quot;</span>).<span class="built_in">all</span>() &lt;&lt; endl;	<span class="comment">//1	(true)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">4</span>&gt;(<span class="string">&quot;1101&quot;</span>).<span class="built_in">all</span>() &lt;&lt; endl;	<span class="comment">//0	(false)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>set 全部置 1, 或者某一位置 1 或 0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员函数声明</span></span><br><span class="line"><span class="function">bitset&amp; <span class="title">set</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//用例：</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;011101&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">set</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;	<span class="comment">//输出:111111</span></span><br><span class="line"><span class="comment">//2.set也可以指定参数,第一个参数是索引,第二个true表示置1,false表示置0</span></span><br><span class="line"><span class="function">bitset&amp; <span class="title">set</span> <span class="params">(<span class="type">size_t</span> pos, <span class="type">bool</span> val = <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;011101&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">a.<span class="built_in">set</span>(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;	<span class="comment">//输出:111100</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reset 全部置 0, 或者某一位置 0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&amp; <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">bitset&amp; <span class="title">reset</span> <span class="params">(<span class="type">size_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//用例：</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;011101&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;	<span class="comment">//输出:000000</span></span><br><span class="line"><span class="comment">//也可以指定参数,单独将某一位置0</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;011101&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">reset</span>(<span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;	<span class="comment">//输出:011100</span></span><br></pre></td></tr></table></figure></li>
<li>flip 全部取反, 或者某一位取反<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员函数声明</span></span><br><span class="line"><span class="function">bitset&amp; <span class="title">flip</span><span class="params">()</span></span>;	</span><br><span class="line"><span class="function">bitset&amp; <span class="title">flip</span> <span class="params">(<span class="type">size_t</span> pos)</span></span>;</span><br><span class="line"><span class="comment">//用例：</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;011101&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">flip</span>();</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;	<span class="comment">//输出:100010</span></span><br><span class="line"><span class="comment">//也可以指定参数,单独将某一位取反</span></span><br><span class="line"><span class="function">bitset&lt;6&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;011101&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">flip</span>(<span class="number">0</span>);</span><br><span class="line">a.<span class="built_in">flip</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;	<span class="comment">//输出:011110</span></span><br></pre></td></tr></table></figure></li>
<li>to_string ( ) 转换为字符串</li>
<li>to_ulong ( ) 转换为无符号 long 类型<br><code>bitset&lt;6&gt; a(&quot;011101&quot;);</code><br><code>auto x = a.to_ulong();</code></li>
<li>to_ullong ( ) 转换为无符号 long long 类型<br><code>bitset&lt;6&gt; a(&quot;011101&quot;);</code><br><code>auto x = a.to_ullong();</code></li>
</ul>
</blockquote>
<ul>
<li>如果超出了 bitset 定义的范围：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;2&gt;<span class="built_in">bitset1</span>(<span class="number">12</span>);<span class="comment">//12的二进制为1100（长度为４），但bitset1的size=2，只取后面部分，即00</span></span><br><span class="line"></span><br><span class="line">string s=<span class="string">&quot;100101&quot;</span>;</span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bitset2</span><span class="params">(s)</span></span>;<span class="comment">//s的size=6，而bitset的size=4，只取前面部分，即1001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char s2[]=&quot;11101&quot;;</span></span><br><span class="line"><span class="comment">//bitset&lt;4&gt; bitset3(s2);//与bitset2同理，只取前面部分，即1110</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; bitset1 &lt;&lt; endl;　　<span class="comment">//00</span></span><br><span class="line">cout &lt;&lt; bitset2 &lt;&lt; endl;　　<span class="comment">//1001</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; bitset3 &lt;&lt; endl;　　//1110</span></span><br></pre></td></tr></table></figure>
<h2 id="3-位运算操作"><a href="#3-位运算操作" class="headerlink" title="3 位运算操作"></a>3 位运算操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">foo</span> <span class="params">(string(<span class="string">&quot;1001&quot;</span>))</span></span>;<span class="comment">//这种赋值方式就可以直接用，没有限制</span></span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bar</span> <span class="params">(string(<span class="string">&quot;0011&quot;</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; (foo^=bar) &lt;&lt; endl;       <span class="comment">// 1010 (foo对bar按位异或后赋值给foo)</span></span><br><span class="line">cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;       <span class="comment">// 0010 (按位与后赋值给foo)</span></span><br><span class="line">cout &lt;&lt; (foo|=bar) &lt;&lt; endl;       <span class="comment">// 0011 (按位或后赋值给foo)</span></span><br><span class="line">cout &lt;&lt; (foo&lt;&lt;=<span class="number">2</span>) &lt;&lt; endl;        <span class="comment">// 1100 (左移２位，低位补０，有自身赋值)</span></span><br><span class="line">cout &lt;&lt; (foo&gt;&gt;=<span class="number">1</span>) &lt;&lt; endl;        <span class="comment">// 0110 (右移１位，高位补０，有自身赋值)</span></span><br><span class="line">cout &lt;&lt; (~bar) &lt;&lt; endl;           <span class="comment">// 1100 (按位取反) </span></span><br><span class="line">cout &lt;&lt; (bar&gt;&gt;<span class="number">1</span>) &lt;&lt; endl;         <span class="comment">// 0001 (右移，不赋值)</span></span><br><span class="line">cout &lt;&lt; (foo==bar) &lt;&lt; endl;       <span class="comment">// （0）false (0110==0011为false)</span></span><br><span class="line">cout &lt;&lt; (foo!=bar) &lt;&lt; endl;       <span class="comment">// （1）true  (0110!=0011为true)</span></span><br><span class="line">cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;        <span class="comment">// 0010 (按位与，不赋值)</span></span><br><span class="line">cout &lt;&lt; (foo|bar) &lt;&lt; endl;        <span class="comment">// 0111 (按位或，不赋值)</span></span><br><span class="line">cout &lt;&lt; (foo^bar) &lt;&lt; endl;		  <span class="comment">// 0101 (按位异或，不赋值)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iota函数</title>
    <url>/posts/8816c0b7/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以生成一个序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> v:p)</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>gcd</title>
    <url>/posts/b6d69992/</url>
    <content><![CDATA[<p><mark style="background: #ADCCFFA6;">递归求法</mark>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用的最多</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//快速算最大公因数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>迭代求法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp % b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>C++14 可用 <code>__gcd (a, b)</code></p>
<p>大数的 gcd：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Big <span class="title">gcd</span><span class="params">(Big a, Big b)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 记录a和b的公因数2出现次数</span></span><br><span class="line">  <span class="type">int</span> atimes = <span class="number">0</span>, btimes = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    atimes++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (b % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    btimes++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// a和b公因数中的2已经计算过了，后面不可能出现a,b均为偶数的情况</span></span><br><span class="line">    <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 确保 a&gt;=b</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    a -= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt;&lt; <span class="built_in">min</span>(atimes, btimes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>dijkstra</title>
    <url>/posts/65ee973a/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3371">P3371</a> <a href="https://www.luogu.com.cn/problem/P4779">P4779</a></p>
<p>[[链式前向星存图]] </p>
<h1 id="堆优化版-：-O-mlogm"><a href="#堆优化版-：-O-mlogm" class="headerlink" title="堆优化版 ：$O(mlogm)$"></a>堆优化版 ：$O(mlogm)$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, w, next;</span><br><span class="line">&#125; a[<span class="number">200010</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> head[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//链式前向星存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[cnt].w = w;</span><br><span class="line">    a[cnt].v = v;</span><br><span class="line">    a[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line">priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     dis[i] = INT_MAX;//弱化版还需要ll</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pll t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = t.second;</span><br><span class="line">        <span class="keyword">if</span> (vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = a[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = a[i].v;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + a[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + a[i].w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="朴素写法-：-O-n-2"><a href="#朴素写法-：-O-n-2" class="headerlink" title="朴素写法 ：$O(n^2)$"></a>朴素写法 ：$O(n^2)$</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//O(n方)</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> inf = <span class="number">99999999</span>;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m; <span class="comment">//顶点数，边数</span></span><br><span class="line">	<span class="type">int</span> a, b, c;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line">				mp[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				mp[i][j] = inf; <span class="comment">//初始化</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		mp[a][b] = c; <span class="comment">//建图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		dis[i] = mp[<span class="number">1</span>][i];</span><br><span class="line">	&#125;</span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//Dijkstra算法的核心部分</span></span><br><span class="line">	<span class="type">int</span> u;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;<span class="comment">//找离原点最近的点 </span></span><br><span class="line">		<span class="type">int</span> minn = inf;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( book[j] == <span class="number">0</span>&amp;&amp;dis[j] &lt; minn ) &#123;</span><br><span class="line">				minn = dis[j];</span><br><span class="line">				u = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		book[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mp[u][v] &lt; inf) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dis[v] &gt; dis[u] + mp[u][v])</span><br><span class="line">					dis[v] = dis[u] + mp[u][v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dis[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>lcm</title>
    <url>/posts/c35fced7/</url>
    <content><![CDATA[<p>两个数有：<br>$gcd(a,b)\times lcm(a,b)=a\times b$</p>
<p>求两个数的最小公倍数，先求出最大公约数即可。</p>
<p>多个数：<br>当我们求出两个数的 $gcd$ 时，求最小公倍数是 $O(1)$ 的复杂度。那么对于多个数，我们其实没有必要求一个共同的最大公约数再去处理，最直接的方法就是，当我们算出两个数的 $gcd$，或许在求多个数的 $gcd$ 时候，我们将它放入序列对后面的数继续求解，那么，我们转换一下，直接将最小公倍数放入序列即可</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>spfa</title>
    <url>/posts/52d25d1/</url>
    <content><![CDATA[<p>可以判断是否有负环，可与 [[dijkstra]] 连用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[maxn];</span><br><span class="line"><span class="type">int</span> dis[maxn], cnt[maxn], vis[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">  dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>(), vis[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">      <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">      <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        cnt[v] = cnt[u] + <span class="number">1</span>;  <span class="comment">// 记录最短路经过的边数</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[v] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 在不经过负环的情况下，最短路至多经过 n - 1 条边</span></span><br><span class="line">        <span class="comment">// 因此如果经过了多于 n 条边，一定说明经过了负环</span></span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) q.<span class="built_in">push</span>(v), vis[v] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><a href="https://www.luogu.com.cn/problem/solution/P3385">P3385</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t,n,m;</span><br><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> v, w, next;</span><br><span class="line">&#125; a[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">50000</span>],dis[<span class="number">50000</span>],cnt[<span class="number">50000</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">50000</span>];</span><br><span class="line"><span class="type">int</span> edge;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++edge].v = v;</span><br><span class="line">    a[edge].w = w;</span><br><span class="line">    a[edge].next = head[u];</span><br><span class="line">    head[u] = edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i;i=a[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = a[i].v, w = a[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                cnt[v] = cnt[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[v]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    vis[v] = <span class="number">1</span>, q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);<span class="comment">///////</span></span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v, w;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            <span class="built_in">add</span>(u, v, w);</span><br><span class="line">            <span class="keyword">if</span>(w&gt;=<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">add</span>(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">spfa</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>lca</title>
    <url>/posts/cae982fc/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA） - 洛谷</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.cnblogs.com/luoyj/p/13956883.html">LCA —算法竞赛专题解析（29） - 罗勇军999 - 博客园</a><br>Lowest Common Ancestor<br>LCA 是指在一棵树中，距离两个点最近的两者的公共节点。也就是说，在两个点通往根的道路上，肯定会有公共的节点，我们就是要求找到公共的节点中，深度尽量深的点。还可以表示成另一种说法，就是如果把树看成是一个图，这找到这两个点中的最短距离。<br><a href="#定义">定义</a><br><a href="#性质">性质</a><br>LCA 算法有在线算法也有离线算法，所谓的在线算法就是实时性的，而离线算法则是要求一次性读入所有的请求，然后在统一得处理。而在处理的过程中不一定是按照请求的输入顺序来处理的。说不定后输入的请求在算法的执行过程中是被先处理的。</p>
<p>这里主要是讨论 tarjan 算法|与|倍增算法(<mark style="background: #ADCCFFA6;">待更</mark>)与树链剖分(需要学到高级数据结构(<mark style="background: #ADCCFFA6;">待更</mark>))的做法，这三种可以解决几乎所有问题。倍增和树链剖分用的尤其多。具体其他做法看 oi. wiki 即可</p>
<p><a href="https://zhuanlan.zhihu.com/p/630881657">最近公共祖先 (Lowest Common Ancestor) - 知乎</a>有详细说明<br>也可以看董晓算法的视频 <a href="https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cb670d82714ee9baee22c33ef083884d">322 Tarjan算法 P3379【模板】最近公共祖先（LCA）_哔哩哔哩_bilibili</a><br>董晓算法很详细的讲了三种方法：<a href="#倍增算法">倍增</a>，<a href="#Tarjan算法">tarjan</a>，<a href="#树链剖分">树链剖分</a>,甚至更深入的知识。</p>
<h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><h2 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h2><p>是在线算法<br>倍增法的总计算量包括预计算 $f a$ 数组和查询 $m$ 次 $L C A$ ，总的时间复杂度为 $O\left(n \log <em>{2} n+m \log </em>{2} n\right)$ 。<br>董晓算法的模板<br>![[../../../images/Z-attachment/Pasted image 20231225134530.png]]</p>
<p>这个模板过洛谷模板题<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> n, m, s, a, b;</span><br><span class="line"><span class="type">int</span> dep[N], fa[N][<span class="number">22</span>];</span><br><span class="line"><span class="type">int</span> h[N], to[M], ne[M], tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    to[++tot] = b, ne[tot] = h[a], h[a] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x][<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        fa[x][i + <span class="number">1</span>] = fa[fa[x][i]][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (to[i] != f)</span><br><span class="line">            <span class="built_in">dfs</span>(to[i], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; ~i; i--)</span><br><span class="line">        <span class="keyword">if</span> (dep[fa[x][i]] &gt;= dep[y])</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; ~i; i--)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span>(a, b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><p><a href="#简介">跳转回简介</a><br><mark style="background: #CACFD9A6;">比较稳定，复杂度较好</mark><br>$O(m+n)$<br>是离线算法</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>Tarjan 算法是一种离线算法，需要使用并查集记录某个结点的祖先结点。做法如下:  </p>
<ol>
<li>首先接受输入边 (邻接链表) 、查询边 (存储在另一个邻接链表内) 。查询边其实是虚拟加上去的边，为了方便，每次输入查询边的时候，将这个边及其反向边都加入到 queryEdge 数组里。  </li>
<li>然后对其进行一次 DFS 遍历，同时使用 visited 数组进行记录某个结点是否被访问过、 parent 记录当前结点的父亲结点。  </li>
<li>其中涉及到了回溯思想，我们每次遍历到某个结点的时候，认为这个结点的根结点就是它本身。让以这个结点为根节点的 DFS 全部遍历完毕了以后，再将这个结点的根节点设置为这个结点的父一级结点。  </li>
<li>回溯的时候，如果以该节点为起点，queryEdge 查询边的另一个结点也恰好访问过了，则直接更新查询边的 LCA 结果。  </li>
<li>最后输出结果。  </li>
</ol>
<h3 id="tarjan性质"><a href="#tarjan性质" class="headerlink" title="tarjan性质"></a>tarjan性质</h3><p>Tarjan 算法需要初始化并查集，所以预处理的时间复杂度为 $O(n)$ 。<br>朴素的 Tarjan 算法处理所有 $m$ 次询问的时间复杂度为 $O(m \alpha(m+n, n)+n)$ ，。但是 Tarjan 算法的常数比倍增算法大。存在 $O(m+n)$ 的实现。  </p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>并不存在「朴素 Tarjan LCA 算法中使用的并查集性质比较特殊，单次调用 find ( ) 函数的时间复杂度为均摊 $O(1)$ 」这种说法。  </p>
<p>以下的朴素 Tarjan 实现复杂度为 $O(m \alpha(m+n, n)+n)$ 。如果需要追求严格线性，可以参考 Gabow 和 Tarjan 于 1983 年的论文。其中给出了一种复杂度为 $O(m+n)$ 的做法。</p>
<h3 id="oiwiki-模板"><a href="#oiwiki-模板" class="headerlink" title="oiwiki 模板"></a>oiwiki 模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> toVertex, fromVertex;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">    <span class="type">int</span> LCA;</span><br><span class="line">    <span class="built_in">Edge</span>() : <span class="built_in">toVertex</span>(<span class="number">-1</span>), <span class="built_in">fromVertex</span>(<span class="number">-1</span>), <span class="built_in">next</span>(<span class="number">-1</span>), <span class="built_in">LCA</span>(<span class="number">-1</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> n) : <span class="built_in">fromVertex</span>(u), <span class="built_in">toVertex</span>(v), <span class="built_in">next</span>(n), <span class="built_in">LCA</span>(<span class="number">-1</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> head[MAX], queryHead[MAX];</span><br><span class="line">Edge edge[MAX], queryEdge[MAX];</span><br><span class="line"><span class="type">int</span> parent[MAX], visited[MAX];</span><br><span class="line"><span class="type">int</span> vertexCount, queryCount;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= vertexCount; i++)</span><br><span class="line">        parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[u] = u;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">    &#123; <span class="comment">//[[链式前向星存图]]</span></span><br><span class="line">        Edge &amp;e = edge[i];</span><br><span class="line">        <span class="keyword">if</span> (!visited[e.toVertex])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e.toVertex);</span><br><span class="line">            parent[e.toVertex] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = queryHead[u]; i != <span class="number">-1</span>; i = queryEdge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge &amp;e = queryEdge[i];</span><br><span class="line">        <span class="keyword">if</span> (visited[e.toVertex])</span><br><span class="line">        &#123;</span><br><span class="line">            queryEdge[i ^ <span class="number">1</span>].LCA = e.LCA = <span class="built_in">find</span>(e.toVertex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(queryHead, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(queryHead));</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; vertexCount &gt;&gt; queryCount;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexCount - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line"></span><br><span class="line">        edge[count] = <span class="built_in">Edge</span>(start, end, head[start]);</span><br><span class="line">        head[start] = count;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        edge[count] = <span class="built_in">Edge</span>(end, start, head[end]);</span><br><span class="line">        head[end] = count;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queryCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line"></span><br><span class="line">        queryEdge[count] = <span class="built_in">Edge</span>(start, end, queryHead[start]);</span><br><span class="line">        queryHead[start] = count;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        queryEdge[count] = <span class="built_in">Edge</span>(end, start, queryHead[end]);</span><br><span class="line">        queryHead[end] = count;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queryCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge &amp;e = queryEdge[i * <span class="number">2</span>];</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; e.fromVertex &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; e.toVertex &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; e.LCA &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 2</span><br><span class="line">1 5</span><br><span class="line">1 4</span><br><span class="line">4 9</span><br><span class="line">5 2</span><br><span class="line">5 6</span><br><span class="line">5 7</span><br><span class="line">6 3</span><br><span class="line">6 8</span><br><span class="line">3 4</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(3,4) 1-----1即为3，4的最近公共祖先</span><br><span class="line">(7,8) 5</span><br></pre></td></tr></table></figure></p>
<h3 id="董晓算法的模板-推荐，更易懂"><a href="#董晓算法的模板-推荐，更易懂" class="headerlink" title="董晓算法的模板 (推荐，更易懂)"></a>董晓算法的模板 (推荐，更易懂)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">        query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line"><span class="comment">//核心代码</span></span><br><span class="line"><span class="type">int</span> n, m, r;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N*<span class="number">2</span>];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; query[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> fa[N], vis[N], ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==fa[u])</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">return</span> fa[u] = <span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            fa[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q:query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = q.first, i = q.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">            ans[i] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>洛谷模板题 (721 ms)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> sym = <span class="literal">false</span>; <span class="type">int</span> res = <span class="number">0</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) sym |= (ch == <span class="string">&#x27;-&#x27;</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> sym ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5E5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> fa[N], head[N], cnt, head_query[N], cnt_query, ans[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="comment">// 链式前向星</span></span><br><span class="line">    <span class="type">int</span> to, next, num;</span><br><span class="line">&#125; edge[N &lt;&lt; <span class="number">1</span>], query[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链式前向星加边</span></span><br><span class="line">    edge[++cnt].to = v;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    query[++cnt_query].to = y;</span><br><span class="line">    query[cnt_query].num = num;</span><br><span class="line">    query[cnt_query].next = head_query[x];</span><br><span class="line">    head_query[x] = cnt_query;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = edge[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> y = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            <span class="comment">// 合并并查集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head_query[x]; i; i = query[i].next) &#123;</span><br><span class="line">        <span class="type">int</span> y = query[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[y]) &#123;</span><br><span class="line">            ans[query[i].num] = <span class="built_in">find</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), root = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(u, v), <span class="built_in">addedge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    fa[n] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_query</span>(x, y, i);</span><br><span class="line">        <span class="built_in">add_query</span>(y, x, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>董晓算法模板 (3.02 s)，加入快读后 （1.75s）换了一种快读后（1.69s）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, r;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; query[N];</span><br><span class="line"><span class="type">int</span> fa[N], vis[N], ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==fa[u])</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">return</span> fa[u] = <span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            fa[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q:query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = q.first, i = q.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])</span><br><span class="line">            ans[i] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">        query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="built_in">tarjan</span>(r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m;i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="用欧拉序列转化为-RMQ-问题"><a href="#用欧拉序列转化为-RMQ-问题" class="headerlink" title="用欧拉序列转化为 RMQ 问题"></a>用欧拉序列转化为 RMQ 问题</h2><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p><a href="#简介">跳转回简介 </a></p>
<h2 id="动态树"><a href="#动态树" class="headerlink" title="动态树"></a>动态树</h2><h2 id="标准-RMQ"><a href="#标准-RMQ" class="headerlink" title="标准 RMQ"></a>标准 RMQ</h2><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>求树上两点之间的距离</li>
<li>树上差分<br>具体参考 oi. wiki</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>最近公共祖先简称 LCA (Lowest Common Ancestor) 。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。为了方便，我们记某点集 $S=\left{v<em>{1}, v</em>{2}, \ldots, v<em>{n}\right}$ 的最近公共祖先为 $\operatorname{LCA}\left(v</em>{1}, v<em>{2}, \ldots, v</em>{n}\right)$ 或 $\operatorname{LCA}(S)$ 。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol>
<li>$\operatorname{LCA}({u})=u$ ；  </li>
<li>$u$ 是 $v$ 的祖先，当且仅当 $\operatorname{LCA}(u, v)=u$ ；  </li>
<li>如果 $u$ 不为 $v$ 的祖先并且 $v$ 不为 $u$ 的祖先，那么 $u, v$ 分别处于 $\operatorname{LCA}(u, v)$ 的两棵不同子树中；  </li>
<li>前序遍历中， $\operatorname{LCA}(S)$ 出现在所有 $S$ 中元素之前，后序遍历中 $\operatorname{LCA}(S)$ 则出现在所有 $S$ 中元素之后；  </li>
<li>两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $\operatorname{LCA}(A \cup B)=\operatorname{LCA}(\operatorname{LCA}(A), \operatorname{LCA}(B)) ；$  </li>
<li>两点的最近公共祖先必定处在树上两点间的最短路上；  </li>
<li>$d(u, v)=h(u)+h(v)-2 h(\operatorname{LCA}(u, v))$ ，其中 $d$ 是树上两点间的距离， $h$ 代表某点到树根的距离。</li>
</ol>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>常用工具</tag>
        <tag>tarjan</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/posts/2cf738e6/</url>
    <content><![CDATA[<h2 id="1-P1495-【模板】中国剩余定理（CRT）-曹冲养猪-洛谷"><a href="#1-P1495-【模板】中国剩余定理（CRT）-曹冲养猪-洛谷" class="headerlink" title="1 P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪 - 洛谷"></a>1 <a href="https://www.luogu.com.cn/problem/P1495">P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪 - 洛谷</a></h2>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/posts/9947c71c/</url>
    <content><![CDATA[<p>二分查找：在一个已知的有序数据集上进行二分地查找<br>二分答案：答案有一个区间，在这个区间中二分，直到找到最优答案</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><h6 id="模板-1："><a href="#模板-1：" class="headerlink" title="模板 1："></a>模板 1：</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;	<span class="comment">//(l+r)/2</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">check</span>(mid))  r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">	<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="模板-2："><a href="#模板-2：" class="headerlink" title="模板 2："></a>模板 2：</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;	<span class="comment">//(l+r+1)/2</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">check</span>(mid))  l = mid;</span><br><span class="line">	<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个模板是尽量往左找目标，第二个模板是尽量往右找目标。</strong></p>
<h6 id="模板-3：（浮点二分）"><a href="#模板-3：（浮点二分）" class="headerlink" title="模板 3：（浮点二分）"></a>模板 3：（浮点二分）</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">1e-5</span>) <span class="comment">//需要一个精度保证</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid; <span class="comment">//或r=mid;</span></span><br><span class="line">	<span class="keyword">else</span> r=mid; <span class="comment">//或l=mid;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><h5 id="例1——-查找"><a href="#例1——-查找" class="headerlink" title="例1—— 查找"></a>例1—— <a href="https://www.luogu.com.cn/problem/P2249">查找</a></h5><h5 id="例-2——-A-B-数对"><a href="#例-2——-A-B-数对" class="headerlink" title="例 2—— A-B 数对"></a>例 2—— <a href="https://www.luogu.com.cn/problem/P1102">A-B 数对</a></h5><h5 id="例-3——-烦恼的高考志愿"><a href="#例-3——-烦恼的高考志愿" class="headerlink" title="例 3—— 烦恼的高考志愿"></a>例 3—— <a href="https://www.luogu.com.cn/problem/P1678">烦恼的高考志愿</a></h5><h5 id="例-4——-银行贷款"><a href="#例-4——-银行贷款" class="headerlink" title="例 4—— 银行贷款"></a>例 4—— <a href="https://www.luogu.com.cn/problem/P1163">银行贷款</a></h5><h5 id="练习-："><a href="#练习-：" class="headerlink" title="练习 ："></a>练习 ：</h5><p>整数二分 ：  </p>
<h6 id="1、-数的范围"><a href="#1、-数的范围" class="headerlink" title="1、 数的范围"></a>1、 <a href="https://www.acwing.com/problem/content/791/">数的范围</a></h6><h6 id="2-、-砍树"><a href="#2-、-砍树" class="headerlink" title="2 、 砍树"></a>2 、 <a href="https://www.luogu.com.cn/problem/P1873">砍树</a></h6><p>实数二分：  </p>
<h6 id="3-、-数的三次方根"><a href="#3-、-数的三次方根" class="headerlink" title="3 、 数的三次方根"></a>3 、 <a href="https://www.acwing.com/problem/content/792/">数的三次方根</a></h6><h6 id="4-、-一元三次方程求解"><a href="#4-、-一元三次方程求解" class="headerlink" title="4 、 一元三次方程求解"></a>4 、 <a href="https://www.luogu.com.cn/problem/P1024">一元三次方程求解</a></h6><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><h5 id="什么是二分答案？"><a href="#什么是二分答案？" class="headerlink" title="什么是二分答案？"></a>什么是二分答案？</h5><p>答案属于一个区间，当这个区间很大时，暴力超时。但重要的是——<strong>这个区间是对题目中的某个量有单调性的</strong>，此时，我们就会二分答案。每一次二分会做一次判断，看是否对应的那个量达到了需要的大小。<br>判断：根据题意写个 check 函数，如果满足 check，就放弃右半区间（或左半区间），如果不满足，就放弃左半区间（或右半区间）。一直往复，直至到最终的答案。</p>
<h5 id="如何判断一个题是不是用二分答案做"><a href="#如何判断一个题是不是用二分答案做" class="headerlink" title="如何判断一个题是不是用二分答案做?"></a>如何判断一个题是不是用二分答案做?</h5><ul>
<li>答案在一个区间内（一般情况下，区间会很大，暴力超时）</li>
<li>直接搜索不好搜，但是容易判断一个答案可行不可行</li>
<li>该区间对题目具有单调性，即：在区间中的值越大或越小，题目中的某个量对应增加或减少。</li>
</ul>
<p><strong>此外，可能还会有一个典型的特征</strong>：<code>求...最大值的最小 、 求...最小值的最大。</code><br>1、<code>求...最大值的最小</code>，我们二分答案（即二分最大值）的时候，判断条件满足后，尽量让答案往前来（即：让 r=mid），对应模板 1；<br>2、同样，<code>求...最小值的最大</code> 时，我们二分答案（即二分最小值）的时候，判断条件满足后，尽量让答案往后走（即：让 l=mid），对应模板 2；</p>
<h5 id="例-1——-木材加工"><a href="#例-1——-木材加工" class="headerlink" title="例 1—— 木材加工"></a>例 1—— <a href="https://www.luogu.com.cn/problem/P2440">木材加工</a></h5><h5 id="例-2——-跳石头"><a href="#例-2——-跳石头" class="headerlink" title="例 2—— 跳石头"></a>例 2—— <a href="https://www.luogu.com.cn/problem/P2678">跳石头</a></h5><h5 id="例-3——-丢瓶盖"><a href="#例-3——-丢瓶盖" class="headerlink" title="例 3—— 丢瓶盖"></a>例 3—— <a href="https://nanti.jisuanke.com/t/T1878">丢瓶盖</a></h5><h5 id="例-4——-数列分段-Section-II"><a href="#例-4——-数列分段-Section-II" class="headerlink" title="例 4—— 数列分段 Section II"></a>例 4—— <a href="https://www.luogu.com.cn/problem/P1182">数列分段 Section II</a></h5><h5 id="练习-：-1"><a href="#练习-：-1" class="headerlink" title="练习 ："></a>练习 ：</h5><h6 id="1-、进击的奶牛"><a href="#1-、进击的奶牛" class="headerlink" title="1 、进击的奶牛"></a>1 、<a href="https://www.luogu.com.cn/problem/P1824">进击的奶牛</a></h6><h6 id="2-、路标设置"><a href="#2-、路标设置" class="headerlink" title="2 、路标设置"></a>2 、<a href="https://www.luogu.com.cn/problem/P3853">路标设置</a></h6><h6 id="3-、最佳牛围栏"><a href="#3-、最佳牛围栏" class="headerlink" title="3 、最佳牛围栏"></a>3 、<a href="https://www.acwing.com/problem/content/104/">最佳牛围栏</a></h6><h6 id="4-、kotori-的设备"><a href="#4-、kotori-的设备" class="headerlink" title="4 、kotori 的设备"></a>4 、<a href="https://www.luogu.com.cn/problem/P3743">kotori 的设备</a></h6>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>二分</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>原根</title>
    <url>/posts/ad6bcf40/</url>
    <content><![CDATA[<ul>
<li><a href="https://zhuanlan.zhihu.com/p/591377528">还算详尽的一篇关于原根的文章</a></li>
<li><a href="https://oi-wiki.org/math/number-theory/primitive-root/#%E5%8E%9F%E6%A0%B9">原根的相关证明</a></li>
</ul>
<h1 id="阶："><a href="#阶：" class="headerlink" title="阶："></a>阶：</h1><ul>
<li>定义：满足同余式 $a^n \equiv 1 \pmod m$ 的最小正整数 $n$ 存在，这个 $n$ 称作 $a$ 模 $m$ 的阶，记作 $\delta_m(a)$ 或 $\operatorname{ord}_m(a).$</li>
</ul>
<blockquote>
<p>由欧拉定理可知，对 $a\in \mathbf{Z}$，$m\in\mathbf{N}^{*}$，若 $(a,m)=1$，则 $a^{\varphi(m)}\equiv 1\pmod m$.</p>
</blockquote>
<ul>
<li>性质：</li>
</ul>
<blockquote>
<ol>
<li><p>$a$, $a^2$, $\cdots$, $a^{\delta_m(a)}$ 模 $m$ 两两不同余。</p>
</li>
<li><p>若 $a^n \equiv 1 \pmod m$，则 $\delta_m(a)\mid n.$</p>
</li>
<li><p>若 $a^p\equiv a^q\pmod m$，则有 $p\equiv q\pmod{\delta_m(a)}.$</p>
</li>
<li><p>设 $m\in\mathbf{N}^{*}$，$a$, $b\in\mathbf{Z}$，$(a,m)=(b,m)=1$，则</p>
</li>
</ol>
<p>$\delta_m(ab)=\delta_m(a)\delta_m(b)$<br>的充分必要条件是<br>$\left(\delta_m(a), \delta_m(b)\right)=1$</p>
<ol>
<li>设 $k \in \mathbf{N}$，$m\in \mathbf{N}^{*}$，$a\in\mathbf{Z}$，$(a,m)=1$，则<br>$\delta_m(a^k)=\dfrac{\delta_m(a)}{\left(\delta_m(a),k\right)}$</li>
</ol>
</blockquote>
<h1 id="原根："><a href="#原根：" class="headerlink" title="原根："></a>原根：</h1><ul>
<li>定义：设 $m \in \mathbf{N}^{*}$，$g\in \mathbf{Z}$. 若 $(g,m)=1$，且 $\delta_m(g)=\varphi(m)$，则称 $g$ 为模 $m$ 的原根。</li>
</ul>
<blockquote>
<p>即 $g$ 满足<br>$\delta_m(g) = \left| \mathbf{Z}_m^* \right| = \varphi(m)$. 当 $m$ 是质数时，我们有 $g^i \bmod m,\,0 \lt i \lt m$ 的结果互不相同。</p>
</blockquote>
<h2 id="1-原根判定定理"><a href="#1-原根判定定理" class="headerlink" title="1 原根判定定理:"></a>1 原根判定定理:</h2><p>设 $m \geqslant 3, (g,m)=1$，则 $g$ 是模 $m$ 的原根的充要条件是，对于 $\varphi(m)$ 的每个素因数 $p$，都有<br> $g^{\frac{\varphi(m)}{p}}\not\equiv 1\pmod m.$</p>
<h2 id="2-原根存在定理"><a href="#2-原根存在定理" class="headerlink" title="2 原根存在定理:"></a>2 原根存在定理:</h2><p>一个数 $m$ 存在原根当且仅当 $m=2,4,p^{\alpha},2p^{\alpha}$，其中 $p$ 为奇素数，$\alpha\in \mathbf{N}^{*}.$</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>基环树</title>
    <url>/posts/70f2f90a/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/blog/user52918/qian-tan-ji-huan-shu">基环树瞎吹 - QuantAsk的博客 - 洛谷博客</a><br>基环树的一个比较详细的解释。<br>[[P2607 骑士 - 洛谷]]<br>[[P1453 城市环路 - 洛谷]]<br>[[P1352 没有上司的舞会 - 洛谷]]</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和</title>
    <url>/posts/8628805/</url>
    <content><![CDATA[<h1 id="1-B3612-【深进1-例1】求区间和-洛谷"><a href="#1-B3612-【深进1-例1】求区间和-洛谷" class="headerlink" title="1 B3612 【深进1.例1】求区间和 - 洛谷"></a>1 <a href="https://www.luogu.com.cn/problem/B3612">B3612 【深进1.例1】求区间和 - 洛谷</a></h1><h2 id="1-代码"><a href="#1-代码" class="headerlink" title="1 代码"></a>1 代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, l, r, a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r,cout &lt;&lt; a[r] - a[l - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2 题目描述"></a>2 题目描述</h2><p>给定 $n$ 个正整数组成的数列 $a_1, a_2, \cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。</p>
<h2 id="3-输入格式"><a href="#3-输入格式" class="headerlink" title="3 输入格式"></a>3 输入格式</h2><script type="math/tex; mode=display">
\boxed{ 
\begin{align}
&n &\\ &a_{1} \  a_2  \cdots \ a_n \\ &m \\&l_1\ \ r_1 \\&l_2\ \ r_2\\ &\vdots \\&l_m\ r_m​
\end{align}
}</script><p>满足 $1\le l_i\le r_i\le n$ , $1 \leq n,m\le 10^5$，$1 \leq a_i\le 10^4$。 </p>
<h2 id="4-输出格式"><a href="#4-输出格式" class="headerlink" title="4 输出格式"></a>4 输出格式</h2><script type="math/tex; mode=display">
\boxed{ 
\begin{align}
&res_1 \\ &res_2 \\ &\vdots \\&res_m​
\end{align}
}</script><p>共 $m$ 行。</p>
<p>第 $i$ 行为第 $i$ 组答案的询问。</p>
<h2 id="5-样例-1"><a href="#5-样例-1" class="headerlink" title="5 样例 #1"></a>5 样例 #1</h2><h3 id="5-1-样例输入-1"><a href="#5-1-样例输入-1" class="headerlink" title="5.1 样例输入 #1"></a>5.1 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4 3 2 1</span><br><span class="line">2</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="5-2-样例输出-1"><a href="#5-2-样例输出-1" class="headerlink" title="5.2 样例输出 #1"></a>5.2 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>常用工具</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂 &amp; 矩阵运算</title>
    <url>/posts/2bd61477/</url>
    <content><![CDATA[<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><p><mark style="background: #FFB8EBA6;">注意开 long long</mark><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y % <span class="number">2</span>)</span><br><span class="line">            ans = (ans * x) % p;</span><br><span class="line">        x = (x * x) % p;</span><br><span class="line">        y /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-矩阵计算"><a href="#2-矩阵计算" class="headerlink" title="2 矩阵计算"></a>2 矩阵计算</h2><p>![[../../../images/Z-attachment/屏幕截图 2023-11-21 183403.png]]</p>
<h2 id="3-示例-P1962-斐波那契数列-洛谷"><a href="#3-示例-P1962-斐波那契数列-洛谷" class="headerlink" title="3 示例: P1962 斐波那契数列 - 洛谷"></a>3 示例: <a href="https://www.luogu.com.cn/problem/P1962">P1962 斐波那契数列 - 洛谷</a></h2><p>计算斐波那契数列，$\Huge{n \le 2^{63}}$<br>可得:</p>
<p>$\begin{aligned} \begin{bmatrix}F<em>n\ F</em>{n+1}\end{bmatrix} &amp;= A\begin{bmatrix}F<em>{n-1}\ F_n\end{bmatrix}=A^2\begin{bmatrix}F</em>{n-2}\ F_{n-1}\end{bmatrix}=…&amp;=A^{n-1}\begin{bmatrix}F_1\ F_2\end{bmatrix}=A^{n-1}\begin{bmatrix}1\ 1\end{bmatrix} \end{aligned}$ , $A=\begin{bmatrix}0 &amp;1\ 1 &amp; 1\end{bmatrix}$ </p>
<figure class="highlight cpp"><figcaption><span>TI:"矩阵运算|快速幂"</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span></span><br><span class="line">&#123;</span><br><span class="line">    ll a1, a2, b1, b2;</span><br><span class="line">    <span class="built_in">matrix</span>(ll a1, ll a2, ll b1, ll b2) : <span class="built_in">a1</span>(a1), <span class="built_in">a2</span>(a2), <span class="built_in">b1</span>(b1), <span class="built_in">b2</span>(b2) &#123;&#125;</span><br><span class="line">    matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix &amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">matrix <span class="title">ans</span><span class="params">((a1 * y.a1 + a2 * y.b1) % MOD,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (a1 * y.a2 + a2 * y.b2) % MOD,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (b1 * y.a1 + b2 * y.b1) % MOD,</span></span></span><br><span class="line"><span class="params"><span class="function">                   (b1 * y.a2 + b2 * y.b2) % MOD)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">matrix <span class="title">ans</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span></span>; <span class="comment">//单位矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="function">matrix <span class="title">M</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">    matrix ans = <span class="built_in">qpow</span>(M, x - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ans.a1 + ans.a2) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-练习-P1939-矩阵加速（数列）-洛谷"><a href="#4-练习-P1939-矩阵加速（数列）-洛谷" class="headerlink" title="4 练习: P1939 矩阵加速（数列） - 洛谷"></a>4 练习: <a href="https://www.luogu.com.cn/problem/P1939">P1939 矩阵加速（数列） - 洛谷</a></h2><p>已知一个数列 $a$，它满足：  </p>
<script type="math/tex; mode=display">
a_x=
\begin{cases}
 1 & x \in\{1,2,3\}\\ 
 a_{x-1}+a_{x-3} & x \geq 4
\end{cases}</script><p>求 $a$ 数列的第 $n$ 项对 $10^9+7$ 取余的值。</p>
<ul>
<li>对于 $100\%$ 的数据 $1 \leq T \leq 100$，$1 \leq n \leq 2 \times 10^9$。</li>
</ul>
<p>找出 $A$ 矩阵即可。不一样的地方是 $A$ 矩阵是 3 维的。<br>![[../../../images/Z-attachment/{222E6BF3-59E1-4bad-8B4A-3D65C9496B64}.png]]</p>
<h2 id="5-练习：-B3646-数列前缀和-3-洛谷"><a href="#5-练习：-B3646-数列前缀和-3-洛谷" class="headerlink" title="5 练习： [[B3646 数列前缀和 3 - 洛谷]]"></a>5 练习： [[B3646 数列前缀和 3 - 洛谷]]</h2><p><a href="https://www.luogu.com.cn/problem/B3646">链接</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>#快速幂</tag>
        <tag>#模板</tag>
        <tag>矩阵运算</tag>
      </tags>
  </entry>
  <entry>
    <title>威尔逊定理</title>
    <url>/posts/c43e98b8/</url>
    <content><![CDATA[<h2 id="1-威尔逊定理"><a href="#1-威尔逊定理" class="headerlink" title="1 威尔逊定理"></a>1 威尔逊定理</h2><p><strong>内容：</strong><br>对于素数 $p$ 有 $(p-1)!\equiv -1\pmod p.$</p>
<p><strong>推论：</strong><br>$(p-1)!\equiv0(mod$ $p),(p&gt;4\land p$ 为合数$ )$</p>
<p> <strong><mark style="background: #CACFD9A6;">计算余数算法</mark>:</strong></p>
<p>实现 $n!$ % $p$.</p>
<p><strong>时间复杂度：</strong> 时间复杂度为 $O(p + \log_p n)$. 如果需要多次调用函数，则可以在函数外部进行预计算，于是计算 $(n!)_p$ 的时间复杂度为 $O(\log_p n).$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factmod</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(p)</span></span>;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; p; i++) f[i] = f[i - <span class="number">1</span>] * i % p;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((n / p) % <span class="number">2</span>) res = p - res;</span><br><span class="line">    res = res * f[n % p] % p;</span><br><span class="line">    n /= p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Legendre-公式"><a href="#2-Legendre-公式" class="headerlink" title="2 $Legendre$ 公式:"></a>2 <strong>$Legendre$ 公式:</strong></h2><p>$n!$ 中含有的素数 $p$ 的幂次 $v_p(n!)$ 为：</p>
<p>$v<em>p(n!) = \sum</em>{i=1}^{\infty} \left\lfloor \frac{n}{p^i} \right\rfloor = \frac{n-S_p(n)}{p-1}$<br>其中 $S_p(n)$ 为 $p$ 进制下 $n$ 的各个数位的和。</p>
<p>特别地，阶乘中 2 的幂次是 $v_2(n!)=n-S_2(n).$</p>
<p>$O(logn)$ 实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiplicity_factorial</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    n /= p;</span><br><span class="line">    count += n;</span><br><span class="line">  &#125; <span class="keyword">while</span> (n);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Kummer-定理"><a href="#3-Kummer-定理" class="headerlink" title="3 $Kummer$ 定理:"></a>3 $Kummer$ <strong>定理:</strong></h2><p>$p$ 在组合数<br>$\dbinom{m}{n}$ 中的幂次，恰好是 $p$ 进制下 $m$ 减掉 $n$ 需要借位的次数。</p>
<p>即<br>$v_p\left(\dbinom{m}{n}\right)=\frac{S_p(n)+S_p(m-n)-S_p(m)}{p-1}$</p>
<p>特别地，组合数中 2 的幂次是<br>$v_2\left(\dbinom{m}{n}\right)=S_2(n)+S_2(m-n)-S_2(m).$</p>
<h2 id="4-Wilson-定理的推广"><a href="#4-Wilson-定理的推广" class="headerlink" title="4 $Wilson$ 定理的推广:"></a>4 $Wilson$ <strong>定理的推广:</strong></h2><p>对于素数 $p$和正整数 $q$ 有 $(p^q!)_p\equiv \pm 1\pmod{p^q}.$</p>
<script type="math/tex; mode=display">(p^q!)_p\equiv
\begin{cases}
  1,  & (p=2) \land (q\geq 3),\\
  -1, & \text{otherwise}.
\end{cases}</script>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/c517589e/</url>
    <content><![CDATA[<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10010</span>];</span><br><span class="line"><span class="comment">// int find(int x)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     while (x != f[x])</span></span><br><span class="line"><span class="comment">//         x = f[x] = f[f[x]];</span></span><br><span class="line"><span class="comment">//     return x;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==f[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int find(int x)//或者这样写</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   return x == f[x] ? x : (f[x] = find(f[x]));</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a==b)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Y&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-练习"><a href="#2-练习" class="headerlink" title="2 练习"></a>2 练习</h2><h3 id="2-1-P1551-亲戚-洛谷"><a href="#2-1-P1551-亲戚-洛谷" class="headerlink" title="2.1 P1551 亲戚 - 洛谷 "></a>2.1 <a href="https://www.luogu.com.cn/problem/P1551">P1551 亲戚 - 洛谷 </a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, p;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : (f[x] = <span class="built_in">find</span>(f[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">        f[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(x), b = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-P-3958-NOIP-2017-提高组-奶酪-洛谷"><a href="#2-2-P-3958-NOIP-2017-提高组-奶酪-洛谷" class="headerlink" title="2.2 P 3958 [NOIP 2017 提高组] 奶酪 - 洛谷"></a>2.2 <a href="https://www.luogu.com.cn/problem/P3958">P 3958 [NOIP 2017 提高组] 奶酪 - 洛谷</a></h3>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/posts/fb40efc5/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/260112913">算法学习笔记(53): 拓扑排序 - 知乎</a></p>
<p>以下是一个 $O(n+m)$ 的实现（ $n,m$ 分别表示点数和边数），利用了队列：<br>一般使用的是<mark style="background: #FFB8EBA6;">邻接表</mark>存储图</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deg 是入度，在存图的时候需要录入数据</span></span><br><span class="line"><span class="comment">// A 是排序后的数组</span></span><br><span class="line"><span class="type">int</span> deg[MAXN], A[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span> <span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!deg[i])</span><br><span class="line">            q.<span class="built_in">push</span> (i);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span> ())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span> ();</span><br><span class="line">        q.<span class="built_in">pop</span> ();</span><br><span class="line">        A[cnt++] = t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to : edges[t])</span><br><span class="line">        &#123;</span><br><span class="line">            deg[to]--;</span><br><span class="line">            <span class="keyword">if</span> (!deg[to]) <span class="comment">// 出现了新的入度为 0 的点</span></span><br><span class="line">                q.<span class="built_in">push</span> (to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值为是否成功进行拓扑排序，也即是否存在环。也就是说拓扑排序是可以用来简单地判环的。有时会要求输出字典序最小的方案，这时把 <code>queue</code> 改成 <code>priority_queue</code> 即可，复杂度会多一个 $\log$。<br>[[B3644 拓扑排序 &amp; 家谱树 - 洛谷]]<a href="https://www.luogu.com.cn/problem/B3644">B3644 【模板】拓扑排序 / 家谱树 - 洛谷</a><br>练习：<br>[[510C]] <a href="https://codeforces.com/contest/510/problem/C">Problem - C - Codeforces</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>常用工具</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展欧几里得</title>
    <url>/posts/68bc28a9/</url>
    <content><![CDATA[<p><strong>欧几里得算法</strong>：$gcd(a,b)=gcd(b,a$ $mod$ $b)$</p>
<p><a href="https://oi-wiki.org/math/number-theory/gcd/">证明</a></p>
<p><strong>扩展欧几里得算法</strong>$:(Extended Euclidean algorithm, EXGCD)$</p>
<p><mark style="background: #BBFABBA6;">常用于</mark>求  <script type="math/tex">ax+by=gcd (a, b)</script> <mark style="background: #D2B3FFA6;">的一组可行解</mark>。</p>
<p> $ax_1+by_1=ay_2+bx_2-\lfloor\frac{a}{b}\rfloor\times by_2=ay_2+b(x_2-\lfloor\frac{a}{b}\rfloor y_2)$</p>
<p> $a=a,b=b$ ,$\Rightarrow$  $x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor y_2$</p>
<p>将 $x_2,y_2$ 不断代入递归求解直至 $gcd$$($ 最大公约数，下同 $)$ 为 $0$ 递归<br>$x=1,y=0$ 回去求解。</p>
<p><a href="https://oi-wiki.org/math/number-theory/gcd/">证明</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> d = <span class="built_in">Exgcd</span>(b, a % b, x, y);</span><br><span class="line">  <span class="type">int</span> t = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = t - (a / b) * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>非递归：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> x1 = <span class="number">0</span>, y1 = <span class="number">1</span>, a1 = a, b1 = b;</span><br><span class="line">  <span class="keyword">while</span> (b1) &#123;</span><br><span class="line">    <span class="type">int</span> q = a1 / b1;</span><br><span class="line">    <span class="built_in">tie</span>(x, x1) = <span class="built_in">make_tuple</span>(x1, x - q * x1);</span><br><span class="line">    <span class="built_in">tie</span>(y, y1) = <span class="built_in">make_tuple</span>(y1, y - q * y1);</span><br><span class="line">    <span class="built_in">tie</span>(a1, b1) = <span class="built_in">make_tuple</span>(b1, a1 - q * b1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>矩阵法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x1 = <span class="number">1</span>, x2 = <span class="number">0</span>, x3 = <span class="number">0</span>, x4 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> c = a / b;</span><br><span class="line">    std::<span class="built_in">tie</span>(x1, x2, x3, x4, a, b) =</span><br><span class="line">        std::<span class="built_in">make_tuple</span>(x3, x4, x1 - x3 * c, x2 - x4 * c, b, a - b * c);</span><br><span class="line">  &#125;</span><br><span class="line">  x = x1, y = x2;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>常用工具</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/posts/9acb5cb3/</url>
    <content><![CDATA[<h1 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h1><p><mark style="background: #CACFD9A6;">Kruskal 算法</mark><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//kruskal算法</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> u, v, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, val;</span><br><span class="line">&#125; a[<span class="number">200010</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// while(x!=f[x])</span></span><br><span class="line">    <span class="comment">//     x = f[x] = f[f[x]];</span></span><br><span class="line">    <span class="comment">// return x;</span></span><br><span class="line">    <span class="keyword">if</span> (f[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = <span class="built_in">find</span>(a[i].x);</span><br><span class="line">        v = <span class="built_in">find</span>(a[i].y);</span><br><span class="line">        <span class="keyword">if</span> (u == v)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ans += a[i].val;</span><br><span class="line">        f[u] = v;</span><br><span class="line">        <span class="keyword">if</span> (++cnt == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].val;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span> (cnt != n - <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h1><h2 id="1-朴素的-prim-算法"><a href="#1-朴素的-prim-算法" class="headerlink" title="1 朴素的 prim 算法"></a>1 朴素的 prim 算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//朴素的prim算法</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dis[N]; </span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//随便从一个起点开始</span></span><br><span class="line">    <span class="type">int</span> num = n, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num--)</span><br><span class="line">    &#123;              <span class="comment">//对于连通图，必须要循环n次才能到所有顶点，获得最小生成树，非连通图会中途break</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//结点是从1开始的，t=0，此时说明还没开始待选</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; (!t || dis[i] &lt; dis[t]))</span><br><span class="line">                t = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[t] == INF)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//存在顶点不可达，说明是不存在生成树</span></span><br><span class="line">        vis[t] = <span class="literal">true</span>; <span class="comment">//否则，顶点t加入集合</span></span><br><span class="line">        res += dis[t]; <span class="comment">//计算生成树的代价,第一次循环时必为事先初始化的1号顶点，dis为0，相当于不加</span></span><br><span class="line">        <span class="comment">//开始更新到集合(顶点t)的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &gt; g[t][i])</span><br><span class="line">                dis[i] = g[t][i];</span><br><span class="line">            <span class="comment">//&quot;只更新不在集合中的点，维护dis数组的含义，所以dis[t]不会被更新，就算自环是负值也不会被更新。&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">//返回最小生成树的代价</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);         </span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    t == <span class="number">-1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;orz&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-堆优化版"><a href="#2-堆优化版" class="headerlink" title="2 堆优化版"></a>2 堆优化版</h2><p> <mark style="background: #FFB8EBA6;">Prim 堆优化版</mark><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//prim堆优化版</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; <span class="comment">//&lt;距离，顶点&gt;</span></span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">2e5</span> + <span class="number">10</span>; <span class="comment">//无向图，边数要乘2</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">//判断是否已经加入生成树的集合</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;dis[<span class="number">1</span>], <span class="number">1</span>&#125;); <span class="comment">//本来还应该剩下的顶点都放进去，然后进行更新就行了，但是stl中的堆不能实现按关键字更新，</span></span><br><span class="line">    <span class="type">int</span> num = n, res = <span class="number">0</span>;   <span class="comment">//用插入代替更新，所以，剩下的点就不放入了，更新到时再放入</span></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &amp;&amp; num)</span><br><span class="line">    &#123; <span class="comment">//这里为什么这么写,原因同dijkstra</span></span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> v = t.second, d = t.first;</span><br><span class="line">        <span class="comment">//&quot;此时取出的d必不可能是INF，因为前面加入堆的原因就是它被更新过&quot; </span></span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>; <span class="comment">//如果v已经在生成树中了，本次循环无效，开始下一次，后面不再执行</span></span><br><span class="line">        vis[v] = <span class="literal">true</span>, res += d, num--;                                                      <span class="comment">//否则，加入生成树</span></span><br><span class="line">        <span class="comment">//修改未在生成树中的点到集合的最短距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[v]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i]; <span class="comment">// v-&gt;e[i]的边,权值为w[i]</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &gt; w[i])</span><br><span class="line">                dis[j] = w[i], heap.<span class="built_in">push</span>(&#123;dis[j], j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//&quot;只有当v到其它顶点可达或者距离更小，才会更新，因此每次取出的d都不是INF,当都不可达时，队列就为null了&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&quot;判断是因为什么原因退出？是因为堆空，还是有效循环num次完了&quot;</span></span><br><span class="line">    <span class="comment">//&quot;因为堆空退出说明图是非连通图，存在不可达点,此时num&gt;0;但是如果num==0，说明已经得到了生成树。&quot; </span></span><br><span class="line">    <span class="keyword">return</span> num? <span class="number">-1</span>: res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">//&quot;切记，邻接表存储时要初始化h数组&quot; </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    t == <span class="number">-1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>) : <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>最长不下降子序列</title>
    <url>/posts/9dcdb1c9/</url>
    <content><![CDATA[<h1 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h1><p><mark style="background: #CACFD9A6;">这里的注释说明更易理解</mark><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="comment">// 0个元素特判一下</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;0&#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>] = a[<span class="number">1</span>]; <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= d[len])</span><br><span class="line">            d[++len] = a[i]; </span><br><span class="line">    <span class="comment">//如果可以接在len后面就接上，如果是最长上升子序列，这里变成&gt;</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则就找一个最该替换的替换掉</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">upper_bound</span>(d + <span class="number">1</span>, d + len + <span class="number">1</span>, a[i]) - d; </span><br><span class="line"><span class="comment">//找到第一个大于它的d的下标，如果是最长上升子序列，这里变成lower_bound</span></span><br><span class="line">            d[j] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最长不上升子序列"><a href="#最长不上升子序列" class="headerlink" title="最长不上升子序列"></a>最长不上升子序列</h1><p>同理，稍改。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N;</span><br><span class="line"><span class="type">int</span> a[MAXN], d[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;0&#x27;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=d[len])</span><br><span class="line">            d[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + len, a[i], <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - d;</span><br><span class="line">            d[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="最长不下降子序列的内容"><a href="#最长不下降子序列的内容" class="headerlink" title="最长不下降子序列的内容"></a>最长不下降子序列的内容</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000010</span>], dp[<span class="number">1000010</span>], poa[<span class="number">1000010</span>],ana[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    poa[<span class="number">1</span>] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= dp[len])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[++len] = a[i];</span><br><span class="line">            poa[i] = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(dp + <span class="number">1</span>, dp + len + <span class="number">1</span>, a[i]) - dp;</span><br><span class="line">            dp[pos] = a[i];</span><br><span class="line">            poa[i] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (poa[i] == len)</span><br><span class="line">            ana[len] = i,len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        cout &lt;&lt; a[ana[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>dp</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/posts/b5073ecc/</url>
    <content><![CDATA[<p>示例<br><a href="https://www.luogu.com.cn/problem/P1020">P1020 导弹拦截</a><br>用到了求最长下降子序列和 [[最长上升子序列]] ，还用到了 $Dilworth 定理$ 证明第二问是最长上升子序列。</p>
<p>若 $n=0$，则需要特判。</p>
<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p>目前我笔记有三种写法，第一种即可。<br> <mark style="background: #CACFD9A6;">推荐 1</mark></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//标准模板</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N;</span><br><span class="line"><span class="type">int</span> a[MAXN], d[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">//if(n==0)//后面不再重复写出</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &#x27;0&#x27; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//    return 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;d[len])</span><br><span class="line">            d[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + len, a[i]) - d;</span><br><span class="line">            d[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><mark style="background: #CACFD9A6;">推荐 2</mark><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//模板</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span>(x--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        cin &gt;&gt; y;</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), nums[i]) - vec.<span class="built_in">begin</span>(); <span class="comment">//二分查找，返回大于等于nums[i]的第一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (p == vec.<span class="built_in">size</span>())                                                </span><br><span class="line">            vec.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            vec[p] = nums[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; vec.<span class="built_in">size</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><mark style="background: #CACFD9A6;">推荐 3</mark><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//边输入边计算，有时不适用</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), t);</span><br><span class="line">        <span class="keyword">if</span> (it != d.<span class="built_in">end</span>())</span><br><span class="line">            *it = t;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最长下降子序列"><a href="#最长下降子序列" class="headerlink" title="最长下降子序列"></a>最长下降子序列</h1><p>和上面的代码思路一模一样，稍改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//标准模板</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = N;</span><br><span class="line"><span class="type">int</span> a[MAXN], d[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;d[len])</span><br><span class="line">            d[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + len, a[i],<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - d;</span><br><span class="line">            d[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>dp</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉定理</title>
    <url>/posts/b43957a0/</url>
    <content><![CDATA[<ul>
<li><a href="https://zhuanlan.zhihu.com/p/349304172">相关文章</a><h1 id="欧拉函数："><a href="#欧拉函数：" class="headerlink" title="欧拉函数："></a>欧拉函数：</h1></li>
</ul>
<p><a href="https://oi-wiki.org/math/number-theory/euler-totient/">欧拉函数</a> $(Euler’s totient function)$ 内容：即 $\varphi(n)$，表示的是小于等于 $n$ 和 $n$ 互质的数的个数。</p>
<p>性质：</p>
<ul>
<li><p>欧拉函数是积性函数。如果有 $\gcd(a, b) = 1$，那么 $\varphi(a \times b) = \varphi(a) \times \varphi(b)$。特别地，当 $n$ 是奇数时 $\varphi(2n) = \varphi(n)$。</p>
</li>
<li><p>$n = \sum_{d \mid n}{\varphi(d)}$。</p>
</li>
<li><p>若 $n = p^k$，其中 $p$ 是质数，那么 $\varphi(n) = p^k - p^{k - 1}$。 （根据定义可知）</p>
</li>
<li><p>由唯一分解定理，设 $n = \prod<em>{i=1}^{s}p_i^{k_i}$，其中$p_i$ 是质数，有<br>$\varphi(n) = n \times \prod</em>{i = 1}^s{\dfrac{p_i - 1}{p_i}}$。</p>
</li>
</ul>
<p>实现：</p>
<p>只要求一个数的欧拉函数值:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">      ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是多个数的欧拉函数值: 详见：<a href="https://oi-wiki.org/math/number-theory/sieve/#%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">筛法求欧拉函数</a></p>
<p>有：</p>
<script type="math/tex; mode=display">\begin{aligned}
\varphi(n) & = \varphi(p_1) \times \varphi(n') \\\\
& = (p_1 - 1) \times \varphi(n')
\end{aligned}</script><h1 id="欧拉定理："><a href="#欧拉定理：" class="headerlink" title="欧拉定理："></a>欧拉定理：</h1><p><a href="https://oi-wiki.org/math/number-theory/fermat/#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">欧拉定理</a> 0 $(Euler’s theorem)$ 内容：若 $\gcd(a, m) = 1$，则 $a^{\varphi(m)} \equiv 1 \pmod{m}$。</p>
<blockquote>
<p>费马小定理可以看作当$m$ 是质数 $p$ 时欧拉定理的一个特殊情形。</p>
</blockquote>
<h1 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理:"></a>扩展欧拉定理:</h1><p><a href="https://oi-wiki.org/math/number-theory/fermat/#%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86">扩展欧拉定理</a>内容：</p>
<script type="math/tex; mode=display">a^b \equiv \begin{cases}
  A^{b \bmod \varphi (m)},                &\gcd (a, m) =  1,                   \\
  A^b,                                   &\gcd (a, m)\ne 1, b <   \varphi (m), \\
  A^{(b \bmod \varphi (m)) + \varphi (m)}, &\gcd (a, m)\ne 1, b \ge \varphi (m).
\end{cases} \pmod m</script>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>离散化</title>
    <url>/posts/515818b4/</url>
    <content><![CDATA[<h2 id="1-如何实现离散化？"><a href="#1-如何实现离散化？" class="headerlink" title="1 如何实现离散化？"></a>1 如何实现离散化？</h2><p>![[../../../images/Z-attachment/Pasted image 20231126151937.png]]</p>
<h2 id="2-解析"><a href="#2-解析" class="headerlink" title="2 解析"></a>2 解析</h2><p>我们可以发现，最后归位后的数组就对应的是 $Rank$ 的值，因此这道题就是去求出最后的数组。注意本题要去重，因此在离散化之前排序之后要去一遍重。</p>
<p>怎么用代码实现？<br>这道题要有两个数组，一个原数组，设为 $a$。一个离散化归位数组，设为 $d$。输入时要将原数组同步到离散化数组上。</p>
<p>第一步没啥好说的，对原数组排序。</p>
<p>第二步之前要进行去重，我们可以用 STL 中的一个神奇的函数：$Unique$，STL 好闪，拜谢 STL，使用方法跟 $Sort$ 函数一样，只不过没有第三个参数。</p>
<p>具体来说，这个函数可以去除数组中的相邻重复项，并返回指向最后一个前移覆盖位置的迭代器。因此想要完全去重就必须先排序。虽然说是去重，本质上其实是让后面的数覆盖掉重复的数。那么因此我们就可以利用这个函数对原数组进行去重并计算出去重后的个数。</p>
<p>去重后的个数会用到一行神奇的代码：$unique (a+1, a+n+1)-(a+1)$，就能求出去重的个数了，具体原理查百度，不是本题主要内容。</p>
<p>第二步根本就不用写代码，可以直接进第三步。</p>
<p>第三步也要用到一个函数：$lower_bound$ 形式是这样的：$lower_bound (first, last, val)$ 可以查找区间中第一个大于等于 $Val$ 的值，返回指向这个数的下标的迭代器。因此这条语句就可以自动完成归位操作：$d[i]=lower_bound (a+1, a+n+1, d[i])-a$。</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>], d[<span class="number">100005</span>]; <span class="comment">//原数组和离散化数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T, n;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            d[i] = a[i]; <span class="comment">//同步原数组数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);                       <span class="comment">//第一步排序</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">unique</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>) - (a + <span class="number">1</span>); <span class="comment">//去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            d[i] = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + cnt + <span class="number">1</span>, d[i]) - a; <span class="comment">//第三步归位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/posts/dc6556d9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1439">P1439【模板】最长公共子序列</a><br>下面的模板代码只适用于每个数字只出现一次。</p>
<h2 id="1-【模板】最长公共子序列-O-nlogn"><a href="#1-【模板】最长公共子序列-O-nlogn" class="headerlink" title="1 【模板】最长公共子序列: $O(nlogn)$"></a>1 【模板】最长公共子序列: $O(nlogn)$</h2><h3 id="1-1-模板：-最长上升子序列-LIS-的应用-最长上升子序列"><a href="#1-1-模板：-最长上升子序列-LIS-的应用-最长上升子序列" class="headerlink" title="1.1 模板：[[最长上升子序列|LIS]] 的应用 [[最长上升子序列]]"></a>1.1 模板：[[最长上升子序列|LIS]] 的应用 [[最长上升子序列]]</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],d[maxn],idx[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="comment">//完全用的LIS模板，统一模板更不容易错。</span></span><br><span class="line">    <span class="keyword">if</span>(!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;d[len])</span><br><span class="line">            d[++len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + len, a[i]) - d;</span><br><span class="line">            d[pos] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,temp;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;cin&gt;&gt;temp;idx[temp]=i;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;a[i]=idx[a[i]];&#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">LIS</span>(n);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="1-2-手写二分"><a href="#1-2-手写二分" class="headerlink" title="1.2 手写二分"></a>1.2 手写二分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100010</span>], b[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> m[<span class="number">100010</span>], f[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], m[a[i]] = i;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len, mid;</span><br><span class="line">        <span class="keyword">if</span> (m[b[i]] &gt; f[len])</span><br><span class="line">            f[++len] = m[b[i]];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (f[mid] &gt; m[b[i]])</span><br><span class="line">                    r = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[l] = m[b[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最长公共子序列"><a href="#2-最长公共子序列" class="headerlink" title="2 最长公共子序列"></a>2 最长公共子序列</h2><p>目前无时间复杂度小于 $O(N^2)$ 的方法，位压缩已经极限了</p>
<h3 id="2-1-HDU-1159-的示例-字母的子序列-O-n-2"><a href="#2-1-HDU-1159-的示例-字母的子序列-O-n-2" class="headerlink" title="2.1 HDU 1159 的示例 (字母的子序列) $O (n^2)$"></a>2.1 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1159">HDU 1159</a> 的示例 (字母的子序列) $O (n^2)$</h3><p>有这样的递归关系：</p>
<p><img data-src="../../../images/Z-attachment/{B8C7D7FC-E782-45f6-B50A-9F1E57E88F0E}.png" alt=""><br>即<mark style="background: #FF5582A6;">动态转移方程</mark>为：</p>
<p><code>f[i][j]=max&#123;f[i-1][j], f[i][j-1], (f[i-1][j-1]+1) * [S[i]==T[j]&#125;</code></p>
<h4 id="2-1-1-用记忆化搜索解决"><a href="#2-1-1-用记忆化搜索解决" class="headerlink" title="2.1.1 用记忆化搜索解决"></a>2.1.1 用记忆化搜索解决</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a, b;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[n1][n2] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    <span class="keyword">if</span> (!n1 || !n2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[n1 - <span class="number">1</span>] == b[n2 - <span class="number">1</span>])</span><br><span class="line">        dp[n1][n2] = <span class="built_in">LCS</span>(n1 - <span class="number">1</span>, n2 - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[n1][n2] = <span class="built_in">max</span>(<span class="built_in">LCS</span>(n1 - <span class="number">1</span>, n2), <span class="built_in">LCS</span>(n1, n2 - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp), cout &lt;&lt; <span class="built_in">LCS</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-DP-写法"><a href="#2-1-2-DP-写法" class="headerlink" title="2.1.2 DP 写法"></a>2.1.2 DP 写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a, b;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="type">int</span> n1 = a.<span class="built_in">size</span>(), n2 = b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[n1][n2] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>滚动数组可以将空间复杂度优化到 $O (n^2)$</p>
<h4 id="2-1-3-滚动数组优化"><a href="#2-1-3-滚动数组优化" class="headerlink" title="2.1.3 滚动数组优化"></a>2.1.3 滚动数组优化</h4><p>可能有的题会卡空间，滚动数组可以将空间复杂度优化到 $O(n)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">dp2</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                    dp2[j] = dp1[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp2[j] = <span class="built_in">max</span>(dp1[j], dp2[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp1 = dp2;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt; dp2[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-HDU-2253-的示例："><a href="#2-2-HDU-2253-的示例：" class="headerlink" title="2.2 HDU 2253 的示例："></a>2.2 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2253">HDU 2253</a> 的示例：</h3><p><mark style="background: #FF5582A6;">难</mark><br>$len \le 3 \times 10^4$</p>
<p>不能使用 $O(n^2)$ 的方法，且靠二维数组也放不下那么大的内存。$(len^2 =9 \times 10^8)$ </p>
<p>Seems $\Huge{O (\frac {n^2}{32})}$ 这样的话就能过。</p>
<p>似乎是用到了位压缩的方法（不懂）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 30005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORDMAX 3200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT 32</span></span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> s1[M], s2[M];</span><br><span class="line"><span class="type">int</span> nword;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> str[SIZE][WORDMAX];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tmp1[WORDMAX], tmp2[WORDMAX];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="built_in">sizeof</span>(str));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		str[s1[i]][i / BIT] |= <span class="number">1</span> &lt;&lt; (i % BIT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *a, <span class="type">unsigned</span> <span class="type">int</span> *b, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, bottom = <span class="number">1</span>, top;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nword; i++) &#123;</span><br><span class="line">		y = a[i];</span><br><span class="line">		x = y | str[ch][i];</span><br><span class="line">		top = (y &gt;&gt; (BIT - <span class="number">1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">		y = (y &lt;&lt; <span class="number">1</span>) | bottom;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; y) top = <span class="number">1</span>;</span><br><span class="line">		b[i] = x &amp; ((x - y) ^ x);</span><br><span class="line">		bottom = top;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitcnt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, res = <span class="number">0</span>, t;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b[<span class="number">5</span>] = &#123; <span class="number">0x55555555</span>, <span class="number">0x33333333</span>, <span class="number">0x0f0f0f0f</span>, <span class="number">0x00ff00ff</span>, <span class="number">0x0000ffff</span> &#125;, x;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nword; i++) &#123;</span><br><span class="line">		x = a[i];</span><br><span class="line">		t = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++, t &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">			x = (x &amp; b[j]) + ((x &gt;&gt; t) &amp; b[j]);</span><br><span class="line">		res += x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, len1, len2;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *a, *b, *t;</span><br><span class="line">	len1 = <span class="built_in">strlen</span>(s1);</span><br><span class="line">	len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">	nword = (len1 + BIT - <span class="number">1</span>) / BIT;</span><br><span class="line">	<span class="built_in">pre</span>(len1);</span><br><span class="line">	<span class="built_in">memset</span>(tmp1, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp1));</span><br><span class="line">	a = &amp;tmp1[<span class="number">0</span>];</span><br><span class="line">	b = &amp;tmp2[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">		<span class="built_in">cal</span>(a, b, s2[i]);</span><br><span class="line">		t = a; a = b; b = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bitcnt</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, s1, s2) != EOF)</span><br><span class="line">		<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-最长公共子串"><a href="#3-最长公共子串" class="headerlink" title="3 最长公共子串"></a>3 最长公共子串</h2><p>与最长公共子序列思路相同</p>
<h3 id="3-1-模板"><a href="#3-1-模板" class="headerlink" title="3.1 模板"></a>3.1 模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s1 &gt;&gt; s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>(), ma = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)</span><br><span class="line">            <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="number">0</span>;<span class="comment">//一旦没不符合就置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)</span><br><span class="line">            ma = <span class="built_in">max</span>(ma, dp[i][j]);</span><br><span class="line">    cout &lt;&lt; ma &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-示例-Problem-B-Codeforces"><a href="#3-2-示例-Problem-B-Codeforces" class="headerlink" title="3.2 示例: Problem - B - Codeforces"></a>3.2 示例: <a href="https://codeforces.com/contest/1446/problem/B">Problem - B - Codeforces</a></h3><p>求 A，B 所有字串的最长公共子序列中 $Max (\ 4 \times LCS(C, D)\ -|C| -|D|)$ </p>
<p>官方题解：</p>
<blockquote>
<p>Let $DP[i][j]$ be the maximum similarity score if we end the first substring with $A_i$ and the second substring with $B_j$. We will also allow the corresponding most similar string to be empty so that $DP[i][j]$ is always at least $0$.</p>
</blockquote>
<p>如果第一个子串以 $A_i$ 结尾，第二个子串以 $B_j$ 结尾，则 $DP[i][j]$ 为最大相似度得分。我们还将允许相应的最相似字符串为空，这样 $DP[i][j]$ 总是至少是 $0$ .</p>
<blockquote>
<p>It turns out that the fact we need to search for substrings of our words is not a big problem, because we can think of extending the previous ones. In fact, we have just two possibilities:</p>
<ol>
<li>$A_i$ and $B_j$ are the same letters. In this case, we say that $DP[i][j] = min(DP[i][j], DP[i-1][j-1] + 2)$ as the new letter will increase the LCS by $1$, but both of the strings increase by one in length, so the total gain is $4-1-1=2.$</li>
<li>In every case, we can refer to $DP[i][j-1]$ or $DP[i][j-1]$ to extend one of the previous substrings, but not the LCS, so: $DP[i][j] = max (DP[i-1][j], DP[i][j-1]) - 1.$</li>
</ol>
</blockquote>
<p>事实证明，我们需要搜索单词的子串并不是一个大问题，因为我们可以考虑扩展前面的搜索。事实上，我们只有两种可能：</p>
<ol>
<li><p>$A_i$ 和 $B_j$ 是相同的字母。在这种情况下，我们可以说 $DP[i][j]=min (DP[i][j], DP[i−1][j−1]+2)$作为新字母将使 $LCS$ 增加 $1$，但是两个字符串的长度都增加了一个，因此总增益为 $4−1−1=2$。</p>
</li>
<li><p>在每种情况下，我们都可以引用 $DP[i][j−1]$ 或 $DP[i][j−1]$ 来扩展之前的一个子串，但不能扩展 $LCS$，所以：$DP[i][j] = max (DP[i-1][j], DP[i][j-1]) - 1.$ </p>
</li>
</ol>
<blockquote>
<p>An inquisitive reader may wonder why it doesn’t hurt to always apply case $2$ in calculations, so clearing the doubts, it’s important to informally notice that we never get a greater $LCS$ this way so wrong calculations only lead to the worse score, and that our code will always find a sequence of transitions which finds the true $LCS$ as well.<br>Implementing the formulas gives a really short $O(n\cdot m)$ solution.</p>
</blockquote>
<p>好奇的读者可能会问，为什么在计算中总是应用情况 $2$ 并没有什么坏处，为了消除这个疑问，我们有必要非正式地指出，这样我们永远不会得到更大的 $LCS$，所以错误的计算只会导致更糟糕的结果，而且我们的代码总是会找到一个过渡序列，这个序列也会找到真正的 $LCS$。<br>执行这些公式可以得到一个非常简短的 $O (n⋅m)$ 解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n1,n2;</span><br><span class="line">string a,b;<span class="type">int</span> ma;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">5010</span>][<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j] - <span class="number">1</span>, dp[i][j - <span class="number">1</span>] - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)</span><br><span class="line">            ma = <span class="built_in">max</span>(ma, dp[i][j]);</span><br><span class="line">            cout&lt;&lt;ma&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-P2516-最长公共子序列-洛谷"><a href="#4-P2516-最长公共子序列-洛谷" class="headerlink" title="4 P2516 最长公共子序列 - 洛谷"></a>4 <a href="https://www.luogu.com.cn/problem/P2516">P2516 最长公共子序列 - 洛谷</a></h2><p>求 $LCS$ 长度和个数</p>
<h2 id="5-51Nod-1006"><a href="#5-51Nod-1006" class="headerlink" title="5 51Nod-1006"></a>5 <a href="https://vjudge.net/problem/51Nod-1006">51Nod-1006</a></h2><p>求 $LCS$ 具体是什么</p>
<h2 id="6-Hdu1503"><a href="#6-Hdu1503" class="headerlink" title="6 Hdu1503"></a>6 <a href="https://acm.hdu.edu.cn/showproblem.php?pid=1503">Hdu1503</a></h2><p>求根据 $LCS$ 拼接后的字符串</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>dp</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>素数筛法</title>
    <url>/posts/4be0696/</url>
    <content><![CDATA[<h1 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h1><p><strong>线性筛法</strong>(也称为 $Euler$ 筛法（欧拉筛法）)<br>最常用！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      pri[cnt++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1ll</span> * i * pri[j] &gt; n) <span class="keyword">break</span>;</span><br><span class="line">      vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// i % pri[j] == 0</span></span><br><span class="line">        <span class="comment">// 换言之，i 之前被 pri[j] 筛过了</span></span><br><span class="line">        <span class="comment">// 由于 pri 里面质数是从小到大的，所以 i乘上其他的质数的结果一定会被</span></span><br><span class="line">        <span class="comment">// pri[j]的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break</span></span><br><span class="line">        <span class="comment">// 掉就好了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Eratosthenes-筛法"><a href="#Eratosthenes-筛法" class="headerlink" title="$Eratosthenes$ 筛法"></a>$Eratosthenes$ 筛法</h1><p>$Eratosthenes$ 筛法即埃拉托斯特尼筛法, 简称<strong>埃氏筛法</strong>。时间复杂度是 $O(n\log\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Eratosthenes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="number">1</span>;</span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      prime[p++] = i;  <span class="comment">// prime[p]是i,后置自增运算代表当前素数数量</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)i * i &lt;= n)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">          <span class="comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span></span><br><span class="line">          <span class="comment">// 的倍数开始，提高了运行速度</span></span><br><span class="line">          is_prime[j] = <span class="number">0</span>;  <span class="comment">// 是i的倍数的均不是素数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>筛至平方根</strong>到 $O(n \ln \ln \sqrt n + o(n))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Eratosthenes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="number">1</span>;</span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// i * i &lt;= n 说明 i &lt;= sqrt(n)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      prime[p++] = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i) is_prime[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-优化版"><a href="#1-优化版" class="headerlink" title="1 优化版"></a>1 优化版</h2><p><strong>只筛奇数</strong><br>(因为除 2 以外的偶数都是合数，所以我们可以直接跳过它们，只用关心奇数就好。</p>
<p>首先，这样做能让我们内存需求减半；其次，所需的操作大约也减半。)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">	b.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= (<span class="type">int</span>)<span class="built_in">sqrt</span>(n); i += <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">			a[j] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; a[i]) </span><br><span class="line">			b.<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分块筛选"><a href="#分块筛选" class="headerlink" title="分块筛选"></a>分块筛选</h1><p><strong>占用内存及其少</strong>!!!<br>以下实现使用块筛选来计算小于等于 n 的质数数量。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> S = <span class="number">10000</span>;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line">  <span class="type">int</span> nsqrt = <span class="built_in">sqrt</span>(n);</span><br><span class="line">  <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">is_prime</span><span class="params">(nsqrt + <span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= nsqrt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= nsqrt; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">block</span><span class="params">(S)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * S &lt;= n; k++) &#123;</span><br><span class="line">    <span class="built_in">fill</span>(block.<span class="built_in">begin</span>(), block.<span class="built_in">end</span>(), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">int</span> start = k * S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : primes) &#123;</span><br><span class="line">      <span class="type">int</span> start_idx = (start + p - <span class="number">1</span>) / p;</span><br><span class="line">      <span class="type">int</span> j = <span class="built_in">max</span>(start_idx, p) * p - start;</span><br><span class="line">      <span class="keyword">for</span> (; j &lt; S; j += p) block[j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) block[<span class="number">0</span>] = block[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S &amp;&amp; start + i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (block[i]) result++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>分块筛法的渐进时间复杂度与埃氏筛法是一样的（除非块非常小），但是所需的内存将缩小为 $O(\sqrt{n} + S)$，并且有更好的缓存结果。另一方面，对于每一对块和区间 $[1, \sqrt{n}]$ 中的素数都要进行除法，而对于较小的块来说，这种情况要糟糕得多。因此，在选择常数 S 时要保持平衡。</p>
<p>块大小 $S$ 取 $10^4$ 到 $10^5$ 之间，可以获得最佳的速度。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>裴蜀定理</title>
    <url>/posts/294dece0/</url>
    <content><![CDATA[<h2 id="1-内容："><a href="#1-内容：" class="headerlink" title="1 内容："></a>1 内容：</h2><h2 id="2-设-a-b-是不全为零的整数，则存在整数-x-y-使得-ax-by-gcd-a-b"><a href="#2-设-a-b-是不全为零的整数，则存在整数-x-y-使得-ax-by-gcd-a-b" class="headerlink" title="2 设 $a,b$ 是不全为零的整数，则存在整数 $x,y$, 使得 $ax+by=gcd(a,b)$."></a>2 设 $a,b$ 是不全为零的整数，则存在整数 $x,y$, 使得 $ax+by=gcd(a,b)$.</h2><h3 id="2-1-证明："><a href="#2-1-证明：" class="headerlink" title="2.1 证明："></a>2.1 证明：</h3><p>设取 $x_0$, $y_0$ 时，$ax+by$ 的最小整数是 $s$.即 $ax_0+by_0$ = $s$</p>
<p>因 $gcd(a,b)|ax_0$ ， $gcd(a,b)|ay_0$</p>
<p>所以 $gcd(a,b)|s$ $………(1)$</p>
<p>设 $a=qs+r(0\le r\le s)$</p>
<p>$r=a-qs=a-q(ax_0+by_0)=a(1-qx_0)+b(-qy_0)=ax+by$</p>
<p>因为 $s$ 是最小整数，$\Rightarrow r=0$</p>
<p>所以 $s|a$,同理 $s|b$</p>
<p>$\Rightarrow s|gcd(a,b)$ $……….(2)$</p>
<p>由 $(1)(2)$ 可得 $s=gcd(a,b)$.</p>
<p>证毕。</p>
<h2 id="3-逆定理："><a href="#3-逆定理：" class="headerlink" title="3 逆定理："></a>3 逆定理：</h2><p>设 $a, b$ 是不全为零的整数，若 $d &gt; 0$ 是 $a, b$ 的公因数，且存在整数$x, y$, 使得 $ax+by=d$，则 $d = gcd(a, b)$。</p>
<p>特殊地，设 $a, b$ 是不全为零的整数，若存在整数 $x, y$, 使得 $ax+by=1$，则 $a, b$ 互质。</p>
<h2 id="4-进一步结论"><a href="#4-进一步结论" class="headerlink" title="4 进一步结论:"></a>4 进一步结论:</h2><p> 对自然数 $a$、$b$ 和整数 $n$，$a$ 与 $b$ 互素，考察不定方程：<br>                $ax+by=n$<br>其中 $x$ 和 $y$ 为自然数。如果方程有解，称 $n$ 可以被 $a$、$b$ 表示。</p>
<p>记 $C=ab-a-b$。由 $a$ 与 $b$ 互素，$C$ 必然为奇数。则有结论：</p>
<p>对任意的整数 $n$，$n$ 与 $C-n$中有且仅有一个可以被表示。</p>
<p>即：可表示的数与不可表示的数在区间 $[0,C]$ 对称（关于 $C$ 的一半对称）。$0$ 可被表示，$C$ 不可被表示；负数不可被表示，大于 $C$ 的数可被表示。</p>
<p>例如在 $luogu P3951$ 就只是为了求 $ab-a-b$ 的值</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>逆元</title>
    <url>/posts/64311e43/</url>
    <content><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><p>如果一个线性同余方程 $ax \equiv 1 \pmod b$，则 $x$ 称为 $a \bmod b$ 的逆元，记作 $a^{-1}$。</p>
<h2 id="2-费马小定理："><a href="#2-费马小定理：" class="headerlink" title="2 费马小定理："></a>2 费马小定理：</h2><p>$x \equiv a^{b-2} \pmod b$。$p$ 为质数才成立</p>
<h2 id="3-拓展欧几里得-："><a href="#3-拓展欧几里得-：" class="headerlink" title="3 [[拓展欧几里得]]："></a>3 [[拓展欧几里得]]：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Exgcd</span>(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">Exgcd</span> (a, p, x, y);</span><br><span class="line">    x = (x % p + p) % p;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, x); <span class="comment">//x是a在mod p下的逆元</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-线性递推求法："><a href="#4-线性递推求法：" class="headerlink" title="4 线性递推求法："></a>4 线性递推求法：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> inv[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_inv</span><span class="params">(<span class="type">int</span> last,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="comment">//求1~last所有数模p意义下的逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//1的逆元就是1本身</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=last;i++)</span><br><span class="line">        inv[i]=(<span class="type">long</span> <span class="type">long</span>)(p-p/i)*(inv[p%i])%p;</span><br><span class="line">    <span class="comment">//注意longlong，否则有可能导致溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-线性求任意-n-个数的逆元"><a href="#5-线性求任意-n-个数的逆元" class="headerlink" title="5 线性求任意 n 个数的逆元"></a>5 线性求任意 n 个数的逆元</h2><p>上面的方法只能求 $1$ 到 $n$ 的逆元，如果需要求任意给定 $n$ 个数（$1 \le a_i &lt; p$）的逆元，就需要下面的方法：</p>
<p>首先计算 $n$ 个数的前缀积，记为 $s_i$，然后使用快速幂或扩展欧几里得法计算 $s_n$ 的逆元，记为 $sv_n$。</p>
<p>因为 $sv<em>n$ 是 $n$ 个数的积的逆元，所以当我们把它乘上 $a_n$ 时，就会和 $a_n$ 的逆元抵消，于是就得到了 $a_1$ 到 $a</em>{n-1}$ 的积逆元，记为 $sv_{n-1}$。</p>
<p>同理我们可以依次计算出所有的 $sv<em>i$，于是<br>$a_i^{-1}$ 就可以用 $s</em>{i-1} \times sv_i$ 求得。</p>
<p>所以我们就在 $O (n + \log p)$ 的时间内计算出了 $n$ 个数的逆元。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = s[i - <span class="number">1</span>] * a[i] % p;</span><br><span class="line">sv[n] = <span class="built_in">qpow</span>(s[n], p - <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sv[i - <span class="number">1</span>] = sv[i] * a[i] % p;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) inv[i] = sv[i] * s[i - <span class="number">1</span>] % p;</span><br></pre></td></tr></table></figure>
<h2 id="6-一些练习题"><a href="#6-一些练习题" class="headerlink" title="6 一些练习题"></a>6 一些练习题</h2><h3 id="6-1-乘法逆元-OI-Wiki-这里有几道题"><a href="#6-1-乘法逆元-OI-Wiki-这里有几道题" class="headerlink" title="6.1 乘法逆元 - OI Wiki 这里有几道题"></a>6.1 <a href="https://oi.wiki/math/number-theory/inverse/#%E9%80%86%E5%85%83%E7%BB%83%E4%B9%A0%E9%A2%98">乘法逆元 - OI Wiki</a> 这里有几道题</h3><h3 id="6-2-B3645-数列前缀和-2-洛谷"><a href="#6-2-B3645-数列前缀和-2-洛谷" class="headerlink" title="6.2 [[B3645 数列前缀和 2 - 洛谷]]"></a>6.2 [[B3645 数列前缀和 2 - 洛谷]]</h3><p><a href="https://www.luogu.com.cn/problem/B3645">链接</a></p>
<h3 id="6-3-B3646-数列前缀和-3-洛谷"><a href="#6-3-B3646-数列前缀和-3-洛谷" class="headerlink" title="6.3 B3646 数列前缀和 3 - 洛谷"></a>6.3 <a href="https://www.luogu.com.cn/problem/B3646">B3646 数列前缀和 3 - 洛谷</a></h3>]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>链式前向星存图</title>
    <url>/posts/5fafceb/</url>
    <content><![CDATA[<p>本质上是用链表实现的邻接表，核心代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//链式前向星存图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a[cnt] = &#123;v, w, head[u]&#125;;</span><br><span class="line">    <span class="comment">//a[cnt].w = w;//这三行与上面一行等价</span></span><br><span class="line">    <span class="comment">//a[cnt].v = v;</span></span><br><span class="line">    <span class="comment">//a[cnt].next = head[u];</span></span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = a[i].next)<span class="comment">//遍历</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><br>$\cup$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head[u] 和 cnt 的初始值都为 -1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  nxt[++cnt] = head[u];  <span class="comment">// 当前边的后继</span></span><br><span class="line">  head[u] = cnt;         <span class="comment">// 起点 u 的第一条边</span></span><br><span class="line">  to[cnt] = v;           <span class="comment">// 当前边的终点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 u 的出边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;  <span class="comment">// ~i 表示 i != -1</span></span><br><span class="line">  <span class="type">int</span> v = to[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>示例代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head, nxt, to;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  nxt.<span class="built_in">push_back</span>(head[u]);</span><br><span class="line">  head[u] = to.<span class="built_in">size</span>();</span><br><span class="line">  to.<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = nxt[i]) &#123;  <span class="comment">// ~i 表示 i != -1</span></span><br><span class="line">    <span class="keyword">if</span> (to[i] == v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; ~i; i = nxt[i]) <span class="built_in">dfs</span>(to[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  head.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="built_in">add</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul>
<li>查询是否存在 u 到 v 的边：$O (d^+(u))$。</li>
<li>遍历点 u 的所有出边：$O (d^+(u))$。</li>
<li>遍历整张图：$O (n+m)$。</li>
<li>空间复杂度：$O (m)$。<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序。</li>
</ul>
<p>优点是边是带编号的，有时会非常有用，而且如果 <code>cnt</code> 的初始值为奇数，存双向边时 <code>i ^ 1</code> 即是 <code>i</code> 的反边（常用于<a href="https://oi.wiki/graph/flow/">网络流</a>）。<br>各种图的存储：<br>![[../../../images/Z-attachment/Pasted image 20231221125830.png]]</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>图的存储</tag>
      </tags>
  </entry>
  <entry>
    <title>【C++】之 iota() 函数与 atoi() 函数详解</title>
    <url>/posts/6aea0693/</url>
    <content><![CDATA[<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/lixiaogang_theanswer/article/details/72588105">https://blog.csdn.net/lixiaogang_theanswer/article/details/72588105</a></li>
<li><a href="http://c.biancheng.net/view/681.html">http://c.biancheng.net/view/681.html</a></li>
</ol>
<h3 id="0-1-iota-函数"><a href="#0-1-iota-函数" class="headerlink" title="0.1 iota() 函数"></a>0.1 iota() 函数</h3><ul>
<li>C++ 中 iota() 是用来批量递增赋值 vector 的元素的。<br>示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>   	<span class="comment">//iota头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it++&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span>	<span class="number">7</span>	<span class="number">8</span>	<span class="number">9</span>	<span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>定义在 numeric 头文件中的 iota() 函数模板会用连续的 T 类型值填充序列</strong>。前两个参数是定义序列的正向迭代器，第三个参数是初始的 T 值。第三个指定的值会被保存到序列的第一个元素中。保存在第一个元素后的值是通过对前面的值运用<strong>自增运算</strong>符得到的。当然，这意味着 T 类型必须支持 operator++()。下面展示了如何生成一个有连续的浮点值元素的 vector 容器：<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">data</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> initial &#123;<span class="number">-4</span>&#125;;</span><br><span class="line">std::<span class="built_in">iota</span> (std::<span class="built_in">begin</span> (data) , std::<span class="built_in">end</span> (data) , initial);</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data),std::ostream_iterator&lt;<span class="type">double</span>&gt;&#123;std::cout&lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>), <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl;  </span><br><span class="line"><span class="comment">// -4.0 -3.0 -2.0 -1.0 0.0 1.0 2.0 3.0 4.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以 -4 为初始值调用 iota() 会将 data 中元素的值设为从 -4 到 +4 的连续值。</p>
<ul>
<li>当然，初始值并不需要一定是整数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">iota</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), <span class="number">-2.5</span>);</span><br><span class="line"><span class="comment">// Values are -2.5 -1.5 -0.5 0.5 1.5 2.5 3.5 4.5 5.5</span></span><br></pre></td></tr></table></figure>
<p>增量是 1，因此 data 中的值和注释显示的一样。</p>
<ul>
<li>可以将 iota() 算法应用到任意类型的序列上，只要它有自增运算符。下面是另一个示例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string text &#123;<span class="string">&quot;This is text&quot;</span>&#125;;</span><br><span class="line">std::<span class="built_in">iota</span>(std::<span class="built_in">begin</span>(text), std::<span class="built_in">end</span>(text), <span class="string">&#x27;K&#x27;</span>);</span><br><span class="line">std::cout &lt;&lt; text &lt;&lt; std::endl;   </span><br><span class="line"><span class="comment">// Outputs: KLMNOPQRSTUV</span></span><br></pre></td></tr></table></figure>
<p>很容易看到输出如注释所示，字符串中的字符被设为以 K 开头的字符序列。这个示例发生了什么并不是那么明显：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;string&gt; <span class="title">words</span> <span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">iota</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words), <span class="string">&quot;mysterious&quot;</span>);</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(words), std::<span class="built_in">end</span>(words),std::ostream_iterator&lt;string&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">std::cout &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// mysterious ysterious sterious terious erious rious ious ous</span></span><br></pre></td></tr></table></figure>
<p>输出如注释所示。这是该算法的一个有趣应用，但没有什么用处。这只适用于第三个参数是一个<strong>字符串常量</strong>的情形。如果参数是 string{“mysterious”}，将无法通过编译，因为没有为 string 类定义 operator++()。字符串常量对应的值是一个 const char* 类型的指针，可以将 ++ 运算符应用到它上面。因此对于 words 中第一个元素后的每个元素，指针的递增会导致字符串常量前面的字母被丢弃。将 ++ 应用到指针的结果是生成一个 string 对象，然后它会被保存到当前的元素序列中。</p>
<ul>
<li>只要 ++ 可以应用到序列中的元素类型上，就能将 iota() 算法应用到序列上。</li>
<li>注意：很有趣的是，iota() 算法来源于 IBM 的编程语言 APL 中的 iota 运算符 ι。在 APL 中，表达式 ι10 会生成从 1 到 10 的整数的 vector。APL 是肯 • 艾弗森在 20 世纪 60 年代发明的。它是一门相当筒洁的语言，能够隐式处理 vector 和数组。APL 的一个完整程序会从键盘读取任意个值，计算出它们的平均值，然后输出被表示为 10 个字符结果。</li>
</ul>
<h3 id="0-2-atoi-函数"><a href="#0-2-atoi-函数" class="headerlink" title="0.2 atoi() 函数"></a>0.2 atoi() 函数</h3><ul>
<li>atoi() 函数的功能是将字符串转换成整数 (int)。</li>
<li>这两个函数名字很相似，容易混淆，注意区分；一个在用在 c++ 的 STL 中，一个是用在 c 中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：atoi() 会扫描 str 字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符 (’\0’) 才结束转换，并将结果返回返回值。</li>
<li>参数：<br>str：待转换的字符串<br>【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0</li>
<li>示例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;-10&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num1 = atoi(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %d\n&quot;</span>, num1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果： </span></span><br><span class="line">num1 = <span class="number">-10</span></span><br><span class="line"></span><br><span class="line">而 <span class="type">char</span> str1[] = <span class="string">&quot;abc-1100def&quot;</span>;结果是： num1 = <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>三分法</title>
    <url>/posts/94ddbdbf/</url>
    <content><![CDATA[<p><strong>二分法</strong>相信大家都会，它最基本的应用是求一个<strong>单调函数</strong>的<strong>零点</strong>。</p>
<p><img data-src="../../../images/Z-attachment/Pasted%20image%2020231118200952.png" alt=""><br><strong>三分法</strong>是二分法的变种，他最基本的用途是求<strong>单峰函数</strong>的<strong>极值点</strong>。</p>
<p>![[../../../images/Z-attachment/Pasted image 20231118201007.png]]</p>
<p>从数学的角度来说，求极值点，先<strong>求导</strong>再<strong>二分</strong>不就好了吗？然而，实际中我们遇到的函数，求导可能很困难，所以会用上三分法。而三分法的原理非常简单，以求极大值为例，每次对一个区间<code>[l,r]</code>求三等分点<code>lsec</code>和<code>rsec</code>：</p>
<ul>
<li>如果<code>f(lsec) &lt; f(rsec)</code> ，说明极大值一定在<code>[lsec,r]</code>内取到，因为如果在<code>[0,lsec)</code>内，那<code>rsec</code>一定处于单调下降的区间内，它的函数值不可能大于<code>lsec</code>的函数值。 于是我们令<code>l=lsec</code>并继续。</li>
</ul>
<p>![[../../../images/Z-attachment/Pasted image 20231118201033.png]]</p>
<ul>
<li>如果<code>f(lsec) &gt; f(rsec)</code>，同理，极大值一定在<code>[l,rsec]</code>内取到，令<code>r=rsec</code>并继续。</li>
</ul>
<p>![[../../../images/Z-attachment/Pasted image 20231118201050.png]]</p>
<p>这样进行下去，直到<code>l</code>和<code>r</code>的差距小于设定的<code>eps</code>为止。如果求的是极小值而非极大值，只需把上面条件判断处的大于、小于互换。</p>
<p>按照上面的算法，我们每次减少三分之一的长度。但其实还可以优化，即每次在中点附近取点，那么每次可以减少约二分之一的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">&#123;</span><br><span class="line">    mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> fl = <span class="built_in">f</span>(mid - eps), fr = <span class="built_in">f</span>(mid + eps);</span><br><span class="line">    <span class="keyword">if</span> (fl &lt; fr)</span><br><span class="line">        l = mid; <span class="comment">// 这里不写成mid - eps，防止死循环；可能会错过极值，但在误差范围以内所以没关系</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法的三分，其实和普通的二分很像了。</p>
<h2 id="1-三分套三分"><a href="#1-三分套三分" class="headerlink" title="1 三分套三分"></a>1 三分套三分</h2><p>以上是求一元单峰函数的极值的方法，如果是二元函数呢？可以三分套三分。例如，求函数 $f(x,y)=(x-1)^2+(x+y)^2+\sin y$在 $-4\le x\le 4,-4\le y\le 4$ 时的极小值。</p>
<p>![[../../../images/Z-attachment/Pasted image 20231118201059.png]]</p>
<p>对于这个函数，无论固定 $x$ ，还是固定 $y$ ，都易证它是一个单峰函数。所以可以先三分一个变量，再固定这个变量，三分另一个变量，来求出最后的答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * (x - <span class="number">1</span>) + (x + y) * (x + y) + <span class="built_in">sin</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">run</span><span class="params">(<span class="type">double</span> x)</span> <span class="comment">// 固定x，三分y &#123;</span></span></span><br><span class="line"><span class="function">    <span class="type">double</span> l </span>= <span class="number">-4</span>, r = <span class="number">4</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(x, mid - eps) &gt; <span class="built_in">f</span>(x, mid + eps))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(x, mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-4</span>, r = <span class="number">4</span>, mid, ans;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>; <span class="comment">// 三分x</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">run</span>(mid - eps) &gt; <span class="built_in">run</span>(mid + eps))</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6f\n&quot;</span>, <span class="built_in">run</span>(mid)); <span class="comment">// -0.918827</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://link.zhihu.com/?target=https%3A//www.luogu.com.cn/problem/P2571">[SCOI2010] 传送带</a>这道题目就会用到三分套三分的方法，设 $E$ 是 $AB$ 上的点， $F$是 $CD$ 上的点，那么最优路径应当是 $A\rightarrow E\rightarrow F\rightarrow D$，那么我们分别设出 $AE$ 占 $AB$ 的比例 $x$ 和 $DF$ 占 $CD$ 的比例 $y$ ，得到函数：</p>
<p>$f(x,y)=\frac{x\cdot len(AB)}{P}+\frac{y\cdot len(CD)}{R}+\frac{len(EF)}{Q}$</p>
<p>其中 $len(E,F)$ 是一个关于 $x,y$ 的函数，它显然对 $x$ 和 $y$ 而言都是单峰的（垂直时最小），再加上前面的单调函数，总体仍是单峰的，那么用三分套三分求解即可。</p>
<p>如果不会证明单峰性，其实可以写个程序打个表，目测一下正确性。</p>
<h2 id="2-三分答案"><a href="#2-三分答案" class="headerlink" title="2 三分答案"></a>2 三分答案</h2><p>和二分答案类似，也可以三分答案。例如：</p>
<blockquote>
<p>You have to restore the wall. The wall consists of $N$  pillars of bricks, the height of the $i$  -th pillar is initially equal to $h_i$, the height is measured in number of bricks. After the restoration all the $N$  pillars should have equal heights.<br>You are allowed the following operations:<br>您可以进行以下操作：<br>● put a brick on top of one pillar, the cost of this operation is $A$ ;<br>●在一根柱子上放一块砖，此操作的成本为  $A$;<br>    ● remove a brick from the top of one non-empty pillar, the cost of this operation is $R$ ;<br>●从一个非空支柱的顶部拆除一块砖，此操作的成本为  $R$;<br>● move a brick from the top of one non-empty pillar to the top of another pillar, the cost of this operation is $M$ .<br>●将一块砖从一个非空柱子的顶部移动到另一个柱子的顶部，此操作的成本为 $M$  。<br>You cannot create additional pillars or ignore some of pre-existing pillars even if their height becomes $0$ .<br>您不能创建额外的支柱或忽略一些预先存在的支柱，即使它们的高度变为  。<br>What is the minimal total cost of restoration, in other words, what is the minimal total cost to make all the pillars of equal height?<br>修复的最小总成本是多少，换句话说，使所有柱子高度相等的最小总成本是多少？<br><strong>Input</strong><br>The first line of input contains four integers $N,A,R,M$ $(1≤N≤10^5,0≤A,R,M≤10^4)$ — the number of pillars and the costs of operations.<br>输入的第一行包含四个整数 $N,A,R,M$  - 支柱的数量和运营成本。<br>The second line contains $N$ integers $h_i$ $(0≤h_i≤10^9)$— initial heights of pillars.<br>第二行包含整数 $N$   - 柱子的初始高度。<br><strong>Output</strong><br>Print one integer — the minimal cost of restoration.<br>打印一个整数 - 恢复的最小成本。</p>
</blockquote>
<p>感性理解，设最后每列的砖块数为 $x$ ，当 $x$ 很小或很大时，显然代价都比较大；当 $x$ 处于最优解时，无论减少还是增多都会增大代价。所以合理猜测这是单峰函数。<em>（至于严谨证明，我也不会；如果不信服这个感性理解，还是可以打个表出来看看）</em></p>
<p>于是我们三分 $x$ 然后贪心即可。贪心的思路比较显然，具体看代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll A[MAXN];</span><br><span class="line">ll n, a, r, m;</span><br><span class="line"><span class="function">ll <span class="title">run</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    ll low = <span class="number">0</span>, high = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; x)</span><br><span class="line">            low += x - A[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high += A[i] - x;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; a + r)</span><br><span class="line">        <span class="keyword">return</span> low * a + high * r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (high &gt; low)</span><br><span class="line">        <span class="keyword">return</span> m * low + (high - low) * r;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> m * high + (low - high) * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; r &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid;</span><br><span class="line">    ll ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) <span class="comment">// 直到只剩不到三个数为止</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        ll a1 = <span class="built_in">run</span>(mid - <span class="number">1</span>), a2 = <span class="built_in">run</span>(mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a1 &gt; a2)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, a1), l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, a2), r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">run</span>(l));</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, <span class="built_in">run</span>(r));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为是对整数进行操作，所以要更加注意边界问题。</p>
<p><a href="https://zhuanlan.zhihu.com/p/105467597">算法笔记（目录）</a></p>
]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>二分</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ array 使用方法详细介绍_array__-CSDN 博客</title>
    <url>/posts/b85f05b1/</url>
    <content><![CDATA[<p>更多关于 STL 的文章：<a href="https://blog.csdn.net/weixin_45826022/article/category/9483074">STL 专栏</a>  </p>
<h4 id="0-1-1-文章目录"><a href="#0-1-1-文章目录" class="headerlink" title="0.1.1 文章目录"></a>0.1.1 文章目录</h4><ul>
<li><ul>
<li><a href="#_3">介绍</a></li>
<li><a href="#array_20">array 成员函数</a></li>
<li><a href="#_37">成员函数用法示例</a></li>
<li><ul>
<li><ul>
<li><a href="#array_38">array 用法及初始化</a></li>
<li><a href="#array_95">array 元素的获取</a></li>
<li><a href="#Tuple_207">Tuple 接口</a></li>
<li><a href="#array_283">array 元素的修改</a></li>
<li><a href="#array_355">array 迭代器</a></li>
<li><a href="#array_398">array 元素的比较</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为了防止学习的过程中出现学后忘的情况，我将接触到的知识进行整理，作该笔记，由于本人水平有限，如果出现错误，还望赐正。</p>
<h3 id="0-2-介绍"><a href="#0-2-介绍" class="headerlink" title="0.2 介绍"></a>0.2 介绍</h3><p>数组是固定大小的序列容器: 它们包含按严格的线性顺序排列的特定数量的元素。一个 array——也就是容器类 array&lt;&gt; 的一份实体——模塑出一个 static array。它包覆一个寻常的 static C-style array 并提供一个 STL 容器接口。</p>
<p>通用格式：array &lt;类型名, 元素个数&gt; 数组名;</p>
<p>注意，因为长度固定，这里的元素个数不能是变量。</p>
<p>在内部，数组除了它所包含的元素之外不保留任何数据 (甚至不保留它的大小，这是一个模板参数，在编译时固定)。就存储大小而言，它与使用该语言的括号语法([]) 声明的普通数组一样有效。这个类只是向它添加了一层成员和全局函数，它比寻常的数组安全，而且效率并没有因此变差，因此数组可以用作标准容器。</p>
<p>与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配: 它们是封装固定大小的元素数组的聚合类型。因此，它们不能动态地展开或收缩。</p>
<p>大小为零的数组是有效的，但是不应该取消对它们的引用 (成员 front, back, 和 data)。</p>
<p>数组容器的另一个独特的特性是它们可以被视为元组对象: array 头文件重载 get 函数来访问数组的元素，就好像它是一个元组一样，还有专门的 tuple_size 和 tuple_element 类型。</p>
<p>array 并不支持（也就是不允许你指定）分配器（allocator）</p>
<h3 id="0-3-array-成员函数"><a href="#0-3-array-成员函数" class="headerlink" title="0.3 array 成员函数"></a>0.3 array 成员函数</h3><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()，end() ,cbegin()，cend()</td><td>提供正向迭代器支持</td></tr><tr><td>rbegin()，rend()，crbegin()，crend()</td><td>提供反向迭代器支持</td></tr><tr><td>size()</td><td>返回数组大小</td></tr><tr><td>max_size()</td><td>返回数组最大大小（由于 array 为固定序列，该函数返回值与 size() 相同）</td></tr><tr><td>empty()</td><td>判断数组是否为空 (几乎没用)</td></tr><tr><td>at()，operator[]</td><td>获取数组元素</td></tr><tr><td>front()</td><td>返回数组第一个元素的引用</td></tr><tr><td>back()</td><td>返回数组最后一个元素的引用</td></tr><tr><td>data()</td><td>返回指向数组对象包含的数据的指针</td></tr><tr><td>fill()</td><td>用值填充数组</td></tr><tr><td>swap()</td><td>交换两个数组元素</td></tr><tr><td>get(array)</td><td>返回某一个数组元素的引用</td></tr></tbody></table>

<p>array 会把元素复制到其内部的 static C-style array 中。这些元素总是拥有一个明确次序。因此 array 是一种有序集合。array 允许随机访问，也就是你可以在常量时间内直接访问任何元素， 前提是你得知道元素位置。 array 的迭代器属于随机访问迭代器，所以你可以对它运用任何 STL 算法。</p>
<h3 id="0-4-成员函数用法示例"><a href="#0-4-成员函数用法示例" class="headerlink" title="0.4 成员函数用法示例"></a>0.4 成员函数用法示例</h3><h5 id="0-4-1-1-array-用法及初始化"><a href="#0-4-1-1-array-用法及初始化" class="headerlink" title="0.4.1.1 array 用法及初始化"></a>0.4.1.1 array 用法及初始化</h5><p>template <class T, size_t N> class array;<br>//T 为所包含元素的类型，别名为成员类型 value_type 。N 为数组的大小，以元素数表示。</p>
<p>在使用 array 前，首先要添加 array 这个头文件，即<code>#include &lt;array&gt;</code>。</p>
<p>注意：array&lt;&gt; 是唯一一个无任何东西被指定为初值时，会被预初始化的容器。这意味着对于基础类型，初值可能不明确，而不是 0，例如：下面定义一个有妖妖灵个 int 元素的数组 arr：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>,110&gt; arr;</span><br></pre></td></tr></table></figure>
<p>上面定义的 arr 并未进行初始化。未初始化将会分配随机值，如图：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20191104224520637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgyNjAyMg==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>所以尽量不要定义未初始化的数组，否则访问数组元素，而该元素恰好未初始化时，可能出现意想不到的错误。</p>
<p>array 数组对象初始化与标准数组初始化一模一样，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>,110&gt; arr  &#123; &#125;;<span class="comment">//将数组所有元素初始化为0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>,110&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//将数组前4个元素分别初始化为1，2，3，4，其余全部为0</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/20191104230148404.png" alt=""></p>
<p>另外由于没有提供针对初值而写的构造函数或 assignment 操作符，因此 “在 array 声明期间完成初始化” 是使用初值列的唯一途径。基于这个原因，你无法使用小括号指明初值（此不同于其他容器类型）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,5&gt; <span class="title function_">a</span><span class="params">(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;)</span>  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>fill()</strong><br>fiil() 函数可以用指定值给数组中所有元素赋值。</li>
</ul>
<p>fill() 函数原型如下：</p>
<p>void fill(const value_type &amp; u); //value_type 为数组元素类型；</p>
<p>【例】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">110</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    arr.fill(<span class="number">3</span>); <span class="comment">//用3对数组所有元素赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h5 id="0-4-1-2-array-元素的获取"><a href="#0-4-1-2-array-元素的获取" class="headerlink" title="0.4.1.2 array 元素的获取"></a>0.4.1.2 array 元素的获取</h5><p><strong>特别注意！array，string，vector 等容器的第一个元素下标为 0！！！</strong></p>
<ul>
<li>array 元素的获取可以使用下标 []（与标准数组用法相同），以及 STL 容器特有的 at()。<br>[] 与 at() 的区别在于，[] 不会进行检查数字是否越界，而 at() 会进行检查（时间开销很少），如果越界则抛出 std::out_of_rang 异常。<br>因此，除非确定访问没有越界，否则应该尽量使用更安全的 at() 。</li>
</ul>
<p>reference at(size_type n);<br>const_reference at(size_type __n) const;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">11</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    arr.at(<span class="number">9</span>) = arr.at(<span class="number">3</span>) + arr.at(<span class="number">5</span>);</span><br><span class="line">    arr[<span class="number">10</span>] = arr[<span class="number">1</span>] + arr[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arr.at(<span class="number">9</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arr[<span class="number">10</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arr[11] = 6;越界访问，程序异常，但Qt Creator并未报错</span></span><br><span class="line">    arr.at(<span class="number">11</span>) = <span class="number">6</span>; <span class="comment">//异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>  </span><br><span class="line"><span class="number">11</span>  </span><br></pre></td></tr></table></figure>
<p>terminate called after throwing an instance of ‘std::out_of_range’<br>what(): array::at: __n (which is 11) &gt;= _Nm (which is 11)</p>
<ul>
<li><strong>front() 和 back()</strong><br>front() 返回数组第一个元素的引用。<br>back() 返回数组最后一个元素的引用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">11</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    arr.front() = <span class="number">666</span>;</span><br><span class="line">    arr.back() = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">666</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">666</span></span><br></pre></td></tr></table></figure>
<p>（注：这两个函数极少使用）</p>
<ul>
<li><strong>data()</strong><br>返回指向数组对象中第一个元素的指针。<br>该函数无参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *arr.data()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; *(arr.data()+<span class="number">6</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//获取元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cstr = <span class="string">&quot;Test string&quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">char</span>,<span class="number">12</span>&gt; charray;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span> (charray.data(),cstr,charray.size());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; charray.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">7</span>  </span><br><span class="line">Test <span class="built_in">string</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>size() 和 max_size()</strong><br>由于 array 在创建的时候必须明确指定大小，而且 array 为固定容器，因此 max_size() 与 size() 的返回值相同。<br>通常使用 size() 函数。<br>返回值类型为 size_t 即无符号整数</li>
</ul>
<p>使用 size() 可以有效避免使用 for 遍历数组时，发生越界的情况。同时它也使得你在写程序的时候，不必去花心思记忆数组的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i(<span class="number">0</span>);i&lt; arr.size();++i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; arr[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//程序运行结果为1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>empty()</strong><br>该函数在 array 中为鸡肋函数。这是因为 array 在定义的时候已经指明了大小，不可能为空。除非你写出如此代码<code>std::array&lt;int,0&gt; var;</code>但这毫无意义。<br>然而，对于其他元素可变或者元素可删除的容器来说，它们使用 empty() 时的机制是一样的，因此为它们提供了一个一致性的操作。</li>
</ul>
<h5 id="0-4-1-3-Tuple-接口"><a href="#0-4-1-3-Tuple-接口" class="headerlink" title="0.4.1.3 Tuple 接口"></a>0.4.1.3 Tuple 接口</h5><p>array 提供 tuple 接口。因此可以使用表达式 <strong>tuple_size&lt;&gt;::value</strong> 取得元素个数，用 <strong>tuple_element&lt;&gt;::type</strong> 取得某特定元素的类型，用 <strong>get&lt;&gt;()</strong> 取得某特定元素。</p>
<ul>
<li><strong>get()</strong><br>get() 函数为非成员函数重载 。<br>该函数返回 array 中指定元素的引用</li>
</ul>
<p>函数原型如下：</p>
<p>template <size_t I, class T, size_t N> T&amp; get (array<T,N>&amp; arr) noexcept;<br>template <size_t I, class T, size_t N> T&amp;&amp; get (array<T,N>&amp;&amp; arr) noexcept;<br>template <size_t I, class T, size_t N> const T&amp; get (const array<T,N>&amp; arr) noexcept;<br>// 参数 l 为：元素在数组中的位置，第一个元素的位置为 0 。<br>// 参数 T 为：数组中包含的元素类型（通常从 arr 隐式获得）。<br>// 参数 N 为：数组的大小，以元素数为单位（通常从 arr 隐式获得）。</p>
<p>由于参数 T，N 可以从 arr 中隐式获得。因此在使用时一般不显式指定二者。<br>【例】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int a = std::get&lt;6,int,10&gt;(arr); 一般不这么写</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">std</span>::get&lt;<span class="number">6</span>&gt;(arr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::get&lt;<span class="number">5</span>&gt;(arr) = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>  </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">666</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>另外参数 l 必须是明确的数字，不能使用变量。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::get&lt;n&gt;(arr);<span class="comment">//错误写法</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>tuple_size&lt;&gt;::value 和 tuple_element&lt;&gt;::type</strong><br>在 array 中用途不大，示例如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">string</span>,<span class="number">5</span>&gt; arr = &#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>&#125;;;</span><br><span class="line">    <span class="comment">//返回元素个数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">std</span>::tuple_size&lt;decltype(arr)&gt;::value &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取第3个元素类型</span></span><br><span class="line">    <span class="built_in">std</span>::tuple_element&lt;<span class="number">1</span>,decltype(arr)&gt;::type type = get&lt;<span class="number">3</span>&gt;(arr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; type &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>  </span><br><span class="line">four</span><br></pre></td></tr></table></figure>
<h5 id="0-4-1-4-array-元素的修改"><a href="#0-4-1-4-array-元素的修改" class="headerlink" title="0.4.1.4 array 元素的修改"></a>0.4.1.4 array 元素的修改</h5><p>array 元素的修改与标准数组用法几乎相同。<br>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = arr[<span class="number">0</span>] + arr[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>同样也可以使用指针、引用对其进行修改。</p>
<p>不同与标准数组的是：只要两个 array 类型的数组的数据类型和大小相同，就可以用 = 赋值。<br>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">3</span>&gt; arr_1 &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">3</span>&gt; arr_2 &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    arr_1 = arr_2; <span class="comment">//用arr_2的元素覆盖arr_1的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr_1)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr_2)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span>  </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>swap()</strong><br>交换两个 array 的值。注：这两个数组的大小，数据类型必须相同！<br>无返回值，无参数。</li>
</ul>
<p>与标准库中的其他容器不同，交换两个数组容器是一种线性操作，涉及单独交换范围内的所有元素，这通常效率较低</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt; var&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    arr.swap(var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:arr)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:var)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h5 id="0-4-1-5-array-迭代器"><a href="#0-4-1-5-array-迭代器" class="headerlink" title="0.4.1.5 array 迭代器"></a>0.4.1.5 array 迭代器</h5><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>begin( )</td><td>返回指向数组第一个元素的迭代器。</td></tr><tr><td>end()</td><td>返回指向数组最后一个元素后紧跟的的理论元素的迭代器。</td></tr><tr><td>cbegin()</td><td>返回指向数组第一个元素的 const 类型迭代器。</td></tr><tr><td>cend()</td><td>返回指向数组最后一个元素后紧跟的的理论元素的 const 类型迭代器。</td></tr><tr><td>rbegin()</td><td>返回一个反向迭代器，该迭代器指向数组的最后一个元素（即它的反向开始）。</td></tr><tr><td>rend()</td><td>返回一个反向迭代器，该迭代器指向数组第一个元素之前的理论元素（该元素被视为反向元素）。</td></tr><tr><td>crbegin()</td><td>返回一个 const 类型反向迭代器，该迭代器指向数组的最后一个元素（即它的反向开始）。</td></tr><tr><td>crend()</td><td>返回一个 const 类型反向迭代器，该迭代器指向数组第一个元素之前的理论元素（该元素被视为反向元素）。</td></tr></tbody></table>

<p>下面为数组迭代器的简单用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt; arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt;::iterator it_beg = arr.begin();  <span class="comment">//或者 auto it_beg = arr.begin();</span></span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">10</span>&gt;::reverse_iterator rit_beg = arr.rbegin(); <span class="comment">//或者 auto rit_brg = arr.rbegin();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;it_beg!=arr.end();it_beg++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; *it_beg * <span class="number">2</span>&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//二倍输出数组所有元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;rit_beg != arr.rend();rit_beg++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; *rit_beg &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//倒序输出数组元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span> <span class="number">20</span>  </span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在使用时最好用全局的 begin() 和 end() 函数从容器中获取迭代器，因为它们是通用的。<br>如上述<code>array&lt;int,10&gt;::iterator it_beg = arr.begin();</code> 可以写为<code>array&lt;int,10&gt;::iterator it_beg = std::begin(arr);</code></p>
<h5 id="0-4-1-6-array-元素的比较"><a href="#0-4-1-6-array-元素的比较" class="headerlink" title="0.4.1.6 array 元素的比较"></a>0.4.1.6 array 元素的比较</h5><p>可以用任何比较运算符比较两个数组容器，只要它们有相同的大小，保存的是相同类型的元素，而且这种类型的元素还要支持比较运算符。示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">3</span>&gt; arr_1 &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">3</span>&gt; arr_2 &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="type">int</span>,<span class="number">3</span>&gt; arr_3 &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr_1 == arr_2)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_1 = arr_2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr_1 != arr_3)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_1 != arr_3&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr_1 &lt; arr_3)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;arr_1 &lt; arr_3&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arr_1 = arr_2  </span><br><span class="line">arr_1 != arr_3  </span><br><span class="line">arr_1 &lt; arr_3</span><br></pre></td></tr></table></figure>
<p>容器被逐元素地比较。对 == ,如果两个数组对应的元素都相等，会返回 true。对于 !=，两个数组中只要有一个元素不相等，就会返回 true。这也是字典中单词排序的根本方式，两个单词中相关联字母的不同决定了单词的顺序。</p>
]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - SWPUACM Wiki</title>
    <url>/posts/7a219ca8/</url>
    <content><![CDATA[<h1 id="算法竞赛中的-C-语法操作"><a href="#算法竞赛中的-C-语法操作" class="headerlink" title="算法竞赛中的 C++ 语法操作"></a><a href="#算法竞赛中的-c-语法操作">算法竞赛中的 C++ 语法操作</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="#前言">前言</a></h2><p>昨天在某群里看到有人问 「有没有那种总结好的语法技巧啊」。突然想到自己也没有做过类似的总结，于是就有了这篇文章。需要注意的是，本文仅列出了一些常见技巧，<em>欢迎指正以及补充</em>！</p>
<p><em>本文的写作顺序</em>并不总<em>符合认知的先后，如果有任何疑问，请善用搜索引擎或 Ctrl-F 查找该内容。</em></p>
<p><strong>算法竞赛代码与工程代码目的与标准并不完全相同，请勿以工程角度看待此文章中的若干「技巧」。同时笔者也需要指出，许多算法竞赛的习惯并不适用于工程。</strong></p>
<ul>
<li>用 <code>!</code> 标记了最近新增的条目。</li>
<li>用 <code>*</code> 标记了最近修改的条目。</li>
<li>用 <code>~</code> 标记了「这其实是一个<em>坏</em>习惯，但算法竞赛就这样用吧」。</li>
<li>用 <code>^</code> 标记了准备删除的条目，笔者<strong>将在下次更新中移除</strong>这些条目。</li>
</ul>
<p>作者是个老鸽子，乐观情况下<em>平均</em>一个月维护一次。另，本文有搬迁至 github 的想法，届时文章将会更加精美全面，敬请期待。</p>
<p>（2023-04-10）假的，可能等不到了，现附上 Markdown，读者可随意使用，欢迎接力。</p>
<h2 id="预处理-1"><a href="#预处理-1" class="headerlink" title="预处理 1"></a><a href="#预处理1">预处理</a> <a href="#1">1</a></h2><p>1</p>
<p>cppreference 预处理器 <a href="https://en.cppreference.com/w/cpp/preprocessor">https://en.cppreference.com/w/cpp/preprocessor</a></p>
<h3 id="万能头-2-及其预编译-——-include"><a href="#万能头-2-及其预编译-——-include" class="headerlink" title="~ 万能头 2 及其预编译 —— #include"></a><a href="#-万能头2及其预编译--include">~ 万能头</a> <a href="#2">2</a> 及其预编译 —— #include</h3><p>2</p>
<p>为什么你不应该使用万能头 <a href="https://stackoverflow.com/questions/31816095/why-should-i-not-include-bits-stdc-h">https://stackoverflow.com/questions/31816095/why-should-i-not-include-bits-stdc-h</a></p>
<p><strong>要使用万能头，请使用 g++ 作为编译器。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br></pre></td></tr></table></figure>
<p>另，万能头本身十分庞大，预编译是节省编译时间的重要手段，具体方法如下：</p>
<ol>
<li>找到本机 <code>bits/stdc++.h</code> ，笔者该文件位置在 <code>/usr/include/c++/12.1.1/x86_64-pc-linux-gnu/bits/stdc++.h</code></li>
<li>运行 <code>g++ --yourflags bits/stdc++.h</code> ，其中 <code>--yourflags</code> 代表你喜好的参数</li>
<li>下次编译也使用第 2 步提到的指令编译。为节省生命，建议写入 <code>CMakeLists.txt</code></li>
</ol>
<h3 id="文本替换宏-3-——-define-undef-预定义替换宏"><a href="#文本替换宏-3-——-define-undef-预定义替换宏" class="headerlink" title="文本替换宏 3 —— #define / #undef / 预定义替换宏"></a><a href="#文本替换宏3----define--undef--预定义替换宏">文本替换宏</a> <a href="#3">3</a> —— #define / #undef / 预定义替换宏</h3><p>3</p>
<p><a href="https://en.cppreference.com/w/cpp/preprocessor/replace">https://en.cppreference.com/w/cpp/preprocessor/replace</a></p>
<p>许多选手喜欢定义若干宏，读者要决定是否喜欢这些大可自行尝试。在此笔者列出一些较为常见的文本替换宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define int long long   // 可能报告为错误（事实上确实不应这样做)</span><br><span class="line">                        // 下文或 #undef int 之后 int main() &#123; &#125;</span><br><span class="line">                        //    或 signed / int32_t main() &#123; &#125; </span><br><span class="line"></span><br><span class="line">// ##x 将连接 x，如 i##i 传入 x2 最终会变为 x2x2</span><br><span class="line">#define rep(i, s, e) for (auto i = s, i##i = e; i &lt;= i##i; i ++)</span><br><span class="line">#define per(i, s, e) for (auto i = s, i##i = e; i &gt;= i##i; i --)</span><br><span class="line"></span><br><span class="line">#define ls i &lt;&lt; 1       // 二叉树的数组实现，ls 表示左儿子 2i</span><br><span class="line">#define rs ls | 1       // 同上，rs 表示右儿子 2i + 1</span><br><span class="line"></span><br><span class="line">// 小技巧：想选中一段区间可使用 sort(3 + all(x) - 4)</span><br><span class="line">#define all(x)  (x).begin(),  (x).end() </span><br><span class="line">// 笔者更推荐 begin(x), end(x)</span><br><span class="line">#define rall(x) (x).rbegin(), (x).rend()</span><br><span class="line"></span><br><span class="line">// #x 将使用双引号包裹参数 x （MSVC 还有单引号的 #@）</span><br><span class="line">#define reopen(x) &#123; freopen(#x&quot;.in&quot;, &quot;r&quot;, stdin); freopen(#x&quot;.out&quot;, &quot;w&quot;, stdout); &#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>#undef</code> 取消文本替换宏，意义为「仅在包裹的代码段落中执行替换」 。</p>
<p>C++ 预定义了一些宏，它们会随着「情况」的不同发生改变。如 <code>__cplusplus</code> 指代当前语言标准， <code>__LINE__</code> 将指代当前行，<code>__FUNC__</code> 将指代当前所在的函数。此处不作展开，详情请参见 <a href="https://en.cppreference.com/w/cpp/preprocessor/replace#Predefined_macros">cppreference 预定义宏</a>。配合这一点，可以写出一个简单的调试文本替换宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define here log(&quot;Passing [%s] in LINE %d\n&quot;, __FUNCTION__, __LINE__)</span><br><span class="line">// log 见下文输出调试信息处</span><br></pre></td></tr></table></figure>
<h3 id="条件宏-4"><a href="#条件宏-4" class="headerlink" title="条件宏 4"></a><a href="#条件宏4">条件宏</a> <a href="#4">4</a></h3><p>4</p>
<p><a href="https://en.cppreference.com/w/cpp/preprocessor/conditional">https://en.cppreference.com/w/cpp/preprocessor/conditional</a></p>
<p><code>#ifdef</code>, <code>#else</code>, <code>#endif</code> 之类的宏操作会<strong>在编译过程中</strong>选择某些部分编译与否等等。</p>
<p>在竞赛中最经典的使用是配合文件流重定向，在本机使用文件输入，而在 OJ 上使用标准读入。<strong>大部分</strong> OJ 都定义了 <code>ONLINE_JUDGE</code> 的宏，因此可以借此作为开关。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef ONLINE_JUDGE</span><br><span class="line">  reopen(1); // 在上面已定义此宏。</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>编译时附加 <code>-DLOCAL</code> 来定义一个名为 <code>LOCAL</code> 的宏。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a><a href="#断言">断言</a></h3><p>这并非一个函数，而是一个宏。接受一个表达式，若为假程序将直接退出，<em>十分</em>便于调试。</p>
<p>例如，某区域是你永不希望到达的，你可以在此区域附加 <code>assert(false)</code>。也可使用 <code>__builtin_unreachable()</code> / <code>std::unreachable()</code><a href="#5">5</a> 来标记不可达的区域。</p>
<p>5</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/unreachable">https://en.cppreference.com/w/cpp/utility/unreachable</a></p>
<p>有的 OJ 会屏蔽 <code>assert</code> (事实上宏 <code>NDEBUG</code> 决定之)，不过实现一个 <a href="#6">6</a> 也很容易：</p>
<p>6</p>
<p>这个宏参考了 f0re1gners 的模板库 <a href="https://f0re1gners.github.io/template/template.pdf">https://f0re1gners.github.io/template/template.pdf</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef ONLINE_JUDGE</span><br><span class="line">#  define assert(condition) do if (!(condition)) exit(*(int*)0); while (0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h2 id="命名空间-7"><a href="#命名空间-7" class="headerlink" title="!~ 命名空间 7"></a><a href="#-命名空间-7">!~ 命名空间</a> <a href="#7">7</a></h2><p>7</p>
<p><a href="https://en.cppreference.com/w/cpp/language/namespace">https://en.cppreference.com/w/cpp/language/namespace</a></p>
<p><code>namespace</code> 是 C++ 中十分有效的解决命名冲突的手段。 假设现在要处理两段命名冲突的数据，将其命名为类似的名称似乎并没有想象中的美观。这种情况下，可以借助 <code>namespace</code> 将其包裹住。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int _hash[maxn], _hash_2[maxn];</span><br><span class="line"></span><br><span class="line">namespace L &#123; int _hash[maxn]; &#125;</span><br><span class="line">namespace R &#123; int _hash[maxn]; &#125;</span><br></pre></td></tr></table></figure>
<p>使用时：<code>L::_hash[i]</code>, <code>R::_hash[i]</code> 。</p>
<p>欲指代全局的命名空间（如 C 库函数），可直接使用 :: 打头，如 ::abs(a)。</p>
<p>匿名的空间也是可行的，对于 namespace {int xxx;} 的访问可直接 ::xxx。</p>
<p>C++ 标准库函数都位于 <code>std</code> 中，这意味着若要使用他们，则需 <code>std::xxx</code> 指代它们。不少竞赛选手常常喜欢使用一句多为人诟病<a href="#8">8</a> 的 <code>using namespace std</code>，这句话将在全局引用 <code>std</code> 命名空间。</p>
<p>8</p>
<p><a href="https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice">https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice</a></p>
<p>如果把 <code>ranges::views::iota_view</code> 比如文件路径 <code>/home/patricky/Downloads/files</code>，那么 <code>using namespace</code> 的意义就如同将其置于环境变量中，意味着你可随时随地使用其下的文件。<strong>使用此方法之后，你应当更小心地使用变量名。</strong></p>
<p>另外一种不错的手段是，使用时再 <code>using</code>。如 <code>using std::cout</code> 之后即可 <code>cout &lt;&lt; &quot;Anything you want.&quot;</code> 了。</p>
<p>说起来，如此长的命名空间 <code>std::ranges:views</code><em>(尽管它已被别名为 <code>std::views</code>)</em> 实在太不方便了，用下面的语法来给它起个别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace NV = std::ranges::views;</span><br></pre></td></tr></table></figure>
<h3 id="作用域-—-另一个解决命名冲突的方法"><a href="#作用域-—-另一个解决命名冲突的方法" class="headerlink" title="作用域 — 另一个解决命名冲突的方法"></a><a href="#作用域----另一个解决命名冲突的方法">作用域 — 另一个解决命名冲突的方法</a></h3><p>一个花括号围住的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n = 1;</span><br><span class="line">&#123; </span><br><span class="line">    using std::cout, std::cin; </span><br><span class="line">    // C++17 开始可以一句话 using 多个目标</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; &quot;\n&quot;; // 1</span><br><span class="line">    int n = 2;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; &quot;\n&quot;; // 2</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符的重载-9"><a href="#运算符的重载-9" class="headerlink" title="运算符的重载 9"></a><a href="#运算符的重载-9">运算符的重载</a> <a href="#9">9</a></h2><p>9</p>
<p><a href="https://en.cppreference.com/w/cpp/language/operators">https://en.cppreference.com/w/cpp/language/operators</a></p>
<p>简单说来就是将某函数绑定到某运算符上（优先级与之前一致），常见的如定义一个<em>不小 <a href="#10">10</a></em> 的矩阵：</p>
<p>10</p>
<p>小矩阵请直接使用 <code>array&lt;array&lt;int, N&gt;, N&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class T = int&gt;</span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    Matrix(int _r = &#123;&#125;, int _c = &#123;&#125;) : r&#123;_r&#125;, c&#123;_c&#125;, data(r * c) &#123; &#125;</span><br><span class="line">    T* operator[](int i) &#123; return &amp; data[i * c]; &#125;</span><br><span class="line">private:</span><br><span class="line">    int r, c;</span><br><span class="line">    vector&lt;T&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样之后就可以对 <code>Matrix m(2, 2)</code> 使用 <code>m[1][0]</code> 了。</p>
<p>写一个比较器（通常是重载小于号）再传入 STL 容器中，这种时候，函数的头就十分重要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int _val;</span><br><span class="line">    // 不一定需要有「小于」的意义。</span><br><span class="line">    bool operator&lt;(const node &amp;_) const &#123; return _val &gt; _.val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="仿函数-函子"><a href="#仿函数-函子" class="headerlink" title="仿函数 / 函子"></a><a href="#仿函数--函子">仿函数 / 函子</a></h3><p>重载括号之后，使用括号运算符的感觉就像是函数一样。</p>
<p>如果想用 <code>unordered_&#123;, multi&#125;&#123;map, set&#125;&lt;pair&lt;T1, T2&gt;, T3&gt;</code>，可以传一个仿函数进去，如 <code>unordered_map&lt;pair&lt;int,int&gt;,int, your_hash&gt;</code></p>
<p>或直接特化 <code>hash</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class T1, class T2&gt; </span><br><span class="line">struct hash&lt;pair&lt;T1, T2&gt;&gt; &#123;</span><br><span class="line">    size_t operator()(const pair&lt;T1, T2&gt; &amp;t) const &#123;</span><br><span class="line">        return t.first ^ (t.second &lt;&lt; 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;pair&lt;int, int&gt;, int&gt; ump;</span><br></pre></td></tr></table></figure>
<p>不过其实不如写一个函数将 <code>pair&lt;int, int&gt;</code> 先哈希一次，再用这个数字来哈希，详情请见：</p>
<p><a href="https://codeforces.com/blog/entry/62393?#comment-464775">Blowing up unordered_map, and how to stop getting hacked on it - Codeforces</a></p>
<h2 id="Lambda-表达式-匿名函数-闭包-11"><a href="#Lambda-表达式-匿名函数-闭包-11" class="headerlink" title="* Lambda 表达式 / 匿名函数 / 闭包 11"></a><a href="#-lambda-表达式--匿名函数--闭包-11">* Lambda 表达式 / 匿名函数 / 闭包</a> <a href="#11">11</a></h2><p>11</p>
<p><a href="https://en.cppreference.com/w/cpp/language/lambda">https://en.cppreference.com/w/cpp/language/lambda</a></p>
<p>简单来说即「函数中的函数」，然而其类型<strong>两两不同</strong>（哪怕写的一模一样）。一个 <code>lambda</code> 表达式包含如下几个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[] // 捕获列表，包含两种捕获方式：按值（const）/引用。将会拷贝一份至 lambda 对应的类中。</span><br><span class="line">   // 如 [a] 表示按值捕获，[=] 表示「全部」按值捕获</span><br><span class="line">   // 而 [&amp;a] 则为按引用，[&amp;] 是其全称形式</span><br><span class="line">() // 参数列表，如果为空可以省略。</span><br><span class="line">各种说明符 // （可选）试图修改按值捕获的变量时应当使用 mutable</span><br><span class="line">          //       可以使用 -&gt; type 作为尾置返回类型的说明</span><br><span class="line">&#123;&#125; // 函数体</span><br></pre></td></tr></table></figure>
<p>因此<em>最简单的</em> <code>lambda</code> 应当是：<code>[]&#123;&#125;</code>。为便于多次调用，可以使用 <code>auto</code> 自动推导其类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto sayHell = [] &#123; cout &lt;&lt; &quot;Hell World!&quot;; &#125;;</span><br><span class="line">sayHell();</span><br></pre></td></tr></table></figure>
<p>来看标准库在后续版本对 <code>lambda</code> 表达式做的一些加强：</p>
<ol>
<li>C++14 起：<code>lambda</code> 表达式可以是模板了，但只能通过在类型中写 <code>auto</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto foo = [](auto cmp, auto a, auto b) &#123;</span><br><span class="line">    cout &lt;&lt; (cmp(a, b) ? &quot;YES\n&quot; : &quot;NO\n&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// less_equal&lt;int&gt;&#123;&#125;</span><br><span class="line">foo([](int a, int b) &#123; return a &lt;= b; &#125;, 1, 2);</span><br></pre></td></tr></table></figure>
<ol>
<li>C++14 起：带有捕获初始化的 <code>lambda</code>，可以在捕获的时候给初值了。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//                      x ++ (错误，必须带等号)</span><br><span class="line">int x = 4, y = [&amp;z = x, x = x + 1] &#123;</span><br><span class="line">    z += 2;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125; ();</span><br><span class="line">// x, y = 6, 25</span><br></pre></td></tr></table></figure>
<p>这使得 <code>bind</code> 的使用场景越来越少。</p>
<ol>
<li>今天的 <code>lambda</code>：若干 <code>this</code> / <code>*this</code>，支持 <code>&lt;&gt;</code> 定义模板 <code>lambda</code> 了等等，此处从略。</li>
</ol>
<hr>
<p>来写个递归的 <code>lambda</code> （尽管 C++23 可以 <code>this auto self</code> 了）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto fib = [](auto &amp;&amp;self, int n) -&gt; int &#123; </span><br><span class="line">    return n &lt;= 2 ? 1 : self(self, n - 1) + self(self, n - 2); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fib(fib, 5);</span><br></pre></td></tr></table></figure>
<p>配合上述 C++14 特性，可以写一个即刻调用的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&amp;, fib&#123;[&amp;](auto &amp;&amp;self, int n) -&gt; int &#123;</span><br><span class="line"> return n &lt;= 2 ? 1 : self(self, n - 1) + self(self, n - 2); </span><br><span class="line">&#125;&#125;] &#123; return fib(fib, 5); &#125;;</span><br></pre></td></tr></table></figure>
<p>这样写<em>有点</em>麻烦，这主要是因为写下 <code>fib</code> 这名字时类型未定，如果有个什么工具标注一下类型就<em>好</em>了，有请 ——</p>
<h2 id="函数对象-function"><a href="#函数对象-function" class="headerlink" title="函数对象 function"></a><a href="#函数对象-function">函数对象 function</a></h2><p><code>function</code> 能够接受若干「可执行的对象」<a href="#12">12</a><a href="#13">13</a>。</p>
<p>12</p>
<p><a href="https://en.cppreference.com/w/cpp/named_req/Callable">https://en.cppreference.com/w/cpp/named_req/Callable</a> <a href="#13">13</a>: <a href="https://en.cppreference.com/w/cpp/utility/functional">https://en.cppreference.com/w/cpp/utility/functional</a></p>
<p>对于上面的例子，依然需要在定义时给出类型以及返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function&lt;int(int)&gt; fib = [&amp;fib](int n) -&gt; int &#123; </span><br><span class="line"> return n &lt;= 2 ? 1 : fib(n - 1) + fib(n - 2); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; fib(5);</span><br></pre></td></tr></table></figure>
<p>其他时候的 <code>function</code> 就自由得多。下面的例子演示了如何使用 <code>function</code> 存储单个参数的三个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void anything(int = 1) &#123; &#125;</span><br><span class="line"></span><br><span class="line">auto main() -&gt; int &#123;</span><br><span class="line">    function foo = [](int = 1) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    foo = anything;</span><br><span class="line"></span><br><span class="line">    namespace NP = placeholders;</span><br><span class="line">    foo = bind(greater&lt;int&gt;&#123;&#125;, 1, NP::_1);</span><br><span class="line"></span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="折叠表达式-14"><a href="#折叠表达式-14" class="headerlink" title="折叠表达式 14"></a><a href="#折叠表达式-14">折叠表达式</a> <a href="#14">14</a></h2><p>14</p>
<p><a href="https://en.cppreference.com/w/cpp/language/fold">https://en.cppreference.com/w/cpp/language/fold</a></p>
<p><strong>要使用这一特性，请使用 C++17 及以上语言版本。</strong></p>
<p>此处不展开了，本身是个<em>不太复杂</em>语法。来看两个笔者常用的简单功能：</p>
<h3 id="输出-tuple"><a href="#输出-tuple" class="headerlink" title="输出 tuple"></a><a href="#输出-tuple">输出 tuple</a></h3><p><code>apply(a, t)</code> 将会把 <code>t</code> 拆包作为「可运行的」<code>a</code> 的参数，另外逗号表达式严格自左向右执行，算是这段代码中最有技巧性的部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename... Ts&gt;</span><br><span class="line">ostream&amp; operator&lt;&lt; (ostream &amp;os, const tuple&lt;Ts...&gt; &amp;tp) &#123;</span><br><span class="line">    apply([&amp;os](const auto &amp;...args) &#123; ((os &lt;&lt; args &lt;&lt; &quot; &quot;), ...); &#125;, tp);</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">cout &lt;&lt; tuple&#123;1, 1.F, &quot;anything&quot;, tuple&#123;1, 2, 3, &quot;hello&quot;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输出调试信息"><a href="#输出调试信息" class="headerlink" title="输出调试信息"></a><a href="#输出调试信息">输出调试信息</a></h3><p>为了利用众所周知的 <code>cerr</code><a href="#15">15</a> 与 <code>clog</code><a href="#16">16</a>，来写一个函数：</p>
<p>15</p>
<p><a href="https://en.cppreference.com/w/cpp/io/cerr">https://en.cppreference.com/w/cpp/io/cerr</a> <a href="#16">16</a>: <a href="https://en.cppreference.com/w/cpp/io/clog">https://en.cppreference.com/w/cpp/io/clog</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;typename... Args&gt;</span><br><span class="line">#ifndef ONLINE_JUDGE</span><br><span class="line">void log(const Args &amp;...args) &#123; ((cerr &lt;&lt; args &lt;&lt; &quot;, &quot;), ...); &#125;</span><br><span class="line">#else </span><br><span class="line">void log([[maybe_unused]] const Args &amp;...args) &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">log(__LINE__, &quot;ans = &quot;, ans, &quot;-----\n&quot;);</span><br></pre></td></tr></table></figure>
<p>其中包含 C++17 引入的 <code>[[maybe_unused]]</code> 能让编译器对没有使用的参数「闭嘴」。</p>
<p>什么？你更喜欢古老的 <code>printf</code> 系列？请用（略去了条件编译）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define log(fmt, args...) fprintf(stderr, fmt, ##args)</span><br><span class="line"></span><br><span class="line">log(&quot;Reached [%d], ans = %lld&quot;, __LINE__, ans);</span><br></pre></td></tr></table></figure>
<h2 id="节省或浪费生命的小玩意"><a href="#节省或浪费生命的小玩意" class="headerlink" title="节省或浪费生命的小玩意"></a><a href="#节省或浪费生命的小玩意">节省或浪费生命的小玩意</a></h2><p>这一部分将介绍一些笔者认为十分方便的语法、工具。</p>
<h3 id="超短的小语法、位运算等"><a href="#超短的小语法、位运算等" class="headerlink" title="超短的小语法、位运算等"></a><a href="#超短的小语法位运算等">超短的小语法、位运算等</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit(0)  // 在任意位置结束程序，然后去世</span><br><span class="line"></span><br><span class="line">0X3F // 十六进制</span><br><span class="line">077  // 八进制</span><br><span class="line">0B11 // 二进制（C++14）</span><br><span class="line">1&#x27;000&#x27;000&#x27;007 // 分隔符（C++14）</span><br><span class="line"></span><br><span class="line">!!x; // 为 1 表示 x 不是 0</span><br><span class="line">!x;  // 与上面相反</span><br><span class="line">~x;  // 有符号数 x 不是 -1 （这是因为 -1 补码全 1） </span><br><span class="line">~0U  // 大数</span><br><span class="line"> (x &amp; 1)   // 为 1 表示 x 是奇数  a + b &amp; 1 判定的是 (a + b) 整体</span><br><span class="line">(~x &amp; 1)   // 与上面相反，但如果使用等价的 (x &amp; 1 ^ 1) 则会报警告</span><br><span class="line">(x &gt;&gt; 1)   // x / 2 取下整（而并非 / 2 表现为向零取整）</span><br><span class="line">(x &lt;&lt; 1)   // x * 2       当心溢出</span><br><span class="line">           // x * 10 = x * 8 + x * 2 = (x &lt;&lt; 3) + (x &lt;&lt; 1)</span><br><span class="line">           // 一个自作聪明的小技巧</span><br><span class="line"></span><br><span class="line">x &amp; -x       // lowbit   =&gt; 易知 lowbit(x) == x 的数或为 0 或为 power(2, k)</span><br><span class="line">x &amp; (x - 1)  // 最低位归零 =&gt; 易知 (x &amp; (x - 1)) == 0 意义同上</span><br><span class="line"></span><br><span class="line">(1LL &lt;&lt; x) // power(2, x) 当心溢出</span><br><span class="line">__lg(x) // 二进制长度 （这里要提一下 __builtin_ 一族了）</span><br><span class="line">// 参见 https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html </span><br><span class="line">// 以及 C++ 20 头文件 &lt;bit&gt;</span><br><span class="line"></span><br><span class="line">&quot;3124&quot;[x] // 输出这个 const char[5] 中 x 下标对应的字符 当心越界</span><br><span class="line">          // 通常用作 &quot; \n&quot;[i == n]</span><br><span class="line"></span><br><span class="line">(i &amp; 1 ? odd : even).push_back(x);     // 三目运算符真好用</span><br><span class="line">set(A.begin(), A.end()).size(); // A 中的元素种类数</span><br></pre></td></tr></table></figure>
<h3 id="一些常用的循环"><a href="#一些常用的循环" class="headerlink" title="一些常用的循环"></a><a href="#一些常用的循环">一些常用的循环</a></h3><h4 id="枚举所有状态"><a href="#枚举所有状态" class="headerlink" title="枚举所有状态"></a><a href="#枚举所有状态">枚举所有状态</a></h4><p>O(n×2n)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 1 &lt;&lt; n; ++i) &#123;</span><br><span class="line">    for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">        if (i &gt;&gt; j &amp; 1) &#123;</span><br><span class="line">          // selected j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举子集"><a href="#枚举子集" class="headerlink" title="枚举子集"></a><a href="#枚举子集">枚举子集</a></h4><p>O(2popcount(n))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto i = s; i; --i &amp;= s) &#123; &#125; // 从大到小</span><br><span class="line">// 使用 s - i 就是从小到大。另外上面没算空集，额外判下</span><br></pre></td></tr></table></figure>
<h4 id="枚举-n-个选-k-个的集合"><a href="#枚举-n-个选-k-个的集合" class="headerlink" title="枚举 n 个选 k 个的集合"></a><a href="#枚举-n-个选-k-个的集合">枚举 n 个选 k 个的集合</a></h4><p>(kn​)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int t = (1 &lt;&lt; k) - 1, x, y; t &lt; 1 &lt;&lt; n; t = ((t &amp; ~y) / x &gt;&gt; 1) | y) &#123;</span><br><span class="line">    f(t);</span><br><span class="line">    y = t + (x = t &amp; -t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举倍数"><a href="#枚举倍数" class="headerlink" title="枚举倍数"></a><a href="#枚举倍数">枚举倍数</a></h4><p>O(logN)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int j = i + i; j &lt;= N; j += i) &#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出变量的类型"><a href="#输出变量的类型" class="headerlink" title="输出变量的类型"></a><a href="#输出变量的类型">输出变量的类型</a></h3><p>一个<em>看似很有用的</em>东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cxxabi.h&gt;</span><br><span class="line">// ...</span><br><span class="line">cout &lt;&lt; abi::__cxa_demangle(typeid(x).name(), &#123;&#125;, &#123;&#125;, &#123;&#125;) &lt;&lt; &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="y-组合子-——-即刻使用的递归-lambda"><a href="#y-组合子-——-即刻使用的递归-lambda" class="headerlink" title="y 组合子 —— 即刻使用的递归 lambda"></a><a href="#y-组合子--即刻使用的递归-lambda">y 组合子 —— 即刻使用的递归 lambda</a></h3><p>选自 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html">A Proposal to Add Y Combinator to the Standard Library</a> <a href="#32">17</a>。</p>
<p>17</p>
<p>“这段代码具体什么意思？” <a href="https://riptutorial.com/cplusplus/example/8508/recursive-lambdas">https://riptutorial.com/cplusplus/example/8508/recursive-lambdas</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class Fun&gt; struct y_combinator_result &#123;</span><br><span class="line">  Fun fun_;</span><br><span class="line">  template &lt;class T&gt;</span><br><span class="line">  explicit y_combinator_result(T &amp;&amp;fun) : fun_(::std::forward&lt;T&gt;(fun)) &#123;&#125;</span><br><span class="line">  template &lt;class... Args&gt; decltype(auto) operator()(Args &amp;&amp;...args) &#123;</span><br><span class="line">    return fun_(::std::ref(*this), ::std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class Fun&gt; decltype(auto) y_combinator(Fun &amp;&amp;fun) &#123;</span><br><span class="line">  return y_combinator_result&lt;::std::decay_t&lt;Fun&gt;&gt;(::std::forward&lt;Fun&gt;(fun));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; y_combinator([&amp;](auto &amp;&amp;gcd, int a, int b) -&gt; int &#123;</span><br><span class="line">    return !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;)(10, 20) &lt;&lt; &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>或者多次使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto gcd = y_combinator([&amp;](auto &amp;&amp;gcd, int a, int b) -&gt; int &#123;</span><br><span class="line"> return !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gcd(10, 20);</span><br><span class="line">gcd(11, 11);</span><br></pre></td></tr></table></figure>
<p><em>上述案例仅用于了解如何使用该语法。实际操作请使用 <code>std::__gcd</code> 或 <code>std::gcd</code>（C++17）。</em></p>
<h3 id="高维-vector"><a href="#高维-vector" class="headerlink" title="高维 vector"></a><a href="#高维-vector">高维 vector</a></h3><p>尽管根据 <strong>CTAD</strong>，C++17 开始可使用 <code>vector graph(n, vector(n, 0))</code> 来定义一个 n×n 的 <code>vector</code>，但当维数更多时，这种方法依然<em>不够</em>简洁。在 C++23 还未普及之前，下面的方法<a href="#17">18</a> 也相当不错：</p>
<p>18</p>
<p>这方法取自 <a href="https://codeforces.com/blog/entry/76149?#comment-606512">https://codeforces.com/blog/entry/76149?#comment-606512</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class... Args&gt; </span><br><span class="line">auto ndvector(size_t n, Args &amp;&amp;...args) &#123;</span><br><span class="line">  if constexpr (sizeof...(args) == 1) &#123;</span><br><span class="line">    return vector(n, args...);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return vector(n, ndvector(args...));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 维数越多越明显，但一般也就四维撑死了～</span><br><span class="line">&#123; vector g(n + 1, vector(m + 1, vector(c + 1, 0X3F3F3F3F))); &#125;</span><br><span class="line">&#123; using vector; vector g(n + 1, vector(m + 1, vector(c + 1, 0X3F3F3F3F))); &#125;</span><br><span class="line">&#123; auto g = ndvector&lt;int&gt;(n + 1, m + 1, c + 1, 0X3F3F3F3F); &#125;</span><br><span class="line"></span><br><span class="line">// 造一个超级高维的 vector：</span><br><span class="line">auto x = ndvector(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);</span><br></pre></td></tr></table></figure>
<p>上面这个 <code>x</code> 展开是什么类型 <a href="#18">19</a>？无需在意。总之，<em>都</em>让编译器忙活去吧！</p>
<p>19</p>
<p><a href="http://fars.ee/EsZ2">http://fars.ee/EsZ2</a></p>
<h2 id="语法项"><a href="#语法项" class="headerlink" title="语法项"></a><a href="#语法项">语法项</a></h2><h3 id="范围-for-20"><a href="#范围-for-20" class="headerlink" title="范围 for 20"></a><a href="#范围-for-20">范围 for</a> <a href="#19">20</a></h3><p>20</p>
<p><a href="https://en.cppreference.com/w/cpp/language/range-for">https://en.cppreference.com/w/cpp/language/range-for</a></p>
<p>如，遍历一个 <code>set&lt;int&gt;</code> 在 C++11 之前使用迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const int a[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s(a, a + 5);</span><br><span class="line">// C++11 可以 s&#123;1, 2, 3, 4, 5&#125;; 来初始化</span><br><span class="line">//      也可以将下面 it 的类型写成 auto</span><br><span class="line"></span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it ++) &#123;</span><br><span class="line">   cout &lt;&lt; *it &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++11 使用 <code>for (int i : s)</code> 即可。在 C++20 还可在 <code>for</code> 中再定义一些变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto S = &quot;Hi!&quot;; const auto i : s) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 一些其他的小技巧</span><br><span class="line">for (int i : &#123;1, 2, 3, 4, 5&#125;) &#123; &#125; </span><br><span class="line"></span><br><span class="line">vector a(n, 0); // CTAD</span><br><span class="line">for (int &amp;i : a) &#123; cin &gt;&gt; i; &#125;</span><br><span class="line"></span><br><span class="line">vector p(m, pair&#123;0, 0&#125;);</span><br><span class="line">for (auto &amp;[x, y] : p) &#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if-switch-中定义变量-21"><a href="#if-switch-中定义变量-21" class="headerlink" title="if / switch 中定义变量 21"></a><a href="#if--switch-中定义变量-21">if / switch 中定义变量</a> <a href="#20">21</a></h3><p>21</p>
<p><a href="https://en.cppreference.com/w/cpp/language/if">https://en.cppreference.com/w/cpp/language/if</a></p>
<p><strong>要使用这一特性，请使用 C++17 及以上语言版本。</strong></p>
<p>从语义上来说，确实更方便了，但也许会部分编码者抓狂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (int op = read(); op == 1) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;  else if (op == 2) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="auto22-初始化-23-CTAD24-结构化绑定-25-等"><a href="#auto22-初始化-23-CTAD24-结构化绑定-25-等" class="headerlink" title="auto22, 初始化 23, CTAD24, 结构化绑定 25 等"></a><a href="#auto22-初始化23-ctad24-结构化绑定25等">auto</a><a href="#21">22</a>, 初始化 <a href="#22">23</a>, CTAD<a href="#23">24</a>, 结构化绑定 <a href="#24">25</a> 等</h3><p>22</p>
<p><a href="https://en.cppreference.com/w/cpp/keyword/auto">https://en.cppreference.com/w/cpp/keyword/auto</a> <a href="#22">23</a>: <a href="https://en.cppreference.com/w/cpp/language/list_initialization">https://en.cppreference.com/w/cpp/language/list_initialization</a> <a href="#23">24</a>: <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">https://en.cppreference.com/w/cpp/language/class_template_argument_deduction</a> <a href="#24">25</a>: <a href="https://en.cppreference.com/w/cpp/language/structured_binding">https://en.cppreference.com/w/cpp/language/structured_binding</a></p>
<p>C++11 的到来使得这个语言充满活力，尤其是 <code>auto</code> 的拓展。聚合（或其他）初始化则更加配合这一点，一些经典的例子是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto /*占位*/ do_nothing = []&#123;&#125;; // 承载 lambda</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">auto sum_up(T a, T b) &#123; return a + b; &#125;</span><br><span class="line">// C++20 简写模板可写的更简洁</span><br><span class="line"></span><br><span class="line">int arr[10]&#123;&#125;; // 初始化</span><br><span class="line"></span><br><span class="line">auto main() -&gt; int &#123; &#125;</span><br><span class="line"></span><br><span class="line">// initializer_list&lt;int&gt; </span><br><span class="line">// C++17 起这里一定带等号</span><br><span class="line">auto init_list = &#123; 1, 2, 3, 4, &#125;;</span><br><span class="line"></span><br><span class="line">decltype(b) a;</span><br></pre></td></tr></table></figure>
<p>配合后续版本增加的特性，<code>auto</code> 更为通用：</p>
<h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a><a href="#结构化绑定">结构化绑定</a></h3><p><strong>要使用这一特性，请使用 C++17 及以上语言版本。</strong></p>
<p>绑定数组、<code>tuple-like</code>、或者只是一个普通的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int arr[] = &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">auto &amp;[a, b, c, d] = arr;</span><br><span class="line">c++;</span><br><span class="line"></span><br><span class="line">const auto [x, y, _] = tuple&#123;1, &quot;anything&quot;, 1.F&#125;; // CTAD</span><br><span class="line"></span><br><span class="line">struct point  &#123; int x, y; &#125;;</span><br><span class="line">auto [x, y] = point&#123;1, 1&#125;; </span><br><span class="line">// 然而笔者感到遗憾的是，还不支持形如 auto [[x, y], r] 的语法</span><br></pre></td></tr></table></figure>
<h3 id="CTAD"><a href="#CTAD" class="headerlink" title="CTAD"></a><a href="#ctad">CTAD</a></h3><p><strong>要使用这一特性，请使用 C++17 及以上语言版本。</strong></p>
<p>再也不需要写全类型了，如 <code>pair&lt;int, double&gt; t &#123; 1, 1. &#125;</code> 可直接写为 <code>pair t&#123; 1, 1. &#125;</code> <a href="#25">26</a></p>
<p>26</p>
<p><code>1.</code> 是 <code>double</code> 类型而 <code>1.F</code> 是 <code>float</code> 类型</p>
<p>而 <code>vector&lt;vector&lt;int&gt;&gt; a(n)</code> 也可写为 <code>vector a(n, vector(0, 0))</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto [dx, dy] : &#123;pair&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;) &#123;</span><br><span class="line">    int x = dx + px, y = dy + py;</span><br><span class="line">&#125; // 遍历方向</span><br><span class="line"></span><br><span class="line">auto mp = map&#123;pair&#123;1, 1&#125;, &#123;2, 1&#125;, &#123;-1, 1&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="输入一行带空格的字符串-27"><a href="#输入一行带空格的字符串-27" class="headerlink" title="输入一行带空格的字符串 27"></a><a href="#输入一行带空格的字符串-27">输入一行带空格的字符串</a> <a href="#26">27</a></h3><p>27</p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/getline">https://en.cppreference.com/w/cpp/string/basic_string/getline</a></p>
<p>对一个 <code>char[]</code> 可使用正则表达式 <code>scanf(&quot; %[^\n]&quot;, str)</code>。<a href="#27">28</a></p>
<p>28</p>
<p><a href="https://en.cppreference.com/w/c/io/fscanf">https://en.cppreference.com/w/c/io/fscanf</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">getline(cin, s);</span><br></pre></td></tr></table></figure>
<p>注意会吃掉 <code>&#39;\n&#39;</code> 。读者可尝试以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int foo; </span><br><span class="line">cin &gt;&gt; foo;</span><br><span class="line"></span><br><span class="line">// cin.ignore();</span><br><span class="line">string s;</span><br><span class="line">getline(cin, s);</span><br><span class="line">cout &lt;&lt; quoted(s) &lt;&lt; &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="多个字符串黏起来的字符串"><a href="#多个字符串黏起来的字符串" class="headerlink" title="多个字符串黏起来的字符串"></a><a href="#多个字符串黏起来的字符串">多个字符串黏起来的字符串</a></h3><p>当你的代码中出现了一行很长的字符串，你可以将它们分隔开来，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char *str = &quot;Hey! &quot;</span><br><span class="line">  &quot;What? You have a new line! &quot;</span><br><span class="line">  &quot;How you did that? &quot;;</span><br></pre></td></tr></table></figure>
<h3 id="原始字符串-29"><a href="#原始字符串-29" class="headerlink" title="原始字符串 29"></a><a href="#原始字符串-29">原始字符串</a> <a href="#28">29</a></h3><p>29</p>
<p><a href="https://en.cppreference.com/w/cpp/language/string_literal">https://en.cppreference.com/w/cpp/language/string_literal</a></p>
<p>不处理转义字符的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string raw = R&quot;(\n\r\b\t\</span><br><span class="line"></span><br><span class="line">这些换行也不处理 ...</span><br><span class="line"></span><br><span class="line">)&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="一些好用的-STL-类-30-函数"><a href="#一些好用的-STL-类-30-函数" class="headerlink" title="一些好用的 STL 类 30/ 函数"></a><a href="#一些好用的-stl-类30函数">一些好用的 STL 类</a> <a href="#29">30</a>/ 函数</h2><p>30</p>
<p>为什么没有 pbds? 我实在是太懒了 …</p>
<h3 id="排序、乱序等"><a href="#排序、乱序等" class="headerlink" title="排序、乱序等"></a><a href="#排序乱序等">排序、乱序等</a></h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a><a href="#排序">排序</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(A.begin(), A.end());</span><br><span class="line">sort(A.rbegin(), A.rend()); // 反着排</span><br><span class="line"></span><br><span class="line">sort(A.begin(), A.end(), [](auto &amp;a, auto &amp;b) &#123;</span><br><span class="line">    return ::abs(a) &lt; ::abs(b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="已经有序"><a href="#已经有序" class="headerlink" title="已经有序"></a><a href="#已经有序">已经有序</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">is_sorted(A.begin(), A.end()); // 非严格升序</span><br><span class="line">is_sorted(A.begin(), A.end(), less_equal&lt;&gt;&#123;&#125;); // 严格升序</span><br></pre></td></tr></table></figure>
<h4 id="乱序"><a href="#乱序" class="headerlink" title="乱序"></a><a href="#乱序">乱序</a></h4><p>自 C++17 起 <code>random_shuffle</code> 被弃用，现在使用 <code>shuffle</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector a &#123;-6, 1, 2, 3, 4, 4, 5&#125;;</span><br><span class="line">mt19937 rng&#123;</span><br><span class="line">    chrono::steady_clock::now()</span><br><span class="line">    .time_since_epoch()</span><br><span class="line">    .count()</span><br><span class="line">&#125;;</span><br><span class="line">// 传 time(nullptr) 亦可</span><br><span class="line">shuffle(a.begin(), a.end(), rng);</span><br></pre></td></tr></table></figure>
<p><em>顺便看看 <code>stable_sort</code></em></p>
<h3 id="创建一个排列"><a href="#创建一个排列" class="headerlink" title="创建一个排列"></a><a href="#创建一个排列">创建一个排列</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iota(A.begin(), A.end(), 1); // 1, 2, 3, ...</span><br><span class="line">iota(A.rbegin(), A.rend(), 0); // n - 1, n - 2, ..., 2, 1, 0</span><br></pre></td></tr></table></figure>
<h3 id="累积-accumulate"><a href="#累积-accumulate" class="headerlink" title="累积 accumulate"></a><a href="#累积-accumulate">累积 accumulate</a></h3><p>求和 / 积、或者是其他操作，下面是两个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accumulate(A.begin(), A.end(), 0LL); </span><br><span class="line">// 注意不要传入 0 使用 int+ 带来不该的溢出</span><br><span class="line">accumulate(A.begin(), A.end(), 0, bit_xor&lt;int&gt;&#123;&#125;); // 异或和</span><br></pre></td></tr></table></figure>
<h3 id="求最值"><a href="#求最值" class="headerlink" title="求最值"></a><a href="#求最值">求最值</a></h3><p><code>m&#123;in&#123;, max&#125;, ax&#125;&#123;_element&#125;</code> 都可以传比较器，如 <code>min(a, b, cmp)</code></p>
<p>有的时候是不同类型做操作，可以追加类型：<code>min&lt;long long&gt;(0, b)</code></p>
<p>可以传 <code>initializer_list</code>，如 <code>max(&#123;a, b, c, d, ...&#125;)</code> 不过这实际上也是<em>非常</em>蛋疼的一点 ，意味着 <code>min</code> 是二义性的，想封装一个 <strong>Sparse Table</strong> 板子的话需要注意这一点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max(max(max(a, b), c), d);</span><br><span class="line">max(&#123;a, b, c, d&#125;);</span><br><span class="line"></span><br><span class="line">// initializer_list</span><br><span class="line">auto A = &#123;-6, 1, 2, 3, 4, 4, 5&#125;;</span><br><span class="line">auto [m, M] = minmax(A);</span><br><span class="line"></span><br><span class="line">tie(m, M) = minmax(&#123; i, i * m, i * M &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a><a href="#离散化">离散化</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(A.begin(), A.end());</span><br><span class="line">A.resize(unique(A.begin(), A.end()) - begin(A));</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(c + 1, c + 1 + tot);</span><br><span class="line">tot = unique(c + 1, c + 1 + tot) - (c + 1);</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">    a[i] = lower_bound(c + 1, c + 1 + tot, a[i]) - c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a href="#其他">其他</a></h3><p>包括但不限于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count&#123;, _if&#125;()</span><br><span class="line">generate&#123;, _n&#125;()</span><br><span class="line">fill&#123;, _n&#125;()</span><br><span class="line">copy&#123;, _if&#125;()</span><br><span class="line">&#123;lower, upper &#125;_bound()</span><br><span class="line">equal_range()</span><br><span class="line">binary_search()</span><br><span class="line">nth_element()</span><br><span class="line">partial_sum()</span><br><span class="line">adjacent_difference()</span><br><span class="line">&#123;, inplace_&#125;merge()</span><br><span class="line">reverse()</span><br><span class="line">mismatch()</span><br><span class="line">rotate()</span><br><span class="line">__gcd()</span><br><span class="line">gcd() (C++17)</span><br><span class="line">lcm() (C++17)</span><br><span class="line">inner_product()</span><br><span class="line">transform()</span><br><span class="line">&#123;all, any, none&#125;_of()</span><br><span class="line">&#123;is, next, prev&#125;_permutation()</span><br><span class="line">basic_string</span><br></pre></td></tr></table></figure>
<p>效率不是非常高的（甚至可以说很差）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">valarray</span><br><span class="line">regex</span><br><span class="line">complex (这个算吗...)</span><br></pre></td></tr></table></figure>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="* 其他注意事项"></a><a href="#-其他注意事项">* 其他注意事项</a></h3><ol>
<li><p>I/O <code>cin.tie(nullptr)-&gt;sync_with_stdio(false)</code>。具体原因可直接百度或查看 <a href="https://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio"><code>cppreference ios_base::sync_with_stdio</code></a> 以及 <code>cin</code> 相关文档。看完这些，读者也应同时理解了为什么 <code>endl</code> 那样「慢」。</p>
</li>
<li><p><code>vector::iterator</code> 可以直接当作指针用。（<code>RandomAccessIterator</code>），比如 <code>V.end()[-1]</code>, <code>V.rbegin()[0]</code>。本质上就是 <code>i[x]</code> 等价于 <code>*(i + x)</code>。</p>
</li>
<li><p>知道 <code>vector</code> 的大小，要么直接开，要么先 <code>reserve</code> 一下再 <code>&#123;push, emplace&#125;_back</code></p>
</li>
<li><p><code>vector</code> 的 <code>resize / clear</code> 方法之后，记得 <code>shrink_to_fit</code>。<a href="#30">31</a></p>
</li>
<li><p>一些没有 <code>clear()</code> 成员方法的容器（<code>queue</code>, <code>stack</code>, <code>...</code>）可以 <code>decltype(cap)&#123;&#125;.swap(cap)</code> 流放之。</p>
</li>
<li><p>除 <code>array</code> 外，所有容器的 <code>swap</code> 方法都是 O(1) 的。</p>
</li>
<li><p>在栈上定义的 <code>array</code> 开在栈上，而 <code>vector</code> 对象开在栈上，数据开在堆上。</p>
</li>
<li><p>注意该不该引用（能不能用右值引用续命），能不能移动（如果可以尽可能使用 <code>move</code>）</p>
</li>
<li><p><code>multi&#123;set, map&#125;::count</code> 的复杂度是 O( 出现次数 +log(n) ，而 C++20 的 <code>contains</code> 则是 O(logn)</p>
</li>
<li><p><code>size_t</code> 类型应强转，或使用 C++20 的 <code>ssize()</code> 获取长度。</p>
</li>
<li><p>用迭代器边遍历 <code>set</code> 边删除迭代器时应使用 <code>it = S.erase(it)</code> 来代替 <code>it ++</code>。也就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto it = s.begin(); it != s.end(); ) &#123;</span><br><span class="line">  if (!judge(*it)) &#123;</span><br><span class="line">    it = s.erase(it);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    it ++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>set::merge(t)</code> 是直接把不同于两集合的元素从 <code>t</code> 直接薅走，意义与 <code>set::insert(t.begin(), t.end())</code> 不总一样。</p>
</li>
</ol>
<p>31</p>
<p><a href="https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit">https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit</a></p>
<p><em>这个条目等我下次破防再更新</em></p>
<h2 id="本文即将移除的条目"><a href="#本文即将移除的条目" class="headerlink" title="本文即将移除的条目"></a><a href="#本文即将移除的条目">本文即将移除的条目</a></h2><h3 id="程序计时"><a href="#程序计时" class="headerlink" title="程序计时"></a><a href="#程序计时">程序计时</a></h3><p>笔者一直主观不赞成将计时嵌入至代码的行为，只是单文件、单元测试，完全可以使用系统的计时工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Measure-Command &#123;xxx | Out-Default&#125;).ToString()</span><br><span class="line">Measure-Command &#123;cat 1.in | .\A | Out-Default&#125; | findstr TotalMilliseconds</span><br></pre></td></tr></table></figure>
<p><img data-src="https://picx.zhimg.com/80/v2-f9da1419ab0b7fc9c79062ec59619a38_720w.png?source=d16d100b" alt=""></p>
<h2 id="后记、致谢、贴贴"><a href="#后记、致谢、贴贴" class="headerlink" title="后记、致谢、贴贴"></a><a href="#后记致谢贴贴">后记、致谢、贴贴</a></h2><ul>
<li>感谢 <a href="https://www.zhihu.com/people/newlzc">@MeteorZ</a> 对 「判断是二的幂」 做的 「特判 0 」 补充。</li>
<li>感谢 <a href="https://www.zhihu.com/people/test-76-72-74">@Lhgzbxhz</a> 对「断言」做的「<code>__builtin_unreachable()</code>」补充。</li>
<li>感谢 <a href="https://www.zhihu.com/people/tyl-11-17">@阿汤</a> 对「判断是二的幂」做的「<code>(x&amp;(x-1))==0</code>」补充。</li>
<li>感谢 <a href="https://www.zhihu.com/people/qing-kuang-shu-sheng-17-32">@轻狂书生</a> 对「程序计时」做的催更。</li>
<li>感谢 <a href="https://www.zhihu.com/people/soulmate-66-60">@soulmate</a> 对删除「异常处理」与「<code>std::regex</code>」内容的建议。</li>
<li>感谢 <a href="https://gist.github.com/Patricky-Tau/8d3ffbf51196546028041647cafc7bf2?permalink_comment_id=4237886#gistcomment-4237886">@n-WN</a> 对「预定义宏」的补充。</li>
</ul>
<h2 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a><a href="#changelog">changelog</a></h2><p>UPD: 本文已经从「算法竞赛中常用的语法操作」重命名为 「算法竞赛中的 C++ 语法操作」。</p>
<p>UPD(22-09-16): 这次更新给每一个条目都加上了 cppreference 的链接（如果有）并重新规划了文章结构。</p>
<p>UPD(22-09-30): 移除了「一些位运算」条目。增加了 y 组合子。</p>
<p>UPD(23-04-10): 纠正了 C++14 lambda 相关描述，增加了一个即刻调用的递归 lambda 写法。并附上了本文的 markdown 版本。能坚持到现在真是一个奇迹，希望下次更新不会太久。</p>
]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找 &amp; 二分答案</title>
    <url>/posts/a56928c5/</url>
    <content><![CDATA[<p>很多人对二分感到很苦恼，很困惑，可能是因为二分的边界很难掌握，也许是判断条件难写…</p>
<p>然而，很幸运，你找到了这篇文章，仔细看下去，这篇文章将带你<strong>学透二分</strong>！！！</p>
<p>二分可以简单分为<code>二分查找</code>与<code>二分答案</code>。</p>
<p>可能你听说过<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&amp;spm=1001.2101.3001.7020">二分查找</a>，二分查找和二分答案是不是一回事呢？答案是否定的。二分查找只是单纯的查找就可以了，简单的控制好边界条件。而二分答案也许稍复杂些。</p>
<h2 id="首先，我们看一下二分的模板："><a href="#首先，我们看一下二分的模板：" class="headerlink" title="首先，我们看一下二分的模板："></a>首先，我们看一下二分的模板：</h2><h6 id="模板-1："><a href="#模板-1：" class="headerlink" title="模板 1："></a>模板 1：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r &gt;&gt; 1;	//(l+r)/2</span><br><span class="line">        if (check(mid))  r = mid;    // check()判断mid是否满足性质</span><br><span class="line">        else l = mid + 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="模板-2："><a href="#模板-2：" class="headerlink" title="模板 2："></a>模板 2：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = l + r + 1 &gt;&gt; 1;	//(l+r+1)/2</span><br><span class="line">        if (check(mid))  l = mid;</span><br><span class="line">        else r = mid - 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>看到这，以后的你就不会因为边界问题而困惑了！！！</strong></p>
<p><strong>第一个模板是尽量往左找目标，第二个模板是尽量往右找目标。</strong></p>
<p><strong>只要是往左找答案，就用第一个模板，mid 不用加一，r=mid，l 加一；<br>只要是往右找答案，就用第二个模板，mid 要加一，l=mid，r 要减一；</strong></p>
<p>二分套这两个模板，肯定没错！（只要判断条件写对）亲测有效！！！<br>下面的题目更能证明这句话！</p>
<h3 id="这两个模板一定要牢牢记住哦"><a href="#这两个模板一定要牢牢记住哦" class="headerlink" title="这两个模板一定要牢牢记住哦"></a>这两个模板一定要牢牢记住哦</h3><p>当然，二分可能在实数中进行，那自然少不了浮点二分。</p>
<h6 id="模板-3：（浮点二分）"><a href="#模板-3：（浮点二分）" class="headerlink" title="模板 3：（浮点二分）"></a>模板 3：（浮点二分）</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(r-l&gt;1e-5) //需要一个精度保证</span><br><span class="line">	&#123;</span><br><span class="line">		double mid = (l+r)/2;</span><br><span class="line">		if(check(mid)) l=mid; //或r=mid;</span><br><span class="line">		else r=mid; //或l=mid;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>浮点二分就相对简单多了，因为浮点除法不会取整，所以 mid，l，r，都不用加 1 或减 1.</p>
<h2 id="我们先来学二分查找："><a href="#我们先来学二分查找：" class="headerlink" title="我们先来学二分查找："></a>我们先来学二分查找：</h2><p>二分查找也称折半查找，顾名思义，就是每次查找去掉不符合条件的一半区间，直到找到答案（整数二分）或者和答案十分接近（浮点二分）。</p>
<p>光说不练假把式，来个例题：</p>
<h5 id="例题-1——查找"><a href="#例题-1——查找" class="headerlink" title="例题 1——查找"></a>例题 1——<a href="https://www.luogu.com.cn/problem/P2249">查找</a></h5><p><img data-src="https://img-blog.csdnimg.cn/20210314114655469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>分析：这题就是典型的二分查找入门题。</strong></p>
<p><strong>首先，区间是有<code>单调性</code>的，查找第一次出现的位置，如果查到一个值比目标值大，就把右半边放弃，因为右半边肯定也比目标值大；同样，如果查到值比目标值小，那就放弃左半边。</strong></p>
<p>本文的所有例题都有分析，题解，并注上详细注释。先自己尝试一下，再看题解哦。</p>
<h5 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000010;</span><br><span class="line">int a[N],x,q,n;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	</span><br><span class="line">	while(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		int l=1,r=n; //左右边界 </span><br><span class="line">		while(l&lt;r) //因为是找第一次出现的位置，那就是尽量往左来，就用模板1 </span><br><span class="line">		&#123;</span><br><span class="line">			int mid=l+r&gt;&gt;1;</span><br><span class="line">			if(a[mid]&gt;=x) r=mid; //判断条件，如果值大于等于目标值，说明在目标值右边，尽量往左来</span><br><span class="line">			else l=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a[l]!=x)&#123; //如果找不到这个值 </span><br><span class="line">			cout&lt;&lt;-1&lt;&lt;&quot; &quot;;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;l&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个小问题就是，如果找不到这个值（即，集合里没有这个数）怎么办？因为判断条件是大于等于目标值，那返回的就是第一个大于目标值的位置。</p>
<h4 id="好了，现在的你已经进入了二分世界的大门，此时让我们畅游吧！"><a href="#好了，现在的你已经进入了二分世界的大门，此时让我们畅游吧！" class="headerlink" title="好了，现在的你已经进入了二分世界的大门，此时让我们畅游吧！"></a>好了，现在的你已经进入了二分世界的大门，此时让我们畅游吧！</h4><h5 id="例-2——A-B-数对"><a href="#例-2——A-B-数对" class="headerlink" title="例 2——A-B 数对"></a>例 2——<a href="https://www.luogu.com.cn/problem/P1102">A-B 数对</a></h5><p><img data-src="https://img-blog.csdnimg.cn/20210314132349914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>分析：给出了 C，我们要找出 A 和 B。我们可以遍历数组，即让每一个值先变成 B，然后二分找对应的 A 首次出现位置，看是否能找到。</strong></p>
<p><strong>如果找到 A，那就二分找最后出现的位置，继而，求出 A 的个数，即数对的个数。</strong></p>
<h5 id="code：-1"><a href="#code：-1" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=200010;</span><br><span class="line">long long a[N],n,c,cnt,st;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	sort(a+1,a+1+n);	//先排序 </span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;n;i++)	//遍历每一个B </span><br><span class="line">	&#123;</span><br><span class="line">		int l=i+1,r=n;	//寻找A第一次出现的位置，使得A-B=C </span><br><span class="line">		while(l&lt;r) //因为是第一次出现，尽量往左，模板1</span><br><span class="line">		&#123;</span><br><span class="line">			int mid=l+r&gt;&gt;1;</span><br><span class="line">			if(a[mid]-a[i]&gt;=c) r=mid;	//判断：在目标值的右边，满足，往左来</span><br><span class="line">			else l=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a[l]-a[i]==c) st=l; //能找到C就继续 </span><br><span class="line">		else continue;</span><br><span class="line">		</span><br><span class="line">		l=st-1,r=n;	//查找A最后出现的位置 </span><br><span class="line">		while(l&lt;r) //因为是最后一次出现，尽量往右，模板2</span><br><span class="line">		&#123;</span><br><span class="line">			int mid=l+r+1&gt;&gt;1;</span><br><span class="line">			if(a[mid]&lt;=a[st]) l=mid; //判断：在目标值的左边，满足，往右去</span><br><span class="line">			else r=mid-1;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt+=l-st+1;	//最后出现的位置减首次出现的位置就是区间长度，即A的个数 </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;cnt;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你把上面的两个题完全搞懂了，那很容易就抽象出做题步骤：</p>
<p><strong>如果题目明确说了 要求最小值（最前面的值）还是求最大值（最后面的值），就能判断是用模板 1（求最小），还是用模板 2（求最大）。<br>之后再根据模板 1，或模板 2，写出对应的判断条件；</strong></p>
<p>但是，我们不建议死记模板，更重要的是在理解之后的灵活变通。比如，再看一个题。</p>
<h5 id="例-3——烦恼的高考志愿"><a href="#例-3——烦恼的高考志愿" class="headerlink" title="例 3——烦恼的高考志愿"></a>例 3——<a href="https://www.luogu.com.cn/problem/P1678">烦恼的高考志愿</a></h5><p><img data-src="https://img-blog.csdnimg.cn/20210314135526382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>分析：这题，就需要稍微理解一下下。</strong></p>
<p><strong>要求估分和分数线相差最小，那肯定分数线刚超过估分或者估分刚超过分数线。我们就转化为，求第一个大于等于估分的分数线的位置。</strong></p>
<p><strong>如此，这个位置的分数线或前一位置的分数线就是和估分相差最小的。</strong></p>
<h5 id="code：-2"><a href="#code：-2" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e5+10;</span><br><span class="line">long long a[N],x,sum,n,m;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	sort(a+1,a+n+1); //排序勿忘 </span><br><span class="line">	a[0]=-1e12;a[n+1]=1e12;	 //最后再解释</span><br><span class="line">	</span><br><span class="line">	while(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		int l=1,r=n+1;	//r设为n+1 </span><br><span class="line">		while(l&lt;r) //寻找第一个超过估分的学校，那它或它前面的一个学校就是目标学校 </span><br><span class="line">		&#123;</span><br><span class="line">			int mid=l+r&gt;&gt;1;</span><br><span class="line">			if(a[mid]&gt;=x) r=mid;</span><br><span class="line">			else l=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(a[l]-x&lt;=x-a[l-1]) sum+=a[l]-x;</span><br><span class="line">		else sum+=x-a[l-1];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout&lt;&lt;sum;</span><br><span class="line">	return 0;</span><br><span class="line">	//a[0]=-1e12: 所有分数先可能都比估分大，那么l就为1，n-1就为0，故设a[0]为无穷小，则第一个值就为解 </span><br><span class="line">	//a[n+1]=1e12: 所有分数线可能都比估分小，那么l就为n,a[l]-x可能为负，则设a[n+1]为无穷大，</span><br><span class="line">				//并将r设为n+1，如此，l最大为n+1，则最后一个就为解 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，STL 中还有两个二分函数：lower_bound 和 upper_bound；具体可以看<a href="https://blog.csdn.net/m0_54621932/article/details/113780956">这个博客</a>；或<a href="https://blog.csdn.net/qiang_____0712/article/details/84196839">这个</a>~（有很多大佬总结的知识点都很好，有啥不懂的话都可以翻博客）~<br>有了这两个函数，我们就可以很方便的求出第一个大于（或等于）目标值的位置；于是，上面代码的中间可以这样改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		int t=lower_bound(a+1,a+n+1,x)-a; //如果分数线都比估分低，那返回的位置是n+1，否则返回第一个大于等于估分的位置。</span><br><span class="line">		if(a[t]-x&lt;=x-a[t-1]) sum+=a[t]-x;</span><br><span class="line">		else sum+=x-a[t-1];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>是不是简洁多了？</strong></p>
<p>最后，我们再来看一个浮点二分：</p>
<h5 id="例-4——银行贷款"><a href="#例-4——银行贷款" class="headerlink" title="例 4——银行贷款"></a>例 4——<a href="https://www.luogu.com.cn/problem/P1163">银行贷款</a></h5><p><img data-src="https://img-blog.csdnimg.cn/2021031414463155.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>分析：对于月利率，大几率是小数，那么，我们就需要浮点二分。</strong></p>
<p><strong>月利率的范围可以放大些，比如，0~500，然后从这个范围里查，直到和答案极度相近，终止。 最后的 l 或 r，精确位数之后就是正确✔答案啦！</strong></p>
<h5 id="code：-3"><a href="#code：-3" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int sum,t,mon;</span><br><span class="line">double sumt;</span><br><span class="line"></span><br><span class="line">int check(double mid) &#123;</span><br><span class="line">	sumt=sum;</span><br><span class="line">	for(int i=1;i&lt;=mon;i++)&#123;</span><br><span class="line">		sumt=sumt+sumt*mid-t;</span><br><span class="line">	&#125;</span><br><span class="line">	if(sumt &gt; 0) return 1; 				//这里是&gt;0, 感谢评论区小伙伴提醒~</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;sum&gt;&gt;t&gt;&gt;mon;</span><br><span class="line">	</span><br><span class="line">	double l=0,r=500; //答案范围尽量开大些</span><br><span class="line">	while(r-l&gt;1e-5)	//精度保证 </span><br><span class="line">	&#123;</span><br><span class="line">		double mid=(l+r)/2;</span><br><span class="line">		if(check(mid)) r=mid;	//如果最后还不完了，说明利率高了 </span><br><span class="line">		else l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.1f&quot;,l*100);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，相信你已经对二分查找有一个更加清晰的认识了。</p>
<p><strong>课后再来几个练习题吧：<br>整数二分：<br>1、 <a href="https://www.acwing.com/problem/content/791/">数的范围</a><br>2、 <a href="https://www.luogu.com.cn/problem/P1873">砍树</a><br>实数二分：<br>3、 <a href="https://www.acwing.com/problem/content/792/">数的三次方根</a><br>4、 <a href="https://www.luogu.com.cn/problem/P1024">一元三次方程求解</a></strong></p>
<h2 id="学会了二分查找，来学二分答案！"><a href="#学会了二分查找，来学二分答案！" class="headerlink" title="学会了二分查找，来学二分答案！"></a>学会了二分查找，来学二分答案！</h2><p>首先:</p>
<h5 id="二分查找与二分答案有何区别"><a href="#二分查找与二分答案有何区别" class="headerlink" title="二分查找与二分答案有何区别?"></a>二分查找与二分答案有何区别?</h5><p>二分查找：在一个已知的有序数据集上进行二分地查找<br>二分答案：答案有一个区间，在这个区间中二分，直到找到最优答案</p>
<h5 id="什么是二分答案？"><a href="#什么是二分答案？" class="headerlink" title="什么是二分答案？"></a>什么是二分答案？</h5><p>答案属于一个区间，当这个区间很大时，暴力超时。但重要的是——<strong>这个区间是对题目中的某个量有单调性的</strong>，此时，我们就会二分答案。每一次二分会做一次判断，看是否对应的那个量达到了需要的大小。<br>判断：根据题意写个 check 函数，如果满足 check，就放弃右半区间（或左半区间），如果不满足，就放弃左半区间（或右半区间）。一直往复，直至到最终的答案。</p>
<p>其实，上面二分查找的例 4，寻找的那个区间就是答案区间。</p>
<p><strong>这不就相当于高中做选择题的时候，完了，不会做，那咋搞，把四个选项代进去看看对不对吧！哪个行得通那个就是答案！！</strong></p>
<p>只不过我们现在要找的是<code>最大的或者最小的答案</code>。</p>
<h5 id="如何判断一个题是不是用二分答案做的呢"><a href="#如何判断一个题是不是用二分答案做的呢" class="headerlink" title="如何判断一个题是不是用二分答案做的呢?"></a>如何判断一个题是不是用二分答案做的呢?</h5><h6 id="1、答案在一个区间内（一般情况下，区间会很大，暴力超时）"><a href="#1、答案在一个区间内（一般情况下，区间会很大，暴力超时）" class="headerlink" title="1、答案在一个区间内（一般情况下，区间会很大，暴力超时）"></a>1、答案在一个区间内（一般情况下，区间会很大，暴力超时）</h6><h6 id="2、直接搜索不好搜，但是容易判断一个答案可行不可行"><a href="#2、直接搜索不好搜，但是容易判断一个答案可行不可行" class="headerlink" title="2、直接搜索不好搜，但是容易判断一个答案可行不可行"></a>2、直接搜索不好搜，但是容易判断一个答案可行不可行</h6><h6 id="3、该区间对题目具有单调性，即：在区间中的值越大或越小，题目中的某个量对应增加或减少。"><a href="#3、该区间对题目具有单调性，即：在区间中的值越大或越小，题目中的某个量对应增加或减少。" class="headerlink" title="3、该区间对题目具有单调性，即：在区间中的值越大或越小，题目中的某个量对应增加或减少。"></a>3、该区间对题目具有单调性，即：在区间中的值越大或越小，题目中的某个量对应增加或减少。</h6><p><strong>此外，可能还会有一个典型的特征</strong>：<code>求...最大值的最小 、 求...最小值的最大。</code><br>1、<code>求...最大值的最小</code>，我们二分答案（即二分最大值）的时候，判断条件满足后，尽量让答案往前来（即：让 r=mid），对应模板 1；<br>2、同样，<code>求...最小值的最大</code>时，我们二分答案（即二分最小值）的时候，判断条件满足后，尽量让答案往后走（即：让 l=mid），对应模板 2；</p>
<p>先看一个经典的二分答案入门：</p>
<h5 id="例-1——木材加工"><a href="#例-1——木材加工" class="headerlink" title="例 1——木材加工"></a>例 1——<a href="https://www.luogu.com.cn/problem/P2440">木材加工</a></h5><p><img data-src="https://img-blog.csdnimg.cn/20210314151456300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<h6 id="分析：看，答案就在区间（1，100000000）里，就等着我们找呢，暴力肯定超时，那可能就用二分。"><a href="#分析：看，答案就在区间（1，100000000）里，就等着我们找呢，暴力肯定超时，那可能就用二分。" class="headerlink" title="分析：看，答案就在区间（1，100000000）里，就等着我们找呢，暴力肯定超时，那可能就用二分。"></a>分析：看，答案就在区间（1，100000000）里，就等着我们找呢，暴力肯定超时，那可能就用二分。</h6><h6 id="满足条件："><a href="#满足条件：" class="headerlink" title="满足条件："></a>满足条件：</h6><p><strong>1，答案在一个区间里。<br>2，如果给一个答案，给目标一个小段的长度，很容易判断是否到 K 个了。<br>3，具有单调性，目标小段越长，那能切出的段数越少，目标小段越短，能切出的段数越多。而最终需要 K 个，从而很容易判断一个答案行不行。</strong></p>
<h5 id="一看求啥，求最长长度，最长？这不，关门打狗，模板-2！-！"><a href="#一看求啥，求最长长度，最长？这不，关门打狗，模板-2！-！" class="headerlink" title="一看求啥，求最长长度，最长？这不，关门打狗，模板 2！ ！"></a>一看求啥，求最长长度，最长？这不，关门打狗，模板 2！ ！</h5><h5 id="那，判断条件？模板-2，如果满足判断，l-mid。啥叫满足呢？那肯定是满足需要的段数了呗！"><a href="#那，判断条件？模板-2，如果满足判断，l-mid。啥叫满足呢？那肯定是满足需要的段数了呗！" class="headerlink" title="那，判断条件？模板 2，如果满足判断，l=mid。啥叫满足呢？那肯定是满足需要的段数了呗！"></a>那，判断条件？模板 2，如果满足判断，l=mid。啥叫满足呢？那肯定是满足需要的段数了呗！</h5><h5 id="code：-4"><a href="#code：-4" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1e5+10;</span><br><span class="line">long long a[N],n,m,sum,maxa;</span><br><span class="line"></span><br><span class="line">int check(int mid) &#123;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		sum+=a[i]/mid;</span><br><span class="line">	&#125;</span><br><span class="line">	if(sum&gt;=m) return 1; //总段数大于等于所需要的 </span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i],sum+=a[i];</span><br><span class="line">		if(a[i]&gt;maxa) maxa=a[i];  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(sum&lt;m)&#123;cout&lt;&lt;0;return 0;&#125; //先判断是否有解 </span><br><span class="line">	</span><br><span class="line">	int l=1,r=maxa;</span><br><span class="line">	while(l&lt;r) //模板2 </span><br><span class="line">	&#123;</span><br><span class="line">		int mid=l+r+1&gt;&gt;1;</span><br><span class="line">		if(check(mid)) l=mid; </span><br><span class="line">		else r=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>是不是感觉很有意思？</strong></p>
<p>再来看个经典的</p>
<h5 id="例-2——跳石头"><a href="#例-2——跳石头" class="headerlink" title="例 2——跳石头"></a>例 2——<a href="https://www.luogu.com.cn/problem/P2678">跳石头</a></h5><p><img data-src="https://img-blog.csdnimg.cn/20210314154525848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<h6 id="分析：看题，这是啥？最短距离的最大值！这不就是二分答案的典型特征？还想啥，二分！"><a href="#分析：看题，这是啥？最短距离的最大值！这不就是二分答案的典型特征？还想啥，二分！" class="headerlink" title="分析：看题，这是啥？最短距离的最大值！这不就是二分答案的典型特征？还想啥，二分！"></a>分析：看题，这是啥？最短距离的最大值！这不就是二分答案的典型特征？还想啥，二分！</h6><h6 id="求最大？上模板-2！！-那，判断条件？"><a href="#求最大？上模板-2！！-那，判断条件？" class="headerlink" title="求最大？上模板 2！！ 那，判断条件？"></a>求最大？上模板 2！！ 那，判断条件？</h6><p>这时候就要注意了，我们二分的是最短距离，通过二分将这个最短距离（答案）最大化。那我们判断的时候肯定要<strong>保证 mid 是最短距离。</strong></p>
<p>如何保证？我们要求抽过石头剩下的石头中，两个石头间的最短距离为 mid，那就要<strong>保证剩下的任意两个间距都要大于等于 mid</strong>。要保证这个，那就只能挑间距大于等于 mid 的石头跳，中间的石头都将会被抽走。</p>
<p>最后，计数可以被抽走的石头。<strong>如果可以被抽走的石头个数小于等于需要抽的 M 个了，就说明满足条件。因为：既然抽了小于 M 个都能满足<code>剩下的石头中，两石头间的距离都大于等于mid</code>了，那抽 M 个，更能满足！</strong></p>
<p>有点晕？没关系！看了代码就懂了！</p>
<h5 id="code：-5"><a href="#code：-5" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=50010;</span><br><span class="line">int a[N],n,len,m,mina=1e9+1,b[N];</span><br><span class="line"></span><br><span class="line">int check(int mid)	//检查，是否最短距离为mid，如果两石头间距小于mid，不满足，移走 &#123;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	int i=0,now=0;	//i表示目标位置，now为当前位置。</span><br><span class="line">	while(i&lt;n+1)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		if(a[i]-a[now]&lt;mid)&#123; //两石头间距离小于mid，mid不是最短距离，不满足，移走该石头 </span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;	//符合，跳过去 </span><br><span class="line">			now=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(cnt&lt;=m) return 1;	//移走的石头个数小于 M，就能保证了任意两剩下的石头间距大于等于最短距离mid，那移走M个，更能保证 </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;len&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		if(a[i]&lt;mina) mina=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[0]=0,a[n+1]=len; //首尾都有石头</span><br><span class="line">	</span><br><span class="line">	if(n==0)&#123; //特判掉起点和终点之间没有石头的情况，可以想一下为什么。评论区中有答案。感谢 luojias 同学的hack数据！</span><br><span class="line">		cout&lt;&lt;len; return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//二分答案：检查每一个答案（最短距离mid）是否符合要求 </span><br><span class="line">	long long l=1,r=1e10;</span><br><span class="line">	while(l&lt;r) //模板2</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=l+r+1&gt;&gt;1;</span><br><span class="line">		if(check(mid)) l=mid; //要的是距离的最大，所以尽可能地往右走 </span><br><span class="line">		else r=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还没懂？没关系，我们再看一题！</p>
<h5 id="例-3——丢瓶盖"><a href="#例-3——丢瓶盖" class="headerlink" title="例 3——丢瓶盖"></a>例 3——<a href="https://nanti.jisuanke.com/t/T1878">丢瓶盖</a></h5><p><img data-src="https://img-blog.csdnimg.cn/20210314162609239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>分析：距离最近的 2 个瓶盖距离最大？ 最短距离的最大值！ 二分！！</strong></p>
<p><strong>看——求最大值，模板二！</strong></p>
<p><strong>判断条件 check</strong>：与上题不同的是，这题是保证<code>拿走的</code>那些瓶盖之间的最短距离最大（上题是保证<code>剩下的</code>石头最短距离最大，这两个容易混淆。~是我没错了…~ ），那么，遍历的时候，只要满足<code>这次和上次拿的那个瓶盖间距大于等于mid</code>，就可以拿了。这样就保证了我们找的<code>最短距离mid</code>是最短的间距。</p>
<p>最后如果拿出的总瓶盖数大于等于目标值，就说明满足判断。因为：既然拿了超过目标值就能满足<code>拿走的瓶盖间距大于等于mid</code>，那拿目标值 (B) 个，肯定更能满足！</p>
<h5 id="code：-6"><a href="#code：-6" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int a[N],n,m,maxa;</span><br><span class="line"></span><br><span class="line">//注意：这是拿出来的那些里，mid为最短距离，和跳石头不同的是，跳石头是在留下的里面，mid为最短距离 </span><br><span class="line">int check(int mid) &#123;</span><br><span class="line">	//now为最后一次拿的瓶盖位置，i为当前遍历的位置</span><br><span class="line">	int i=1,now=1,cnt=0; 注意：第一个瓶盖必选，才能保证剩下的距离最大，从而挑出的瓶盖间最短距离最大化 </span><br><span class="line">	while(i&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		i++;</span><br><span class="line">		if(a[i]-a[now]&gt;=mid)&#123; //保证拿走的瓶盖间距大于等于mid，才拿这个瓶盖，否则不能保证mid为最短距离</span><br><span class="line">			now=i,cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(cnt+1&gt;=m) return 1;	//如果拿出的总个数大于等于m，都能保证拿走的瓶盖间距大于等于mid，那拿出来m个，肯定也能满足！！</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		if(a[i]&gt;maxa) maxa=a[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	sort(a+1,a+n+1);</span><br><span class="line">	</span><br><span class="line">	int l=0,r=maxa;</span><br><span class="line">	while(l&lt;r) //模板2</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=l+r+1&gt;&gt;1;</span><br><span class="line">		if(check(mid)) l=mid;</span><br><span class="line">		else r=mid-1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做了上面两题，我们差不多又可以总结出规律了，心里是不是有点小激动？</p>
<h4 id="最大值最小，最小值最大-类-问题解题方向："><a href="#最大值最小，最小值最大-类-问题解题方向：" class="headerlink" title="最大值最小，最小值最大 类 问题解题方向："></a><code>最大值最小，最小值最大 类</code> 问题解题方向：</h4><h4 id="最短距离最大化问题：保证任意区间距离要比最短距离-mid-大或相等（这样，mid-才是最短距离）即：区间的距离-gt-mid"><a href="#最短距离最大化问题：保证任意区间距离要比最短距离-mid-大或相等（这样，mid-才是最短距离）即：区间的距离-gt-mid" class="headerlink" title="最短距离最大化问题：保证任意区间距离要比最短距离 mid 大或相等（这样，mid 才是最短距离）即：区间的距离 &gt;=mid"></a>最短距离最大化问题：保证任意区间距离要比最短距离 mid 大或相等（这样，mid 才是最短距离）即：区间的距离 &gt;=mid</h4><h4 id="最长距离最小化问题：保证任意区间距离要比最大距离-mid-小或相等（这样，mid-才是最大距离）即：区间的距离-lt-mid"><a href="#最长距离最小化问题：保证任意区间距离要比最大距离-mid-小或相等（这样，mid-才是最大距离）即：区间的距离-lt-mid" class="headerlink" title="最长距离最小化问题：保证任意区间距离要比最大距离 mid 小或相等（这样，mid 才是最大距离）即：区间的距离 &lt;=mid"></a>最长距离最小化问题：保证任意区间距离要比最大距离 mid 小或相等（这样，mid 才是最大距离）即：区间的距离 &lt;=mid</h4><p><strong>哈哈哈，是不是太有趣啦？</strong></p>
<p>快快，趁热打铁，再来！！</p>
<h5 id="例-4——数列分段-Section-II"><a href="#例-4——数列分段-Section-II" class="headerlink" title="例 4——数列分段 Section II"></a>例 4——<a href="https://www.luogu.com.cn/problem/P1182">数列分段 Section II</a></h5><p><img data-src="https://img-blog.csdnimg.cn/20210311110909144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><img data-src="https://img-blog.csdnimg.cn/2021031111085529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX2RpbXBsZQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>分析：没错，这次是最大值最小！</strong><br>求最小值？ 哎对，模板 1！<br><strong>判断条件</strong>：<code>要保证：每一段的和都小于等于最大值。</code>也就是说，只要这一段的和加上下一个值大于最大值了，那下一个值加不得，得分段！接着段数 ++；<br><strong>最后</strong>，统计出的总段数 (cnt+1) 小于等于目标值了，那就算满足；因为，既然分了小于目标值个段都能<code>保证每段的和小于等于最大值</code>，那么分目标值个段肯定还能保证！</p>
<p>还有一个<strong>小细节</strong>：l，和 r 的初始化。<br>所有段中的最大和肯定大于等于数列中的最大值（因为最大值最少单成一段，那所有段中的最大的和肯定要大于等于最大值），所以 l 要初始化为 maxa。<br>同样，所有段中和的最大值，最大不过数列中的所有值的和。</p>
<h5 id="code：-7"><a href="#code：-7" class="headerlink" title="code："></a>code：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll a[N],n,m,summ,mina=1e9+1,maxa;</span><br><span class="line"></span><br><span class="line">int check(int mid) &#123;</span><br><span class="line">	ll cnt=0,sum=0;</span><br><span class="line">	for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=a[i];</span><br><span class="line">		if(sum+a[i+1]&gt;mid) cnt++,sum=0; //不能满足 &quot;区间间距小于最大距离&quot;，那就分段 </span><br><span class="line">	&#125;</span><br><span class="line">	if(cnt+1&lt;=m) return 1;	//总的段数小于等于需要的段数，这样都能满足mid为每段的最大值，那么多分几段，肯定还能满足 </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i],summ+=a[i];	</span><br><span class="line">		if(a[i]&lt;mina) mina=a[i];</span><br><span class="line">		if(a[i]&gt;maxa) maxa=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int l=maxa,r=summ;	//l要设为maxa，所有段的最大值肯定大于等于maxa </span><br><span class="line">	while(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid=l+r&gt;&gt;1;</span><br><span class="line">		if(check(mid)) r=mid; //求的是最大值的最小，故尽量往左来 </span><br><span class="line">		else l=mid+1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好啦，至此，二分答案你就差不多掌握了。方法说的都是实打实的；<br>最后，在给出几道练习题吧：<br><strong>1、<a href="https://www.luogu.com.cn/problem/P1824">进击的奶牛</a><br>2、<a href="https://www.luogu.com.cn/problem/P3853">路标设置</a><br>3、<a href="https://www.acwing.com/problem/content/104/">最佳牛围栏</a><br>4、<a href="https://www.luogu.com.cn/problem/P3743">kotori 的设备</a></strong></p>
<p>本文的课后练习题的答案在<a href="https://blog.csdn.net/Mr_dimple/article/details/114938038"><strong>这个博客</strong></a>里。</p>
<p><strong>相信看到这的你一定收获了不少吧。</strong></p>
<p>讲的有点多，看不完的话可以先收藏。如果有没讲到的，后续会再更新。</p>
<p>有哪里不明白的话欢迎留言或评论，相互讨论，共同进步！</p>
<p><strong>哪里写的有问题的话，还请大佬们不吝赐教。</strong></p>
<p>参考博客：<a href="https://www.it610.com/article/1292865348768440320.htm">https://www.it610.com/article/1292865348768440320.htm</a></p>
]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Sat Jan 06 2024 00:00:00 GMT+0800 (中国标准时间)</title>
    <url>/posts/8f794510/</url>
    <content><![CDATA[<blockquote>
<p>[!tip]- 题型分布</p>
<ul>
<li>选择($15\times 3$)</li>
<li>简答题($5\times 2$)</li>
<li>计算题($45$)<ul>
<li>电场强度的计算 </li>
<li>电势的计算 </li>
<li>磁场的计算</li>
<li>安培力的计算 </li>
<li>法拉第电磁感应定律的计算</li>
<li>动生电动势的计算 </li>
<li>微观量的计算(热学)</li>
<li>循环效率的计算 </li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="7-静电场"><a href="#7-静电场" class="headerlink" title="7 静电场"></a>7 静电场</h2><h3 id="电场强度的计算"><a href="#电场强度的计算" class="headerlink" title="电场强度的计算"></a><span style="color:#92d050">电场强度的计算</span></h3><p>库仑力：<script type="math/tex">\Huge{\overrightarrow{F_{21}} =\frac{1}{4\pi ε_{0}}\cdot \frac{q_{1}q_{2}}{r_{21}^3}\cdot \overrightarrow {r_{21}}}</script><br><img data-src="../../../images/Z-attachment/Pasted%20image%2020240106163810.png" alt=""></p>
<p>电场强度：$\Huge{\overrightarrow{E}=\frac{\overrightarrow{F}}{q<em>{0}}}$ $(N/C)$<br>积分法：$\Huge{\overrightarrow{E}=\int  \, d\overrightarrow{E}=\frac{1}{4\pi \epsilon</em>{0} }\int \frac{dq}{r^{3}} \overrightarrow{r}}$</p>
<p>带电体电荷分为线分布、面分布和体分布。<br>线密度：$\lambda=\lim<em>{ \Delta l \to 0} \frac{\Delta q}{\Delta l}=\frac{dq}{dl}$<br>面密度：$\sigma=\lim</em>{ \Delta s \to 0 } \frac{\Delta q}{\Delta s}=\frac{dq}{ds}$<br>体密度：$\rho=\lim_{ \Delta V \to 0 } \frac{\Delta q}{\Delta V}=\frac{dq}{dv}$</p>
<p>力偶矩：$\overrightarrow{M}=q\overrightarrow{l}\times \overrightarrow{E}=\overrightarrow{p_{e}}\times \overrightarrow{E}=qlE\sin \theta$      <img data-src="../../../images/Z-attachment/Pasted%20image%2020240106171430.png" alt=""></p>
<h4 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h4><p>细杆<br><img data-src="../../../images/Z-attachment/Pasted%20image%2020240106182331.png" alt=""> 细杆：无限长的均匀带电直线：$E<em>{y}=0,E</em>{x}=\frac{\lambda}{2\pi \epsilon_{0}a}$</p>
<p>圆环：<br>![[../../../images/Z-attachment/Pasted image 20240106182501.png|375]] 在圆环：$1.x=0,E=0$，$2.R\to0,E=\frac{1}{4\pi \epsilon<em>{0}}\cdot \frac{q}{x^2}$<br>原盘：<br>![[../../../images/Z-attachment/Pasted image 20240106182612.png|350]] 在圆盘：$x\to0,E=\frac{\sigma}{2\epsilon</em>{0}}$</p>
<h3 id="高斯定理-电通量的计算"><a href="#高斯定理-电通量的计算" class="headerlink" title="高斯定理(电通量的计算)"></a>高斯定理(电通量的计算)</h3><p>面元的==电通量== ：</p>
<ul>
<li>面元的电通量表示穿过该面元的电场线数目。</li>
<li>对于非闭合曲面，面积元的法线取向可在曲面的任一侧，应事先规定法线方向。<br>$d\Phi=E\cdot ds=E\cdot nds=E\cos \theta ds=Eds<em>{\perp}$<br>曲面的电通量：曲面的电通量为组成曲面的各面元电通量的代数和。<br>$\Phi</em>{e}=\int \int d\Phi_{e}=\int \int  E\cdot ds =\int \int E\cos \theta ds$<br>有规定：</li>
<li>闭合曲面，规定指向曲面外部的法线方向为正($d\Phi_{e}$)，当电场线从闭合面穿入时为负，当电场线从闭合面穿出时为正<br>闭合曲面的电通量为穿入和穿出的电场线数目的代数和，即净穿入（净穿出）的电场线数目。</li>
</ul>
<p>==高斯定理==：揭示了电场强度的通量与场源电荷间的关系：$\Huge{\oint<em>{s}E\cdot dS=\frac{1}{\epsilon</em>{0}}\sum q<em>{内}}$<br>高斯定理的验证：<br>（1） 以点电荷 q 为球心，以 r 为半径的球面为闭合曲面，其电通量 $\Phi</em>{e}=\frac{q}{\epsilon<em>{0}}$<br>（2）包含点电荷 q 的任意形状的闭合曲面，其电通量 $\Phi</em>{e}=\frac{q}{\epsilon<em>{0}}$<br>（3） 包含点电荷系统{$q</em>{i}$ }的任意形状的闭合曲面，其电通量 $\Phi<em>{e}=\frac{q}{\epsilon</em>{0}}$<br>（4）闭合曲面外的电荷对其电通量贡献为零<br>==高斯定理的理解==<br>![[../../../images/Z-attachment/Pasted image 20240106192105.png|450]]</p>
<h4 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h4><p>![[../../../images/Z-attachment/Pasted image 20240106213048.png|350]]</p>
<h3 id="电势的计算"><a href="#电势的计算" class="headerlink" title="电势的计算"></a>电势的计算</h3><p>![[../../../images/Z-attachment/Pasted image 20240106215550.png|450]]</p>
<p>==在静电场中, 电场强度沿任意闭合路径的线积分为零，或在静电场中电场强度的环流为零==<br>点电荷的电势：<br>$\Huge{U=\frac{q}{4\pi \epsilon_{0}r}, \begin{cases}  &amp; q&gt;0,U&gt;0 \ &amp; q&lt;0,U&lt;0 \end{cases} }$</p>
<p>点电荷系的电势:<br>$\Huge{U=\sum\limits<em>{i} \frac{q</em>{i}}{4\pi \epsilon<em>{0}r</em>{i}}}$</p>
<h4 id="eg-2"><a href="#eg-2" class="headerlink" title="eg"></a>eg</h4><p>圆盘与圆环：<br>![[../../../images/Z-attachment/Pasted image 20240106215311.png|375]]<br>球壳<br>![[../../../images/Z-attachment/Pasted image 20240106220003.png|350]]</p>
]]></content>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最全的各种 C++ STL 容器全解析</title>
    <url>/posts/f512cae/</url>
    <content><![CDATA[<h1 id="史上最全的-C-STL-容器大礼包"><a href="#史上最全的-C-STL-容器大礼包" class="headerlink" title="史上最全的 C++ STL 容器大礼包"></a>史上最全的 C++ STL 容器大礼包</h1><p>为什么 C++$C++$比 C$C$更受人欢迎呢？除了 C++$C++$ 的编译令人感到更舒适，C++$C++$的标准模板库（STL$STL$）也占了很重要的原因。当你还在用手手写快排、手写二叉堆，挑了半天挑不出毛病的时候，C++$C++$党一手 STL$STL$轻松 AC$AC$，想不嫉妒都难。</p>
<p>所以这篇随笔就带大家走进博大精深的 C++STL$C++STL$，系统讲解各种 STL$STL$容器及其用法、作用。在学习 STL$STL$的时候认真体会 STL$STL$语法及功能，提升自己在算法竞赛及程序设计中解题、码代码的能力。</p>
<p>话不多说，现在开始：</p>
<h2 id="浅谈-C-STL-vector-容器"><a href="#浅谈-C-STL-vector-容器" class="headerlink" title="浅谈 C++ STL vector 容器"></a>浅谈 C++ STL vector 容器</h2><p><a href="https://www.cnblogs.com/fusiwei/p/11822800.html">vector 讲解传送门</a></p>
<p>本篇随笔简单介绍一下 C++STL$C++STL$中 vector$vector$容器的使用方法和常见的使用技巧。vector$vector$容器是 C++STL$C++STL$的一种比较基本的容器。我们在学习这个容器的时候，不仅要学到这个容器具体的使用方法，更要从中体会 C++STL$C++STL$的概念。</p>
<h2 id="vector-容器的概念"><a href="#vector-容器的概念" class="headerlink" title="vector 容器的概念"></a>vector 容器的概念</h2><p>vector$vector$在英文中是矢量的意思。如果学过高中数学必修四的平面向量或者高中物理必修一的第一节课对其会有一个直观的认识。但是在 STL$STL$中，vector$vector$和物理、几何等东西没有任何关系。</p>
<p>我们知道，一个数组必须要有固定的长度，在开一个数组的时候，这个长度也就被静态地确定下来了。但是 vector$vector$却是数组的 “加强版”，对于一组数据来讲，你往 vector$vector$里存多少数据，vector$vector$的长度就有多大。也就是说，我们可以将其理解为一个 “变长数组”。</p>
<p>事实上，vector$vector$的实现方式是基于<strong>倍增思想的</strong>：假如 vector$vector$的实际长度为 n$n$，m$m$为 vector$vector$当前的最大长度，那么在加入一个元素的时候，先看一下，假如当前的 n=m$n=m$，则再动态申请一个 2m$2m$大小的内存。反之，在删除的时候，如果 n≥m2$n\ge \frac{m}{2}$，则再释放一半的内存。</p>
<h2 id="vector-容器的声明"><a href="#vector-容器的声明" class="headerlink" title="vector 容器的声明"></a>vector 容器的声明</h2><p>vector$vector$容器存放在模板库：<code>#include&lt;vector&gt;</code>里，使用前需要先开这个库。</p>
<p>vector$vector$容器的声明遵循 C++STL$C++STL$的一般声明原则：</p>
<p>容器类型 &lt;变量类型&gt; 名称</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line">vector&lt;char&gt; vec;</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; vec;</span><br><span class="line">vector&lt;node&gt; vec;</span><br><span class="line">struct node&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="vector-容器的使用方法"><a href="#vector-容器的使用方法" class="headerlink" title="vector 容器的使用方法"></a>vector 容器的使用方法</h2><p>vector$vector$容器的使用方法大致如下表所示：</p>
<table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td><code>vec.begin(),vec.end()</code></td><td>返回 vector 的首、尾<strong>迭代器</strong></td></tr><tr><td><code>vec.front(),vec.back()</code></td><td>返回 vector 的首、尾<strong>元素</strong></td></tr><tr><td><code>vec.push_back()</code></td><td>从 vector 末尾加入一个元素</td></tr><tr><td><code>vec.size()</code></td><td>返回 vector 当前的长度（大小）</td></tr><tr><td><code>vec.pop_back()</code></td><td>从 vector 末尾删除一个元素</td></tr><tr><td><code>vec.empty()</code></td><td>返回 vector 是否为空，1 为空、0 不为空</td></tr><tr><td><code>vec.clear()</code></td><td>清空 vector</td></tr></tbody></table>

<p>除了上面说过的那些之外，我们的 vector$vector$容器是支持随机访问的，即可以像数组一样用 []$[\,\,]$来取值。请记住，不是所有的 STL$STL$容器都有这个性质！在 STL$STL$的学习过程中，一定要清楚各个容器之间的异同！</p>
<h1 id="浅谈-C-STL-queue-容器"><a href="#浅谈-C-STL-queue-容器" class="headerlink" title="浅谈 C++ STL queue 容器"></a>浅谈 C++ STL queue 容器</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11822867.html">queue 讲解传送门</a></p>
<p>本篇随笔简单介绍一下 C++STL$C++STL$中 queue$queue$容器的使用方法和常见的使用技巧。queue$queue$容器是 C++STL$C++STL$的一种比较基本的容器。我们在学习这个容器的时候，不仅要学到这个容器具体的使用方法，更要从中体会 C++STL$C++STL$的概念。</p>
<h2 id="queue-容器的概念"><a href="#queue-容器的概念" class="headerlink" title="queue 容器的概念"></a>queue 容器的概念</h2><p>queue$queue$在英文中是队列的意思。队列是一种基本的数据结构。而 C++STL$C++STL$中的队列就是把这种数据结构模板化了。我们可以在脑中想象买票时人们站的排队队列。我们发现，在一个队列中，只可以从队首离开，从队尾进来（没有插队，想啥呢）。即一个先进先出的数据结构。</p>
<p>上图理解：</p>
<p><img data-src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194202009-539251419.png" alt=""></p>
<h2 id="queue-容器的声明"><a href="#queue-容器的声明" class="headerlink" title="queue 容器的声明"></a>queue 容器的声明</h2><p>queue$queue$容器存放在模板库：<code>#include&lt;queue&gt;</code>里，使用前需要先开这个库。</p>
<p>queue$queue$容器的声明遵循 C++STL$C++STL$的一般声明原则：</p>
<p>容器类型 &lt;变量类型&gt; 名称</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">queue&lt;char&gt; q;</span><br><span class="line"></span><br><span class="line">queue&lt;pair&lt;int,int&gt; &gt; q;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line">struct node&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="queue-容器的使用方法"><a href="#queue-容器的使用方法" class="headerlink" title="queue 容器的使用方法"></a>queue 容器的使用方法</h2><p>queue$queue$容器的使用方法大致如下表所示：</p>
<table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td><code>q.front(),q.back()</code></td><td>返回 queue 的首、尾<strong>元素</strong></td></tr><tr><td><code>q.push()</code></td><td>从 queue 末尾加入一个元素</td></tr><tr><td><code>q.size()</code></td><td>返回 queue 当前的长度（大小）</td></tr><tr><td><code>q.pop()</code></td><td>从 queue 末尾删除一个元素</td></tr><tr><td><code>q.empty()</code></td><td>返回 queue 是否为空，1 为空、0 不为空</td></tr></tbody></table>

<p>注意，虽然 vector$vector$和 queue$queue$是两种最基本的 STL$STL$容器，但请记住它们两个不是完全一样的。就从使用方法来讲：</p>
<p>queue$queue$不支持随机访问，即不能像数组一样地任意取值。并且，queue$queue$并不支持全部的 vector$vector$的内置函数。比如 queue$queue$不可以用 clear()$clear()$函数清空，清空 queue$queue$必须一个一个弹出。同样，queue$queue$也并不支持遍历，无论是数组型遍历还是迭代器型遍历统统不支持，所以没有 begin(),end();$begin(),end();$函数，使用的时候一定要清楚异同！</p>
<h1 id="浅谈-C-STL-stack-容器"><a href="#浅谈-C-STL-stack-容器" class="headerlink" title="浅谈 C++ STL stack 容器"></a>浅谈 C++ STL stack 容器</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11822960.html">stack 讲解传送门</a></p>
<p>本篇随笔简单介绍一下 C++STL$C++STL$中 stack$stack$容器的使用方法和常见的使用技巧。</p>
<h2 id="stack-容器的概念"><a href="#stack-容器的概念" class="headerlink" title="stack 容器的概念"></a>stack 容器的概念</h2><p>stack$stack$在英文中是栈的意思。栈是一种基本的数据结构。而 C++STL$C++STL$中的栈就是把这种数据结构模板化了。<br>栈的示意图如下：这是一个先进后出的数据结构。这<strong>非常重要！！</strong>  </p>
<p><img data-src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194156752-1724424437.png" alt=""></p>
<p>事实上，stack$stack$容器并不是一种标准的数据结构，它其实是一个<strong>容器适配器</strong>，里面还可以存其他的 STL$STL$容器。但那种使用方法过于高深而且不是很常用，所以在此不与介绍。请有兴趣的读者自行查询资料。</p>
<h2 id="stack-容器的声明"><a href="#stack-容器的声明" class="headerlink" title="stack 容器的声明"></a>stack 容器的声明</h2><p>stack$stack$容器存放在模板库：<code>#include&lt;stack&gt;</code>里，使用前需要先开这个库。<br>stack$stack$容器的声明遵循 C++STL$C++STL$的一般声明原则：<br>容器类型 &lt;变量类型&gt; 名称<br>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stack&gt;</span><br><span class="line">stack&lt;int&gt; st;</span><br><span class="line">stack&lt;char&gt; st;</span><br><span class="line">stack&lt;pair&lt;int,int&gt; &gt; st;</span><br><span class="line">stack&lt;node&gt; st;</span><br><span class="line">struct node&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="stack-容器的使用方法"><a href="#stack-容器的使用方法" class="headerlink" title="stack 容器的使用方法"></a>stack 容器的使用方法</h2><p>stack$stack$容器的使用方法大致如下表所示：</p>
<table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td><code>st.top()</code></td><td>返回 stack 的栈顶<strong>元素</strong></td></tr><tr><td><code>st.push()</code></td><td>从 stack 栈顶加入一个元素</td></tr><tr><td><code>st.size()</code></td><td>返回 stack 当前的长度（大小）</td></tr><tr><td><code>st.pop()</code></td><td>从 stack 栈顶弹出一个元素</td></tr><tr><td><code>st.empty()</code></td><td>返回 stack 是否为空，1 为空、0 不为空</td></tr></tbody></table>

<h1 id="浅谈-C-STL-string-容器"><a href="#浅谈-C-STL-string-容器" class="headerlink" title="浅谈 C++ STL string 容器"></a>浅谈 C++ STL string 容器</h1><p>本篇随笔简单讲解一下 C++STL$C++STL$中 string$string$容器的使用方法及技巧。</p>
<h2 id="string-容器的概念"><a href="#string-容器的概念" class="headerlink" title="string 容器的概念"></a>string 容器的概念</h2><p>其实 string$string$并不是 STL$STL$的一种容器，但是由于它的使用方法等等和 STL$STL$容器很像，所以就把它当作 STL$STL$容器一样介绍。</p>
<p>其实 string$string$容器就是个字符串，这通过它的英文译名就能看得出来。但是对于字符串以及字符串的相关操作，可能读者还是对普通的 C/C++$C/C++$的<code>#include&lt;cstring&gt;</code>，<code>#include&lt;string.h&gt;</code>库更熟悉一些。我丝毫不否认这些传统字符操作的经典性和实用性，但是由于它们函数定义的局限，有些时候对于一些特殊的读入、输出、遍历等要求，它的操作并不如 string$string$容器好用。</p>
<p>比如，要求读入一群中间可能带空格的字符串，如果用传统方式进行读入，可能就会很麻烦，但是如果使用 string$string$的话，一个读入函数就可以完全搞定。</p>
<h2 id="string-容器的使用方法及与传统字符读入的对比"><a href="#string-容器的使用方法及与传统字符读入的对比" class="headerlink" title="string 容器的使用方法及与传统字符读入的对比"></a>string 容器的使用方法及与传统字符读入的对比</h2><p>一张图解决问题。</p>
<p><img data-src="https://img-blog.csdn.net/20160825125138703" alt=""></p>
<h1 id="详解-C-STL-priority-queue-容器"><a href="#详解-C-STL-priority-queue-容器" class="headerlink" title="详解 C++ STL priority_queue 容器"></a>详解 C++ STL priority_queue 容器</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11823053.html">优先队列讲解传送门</a></p>
<p>本篇随笔简单介绍一下 C++STL$C++STL$中 priorityqueue$priority_queue$</p>
<p>容器的使用方法和常见的使用技巧。</p>
<h2 id="priority-queue-容器的概念"><a href="#priority-queue-容器的概念" class="headerlink" title="priority_queue 容器的概念"></a>priority_queue 容器的概念</h2><p>priorityqueue$priority_queue$在英文中是优先队列的意思。</p>
<p>队列是一种基本的数据结构。其实现的基本示意图如下所示：</p>
<p><img data-src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194202009-539251419.png" alt=""></p>
<p>而 C++STL$C++STL$中的优先队列就是在这个队列的基础上，把其中的元素加以排序。其内部实现是一个二叉堆。所以优先队列其实就是把堆模板化，将所有入队的元素排成具有单调性的一队，方便我们调用。</p>
<h2 id="priority-queue-容器的声明"><a href="#priority-queue-容器的声明" class="headerlink" title="priority_queue 容器的声明"></a>priority_queue 容器的声明</h2><p>priorityqueue$priority_queue$容器存放在模板库：<code>#include&lt;queue&gt;</code>里，使用前需要先开这个库。</p>
<p>这里需要注意的是，优先队列的声明与一般 STL$STL$模板的声明方式并不一样。事实上，我认为其是 C++STL$C++STL$中最难声明的一个容器。</p>
<h4 id="大根堆声明方式："><a href="#大根堆声明方式：" class="headerlink" title="大根堆声明方式："></a>大根堆声明方式：</h4><p>大根堆就是把大的元素放在堆顶的堆。优先队列默认实现的就是大根堆，所以大根堆的声明不需要任何花花肠子，直接按 C++STL$C++STL$的声明规则声明即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">priority_queue&lt;int&gt; q;</span><br><span class="line">priority_queue&lt;string&gt; q;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt; q;</span><br></pre></td></tr></table></figure>
<p>C++$C++$中的 int,string$int,string$等类型可以直接比较大小，所以不用我们多操心，优先队列自然会帮我们实现。但是如果是我们自己定义的结构体，就需要进行重载运算符了。关于重载运算符的讲解，请参考这篇博客：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11314650.html">重载运算符语法讲解</a></p>
<h4 id="小根堆声明方式"><a href="#小根堆声明方式" class="headerlink" title="小根堆声明方式"></a>小根堆声明方式</h4><p>大根堆是把大的元素放堆顶，小根堆就是把小的元素放到堆顶。</p>
<p>实现小根堆有两种方式：</p>
<p>第一种是比较巧妙的，因为优先队列默认实现的是大根堆，所以我们可以把元素取反放进去，因为负数的绝对值越小越大，那么绝对值较小的元素就会被放在前面，我们在取出的时候再取个反，就瞒天过海地用大根堆实现了小根堆。</p>
<p>第二种：</p>
<p>小根堆有自己的声明方式，我们记住即可（我也说不明白道理）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br></pre></td></tr></table></figure>
<p>注意，当我们声明的时候碰到两个 “&lt;” 或者 “&gt;” 放在一起的时候，一定要记得在中间加一个空格。这样编译器才不会把两个连在一起的符号判断成位运算的左移 / 右移。</p>
<h2 id="priority-queue-容器的使用方法"><a href="#priority-queue-容器的使用方法" class="headerlink" title="priority_queue 容器的使用方法"></a>priority_queue 容器的使用方法</h2><p>priorityqueue$priority_queue$容器的使用方法大致如下表所示：</p>
<table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td><code>q.top()</code></td><td>返回 priority_queue 的首<strong>元素</strong></td></tr><tr><td><code>q.push()</code></td><td>向 priority_queue 中加入一个元素</td></tr><tr><td><code>q.size()</code></td><td>返回 priority_queue 当前的长度（大小）</td></tr><tr><td><code>q.pop()</code></td><td>从 priority_queue 末尾删除一个元素</td></tr><tr><td><code>q.empty()</code></td><td>返回 priority_queue 是否为空，1 为空、0 不为空</td></tr></tbody></table>

<p>注意：priority_queue 取出队首元素是使用 top$top$，而不是 front$front$，这点一定要注意！！</p>
<h1 id="浅谈-C-STL-deque-容器"><a href="#浅谈-C-STL-deque-容器" class="headerlink" title="浅谈 C++ STL deque 容器"></a>浅谈 C++ STL deque 容器</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11821000.html">deque 讲解传送门</a></p>
<p>本篇随笔简单介绍一下 C++STL$C++STL$中 deque$deque$容器的使用方法及常见使用技巧。</p>
<h2 id="deque-容器的概念"><a href="#deque-容器的概念" class="headerlink" title="deque 容器的概念"></a>deque 容器的概念</h2><p>deque$deque$的意义是：双端队列。队列是我们常用而且必须需要掌握的数据结构。C++STL$C++STL$中的确有模拟队列的模板：<code>#include&lt;queue&gt;</code>中的 queue$queue$和 priority_queue$priority_queue$。队列的性质是先进先出，即从队尾入队，从队首出队。而 deque$deque$的特点则是双端进出，即处于双端队列中的元素既可以从队首进 / 出队，也可以从队尾进 / 出队。</p>
<p>即：deque$deque$是一个支持在两端高效插入、删除元素的线性容器。</p>
<p>deque$deque$模板存储在 C++STL$C++STL$的<code>#include&lt;deque&gt;</code>中。</p>
<h2 id="deque-容器的使用方法"><a href="#deque-容器的使用方法" class="headerlink" title="deque 容器的使用方法"></a>deque 容器的使用方法</h2><p>因为 deque$deque$容器真的和 queue$queue$容器大体相同，其使用方式也大体一致。下面把 deque$deque$容器的使用方式以列表的方式放在下面：</p>
<table><thead><tr><th>用法</th><th>作用</th></tr></thead><tbody><tr><td><code>q.begin(),q.end()</code></td><td>返回 deque 的首、尾<strong>迭代器</strong></td></tr><tr><td><code>q.front(),q.back()</code></td><td>返回 deque 的首、尾<strong>元素</strong></td></tr><tr><td><code>q.push_back()</code></td><td>从队尾入队一个元素</td></tr><tr><td><code>q.push_front()</code></td><td>从队头入队一个元素</td></tr><tr><td><code>q.pop_back()</code></td><td>从队尾出队一个元素</td></tr><tr><td><code>q.pop_front()</code></td><td>从队头出队一个元素</td></tr><tr><td><code>q.clear()</code></td><td>清空队列</td></tr></tbody></table>

<p>除了这些用法之外，deque$deque$比 queue$queue$更优秀的一个性质是它支持随机访问，即可以像数组下标一样取出其中的一个元素。</p>
<p>即：<code>q[i]</code>。</p>
<h2 id="deque-的一些用途"><a href="#deque-的一些用途" class="headerlink" title="deque 的一些用途"></a>deque 的一些用途</h2><p>由于本蒟蒻水平有限，暂时想不出 deque 应用的一些实例。但有一点是肯定的：deque$deque$容器可以被应用到 SPFA$SPFA$算法的 SLF$SLF$优化。其具体应用方式可见这篇博客：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11289019.html">关于 SPFA 算法的优化方式</a></p>
<h1 id="详解-C-STL-set-容器"><a href="#详解-C-STL-set-容器" class="headerlink" title="详解 C++ STL set 容器"></a>详解 C++ STL set 容器</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11820365.html">set 讲解传送门</a></p>
<p>本篇随笔简单介绍一下 C++STL$C++STL$中 set$set$容器的使用方法及常见使用技巧。</p>
<h2 id="set-容器的概念和性质"><a href="#set-容器的概念和性质" class="headerlink" title="set 容器的概念和性质"></a>set 容器的概念和性质</h2><p>set$set$在英文中的意义是：集合。set$set$容器也的确 “人如其名”，实现了这个集合的功用。</p>
<p>高中数学必修一集合那章（高一以下的小伙伴不用慌，不讲数学只讲概念），关于集合的性质，给出了三个概念：<strong>无序性、互异性、确定性</strong>。</p>
<p>那么，set$set$容器的功用就是维护一个集合，其中的元素满足互异性。</p>
<p>我们可以将其理解为一个数组。这个数组的元素是两两不同的。</p>
<p>这个<strong>两两不同</strong>是指，如果这个 set$set$容器中已经包含了一个元素 i$i$，那么无论我们后续再往里假如多少个 i$i$，这个 set$set$中还是只有一个元素 i$i$，而不会出现一堆 i$i$的情况。这就为我们提供了很多方便。</p>
<p>但是，需要额外说明的是，刚刚说集合是有无序性的，但是 set$set$中的元素是默认排好序<strong>（按升序排列）</strong>的。（稍微说一句，set$set$容器自动有序和快速添加、删除的性质是由其内部实现：红黑树（平衡树的一种）。这个东西过于高深~我不会~，所以不予过多介绍，有兴趣的小伙伴可以自行浏览相关内容。）</p>
<h2 id="set-容器的声明"><a href="#set-容器的声明" class="headerlink" title="set 容器的声明"></a>set 容器的声明</h2><p>set$set$容器的声明和大部分 C++STL$C++STL$容器一样，都是：容器名 &lt;变量类型&gt; 名称的结构。前提需要开 #include 库。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;set&gt;</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">set&lt;char&gt; s;</span><br><span class="line">set&lt;pair&lt;int,int&gt; &gt; s;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line">struct node&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="set-容器的使用"><a href="#set-容器的使用" class="headerlink" title="set 容器的使用"></a>set 容器的使用</h2><p>其实，C++STL$C++STL$容器的使用方式都是差不多的。我们完全可以举一反三地去类比。与 bitset$bitset$重定义了许多~奇形怪状~新的函数之外，其他都是大致相同的。所以笔者在此不再做幼稚的介绍，大家都是竞赛狗，应该都能自己看明白。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.empty();</span><br></pre></td></tr></table></figure>
<p>empty()$empty()$函数返回当前集合是否为空，是返回 1，否则返回 0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.size();</span><br></pre></td></tr></table></figure>
<p>size()$size()$函数返回当前集合的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.clear();</span><br></pre></td></tr></table></figure>
<p>clear()$clear()$函数清空当前集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.begin(),s.end();</span><br></pre></td></tr></table></figure>
<p>begin()$begin()$函数和 end()$end()$函数返回集合的<strong>首尾迭代器</strong>。注意是迭代器。我们可以把迭代器理解为数组的下标。但其实迭代器是一种指针。这里需要注意的是，由于计算机区间 <strong>“前闭后开”</strong> 的结构，begin()$begin()$函数返回的指针指向的的确是集合的第一个元素。但 end()$end()$返回的指针却指向了集合最后一个元素后面一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.insert(k);</span><br></pre></td></tr></table></figure>
<p>insert(k)$insert(k)$函数表示向集合中加入元素 k$k$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.erase(k);</span><br></pre></td></tr></table></figure>
<p>erase(k)$erase(k)$函数表示删除集合中元素 k$k$。这也反映了 set$set$容器的强大之处，指哪打哪，说删谁就删谁，完全省略了遍历、查找、复制、还原等繁琐操作。更不用像链表那种数据结构那么毒瘤。直接一个函数，用 O(logn)$O(logn)$的复杂度解决问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.find(k);</span><br></pre></td></tr></table></figure>
<p>find(k)$find(k)$函数返回集合中指向元素 k$k$的迭代器。如果不存在这个元素，就返回 s.end()$s.end()$，这个性质可以用来判断集合中有没有这个元素。</p>
<h2 id="其他好用的函数"><a href="#其他好用的函数" class="headerlink" title="其他好用的函数"></a>其他好用的函数</h2><p>下面介绍一些不是很常用，但是很好用的 set$set$容器的内置函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.lower_bound(),s.upper_bound();</span><br></pre></td></tr></table></figure>
<p>熟悉 algorithm$algorithm$库和二分、离散化的小伙伴会对这两个函数比较熟悉。其实这两个函数比较常用。但是对于 set$set$集合来讲就不是很常用。其中 lower_bound$lower_bound$返回集合中第一个大于等于关键字的元素。upper_bound$upper_bound$返回集合中第一个严格大于关键字的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.equal_range();</span><br></pre></td></tr></table></figure>
<p>这个东西是真的不常用… ~可能是我太菜了~。</p>
<p>这个东西返回一个 pair$pair$（内置二元组），分别表示第一个大于等于关键字的元素，第一个严格大于关键字的元素，也就是把前面的两个函数和在一起。如果有一个元素找不到的话，就会返回 s.end()$s.end()$。</p>
<h1 id="详解-C-STL-multiset-容器"><a href="#详解-C-STL-multiset-容器" class="headerlink" title="详解 C++ STL multiset 容器"></a>详解 C++ STL multiset 容器</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11820455.html">multiset 讲解传送门</a></p>
<p>本篇随笔简单介绍一下 C++STL$C++STL$中 multiset$multiset$容器的使用方法及常见使用技巧。</p>
<h2 id="multiset-容器的概念和性质"><a href="#multiset-容器的概念和性质" class="headerlink" title="multiset 容器的概念和性质"></a>multiset 容器的概念和性质</h2><p>set$set$在英文中的意义是：集合。而 multi−$multi-$前缀则表示：多重的。所以 multiset$multiset$容器就叫做：有序多重集合。</p>
<p>multiset$multiset$的很多性质和使用方式和 set$set$容器差不了多少。而 multiset$multiset$容器在概念上与 set$set$容器不同的地方就是：set$set$的元素互不相同，而 multiset$multiset$的元素可以允许相同。</p>
<p>所以，关于一些 multiset$multiset$容器和 set$set$容器的相同点，本篇博客就不加以赘述了。需要学习的小伙伴推荐进入本蒟蒻的这篇博客：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11820365.html">C++STL set 容器详解</a></p>
<h2 id="与-set-容器不太一样的地方："><a href="#与-set-容器不太一样的地方：" class="headerlink" title="与 set 容器不太一样的地方："></a>与 set 容器不太一样的地方：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.erase(k);</span><br></pre></td></tr></table></figure>
<p>erase(k)$erase(k)$函数在 set$set$容器中表示删除集合中元素 k$k$。但在 multiset$multiset$容器中表示删除所有等于 k$k$的元素。</p>
<p>时间复杂度变成了 O(tot+logn)$O(tot+logn)$，其中 tot$tot$表示要删除的元素的个数。</p>
<p>那么，会存在一种情况，我只想删除这些元素中的一个元素，怎么办呢？</p>
<p>可以妙用一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((it=s.find(a))!=s.end())</span><br><span class="line">	s.erase(it);</span><br></pre></td></tr></table></figure>
<p>if$if$中的条件语句表示定义了一个指向一个 a$a$元素迭代器，如果这个迭代器不等于 s.end()$s.end()$，就说明这个元素的确存在，就可以直接删除这个迭代器指向的元素了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.count(k);</span><br></pre></td></tr></table></figure>
<p>count(k)$count(k)$函数返回集合中元素 k$k$的个数。set$set$容器中并不存在这种操作。这是 multiset$multiset$独有的。</p>
<h1 id="C-STL-bitset-容器详解"><a href="#C-STL-bitset-容器详解" class="headerlink" title="C++ STL bitset 容器详解"></a>C++ STL bitset 容器详解</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11720118.html">bitset 讲解传送门</a></p>
<p>本篇随笔讲解 C++STL$C++STL$中 bitset$bitset$容器的用法及常见使用技巧。</p>
<h2 id="bitset-bitset-容器概论"><a href="#bitset-bitset-容器概论" class="headerlink" title="bitset$bitset$容器概论"></a>bitset$bitset$容器概论</h2><p>bitset$bitset$容器其实就是个 01$01$串。可以被看作是一个 bool$bool$数组。它比 bool$bool$数组更优秀的优点是：<strong>节约空间，节约时间，支持基本的位运算。</strong>在 bitset$bitset$容器中，8$8$位占一个字节，相比于 bool$bool$数组 4$4$位一个字节的空间利用率要高很多。同时，n$n$位的 bitset$bitset$在执行一次位运算的复杂度可以被看作是 n/32$n/32$，这都是 bool$bool$数组所没有的优秀性质。</p>
<p>bitset$bitset$容器包含在 C++$C++$自带的 bitset$bitset$库中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bitset&gt;</span><br></pre></td></tr></table></figure>
<h2 id="bitset-bitset-容器的声明"><a href="#bitset-bitset-容器的声明" class="headerlink" title="bitset$bitset$容器的声明"></a>bitset$bitset$容器的声明</h2><p>因为 bitset$bitset$容器就是装 01$01$串的，所以不用在 &lt; &gt; 中装数据类型，这和一般的 STL$STL$容器不太一样。&lt; &gt; 中装 01$01$串的<strong>位数</strong>。</p>
<p>如：（声明一个 105$10^5$位的 bitset$bitset$）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitset&lt;100000&gt; s;</span><br></pre></td></tr></table></figure>
<h2 id="对-bitset-bitset-容器的一些操作"><a href="#对-bitset-bitset-容器的一些操作" class="headerlink" title="对 bitset$bitset$容器的一些操作"></a>对 bitset$bitset$容器的一些操作</h2><h4 id="1、常用的操作函数"><a href="#1、常用的操作函数" class="headerlink" title="1、常用的操作函数"></a>1、常用的操作函数</h4><p>和其他的 STL$STL$容器一样，对 bitset$bitset$的很多操作也是由自带函数来实现的。下面，我们来介绍一下 bitset$bitset$的一些常用函数及其使用方法。</p>
<ul>
<li>count()$count()$函数</li>
</ul>
<p>count$count$，数数的意思。它的作用是数出 1$1$的个数。即 s.count()$s.count()$返回 s$s$中有多少个 1$1$.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.count();</span><br></pre></td></tr></table></figure>
<ul>
<li>any()/none()$any()/none()$函数</li>
</ul>
<p>any$any$，任何的意思。none$none$，啥也没有的意思。这两个函数是在检查 bitset$bitset$容器中全 0$0$的情况。</p>
<p>如果，bitset$bitset$中全都为 0$0$，那么 s.any()$s.any()$返回 false$false$，s.none()$s.none()$返回 true$true$。</p>
<p>反之，假如 bitset$bitset$中至少有一个 1$1$，即哪怕有一个 1$1$，那么 s.any()$s.any()$返回 true$true$，s.none()$s.none()$返回 false$false$.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.any();</span><br><span class="line">s.none();</span><br></pre></td></tr></table></figure>
<ul>
<li>set()$set()$函数</li>
</ul>
<p>set()$set()$函数的作用是把 bitset$bitset$全部置为 1$1$.</p>
<p>特别地，set()$set()$函数里面可以传参数。set(u,v)$set(u,v)$的意思是把 bitset$bitset$中的第 u$u$位变成 v,v∈0/1$v,v\in 0/1$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.set();</span><br><span class="line">s.set(u,v);</span><br></pre></td></tr></table></figure>
<ul>
<li>reset()$reset()$函数</li>
</ul>
<p>与 set()$set()$函数相对地，reset()$reset()$函数将 bitset$bitset$的所有位置为 0$0$。而 reset()$reset()$函数只传一个参数，表示把这一位改成 0$0$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.reset();</span><br><span class="line">s.reset(k);</span><br></pre></td></tr></table></figure>
<ul>
<li>flip()$flip()$函数</li>
</ul>
<p>flip()$flip()$函数与前两个函数不同，它的作用是将整个 bitset$bitset$容器按位取反。同上，其传进的参数表示把其中一位取反。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.flip();</span><br><span class="line">s.flip(k);</span><br></pre></td></tr></table></figure>
<h4 id="2、位运算操作在-bitset-bitset-中的实现"><a href="#2、位运算操作在-bitset-bitset-中的实现" class="headerlink" title="2、位运算操作在 bitset$bitset$中的实现"></a>2、位运算操作在 bitset$bitset$中的实现</h4><p>bitset$bitset$的作用就是帮助我们方便地实现位运算的相关操作。它当然支持位运算的一些操作内容。我们在编写程序的时候对数进行的二进制运算均可以用在 bitset$bitset$函数上。</p>
<p>比如：</p>
<p>~：按位取反</p>
<p>&amp;：按位与</p>
<p>|：按位或</p>
<p>^：按位异或</p>
<p>&lt;&lt;&gt;&gt;：左 / 右移</p>
<p>==/！=：比较两个 bitset$bitset$是否相等。</p>
<p>关于位运算的相关知识，不懂的小伙伴请戳这里：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11384756.html">常用的位运算技巧</a></p>
<p>另外，bitset$bitset$容器还支持直接取值和直接赋值的操作：具体操作方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s[3]=1;</span><br><span class="line">s[5]=0;</span><br></pre></td></tr></table></figure>
<p>这里要注意：在 bitset$bitset$容器中，最低位为 0$0$。这与我们的数组实现仍然有区别。</p>
<h2 id="bitset-bitset-容器的实际应用"><a href="#bitset-bitset-容器的实际应用" class="headerlink" title="bitset$bitset$容器的实际应用"></a>bitset$bitset$容器的实际应用</h2><p>bitset$bitset$可以高效率地对 01$01$串，01$01$矩阵等等只含 0/1$0/1$的题目进行处理。其中支持的许多操作对我们处理数据非常有帮助。如果碰到一道 0/1$0/1$题，使用 bitset$bitset$或许是不错的选择。</p>
<h1 id="详解-C-STL-map-容器"><a href="#详解-C-STL-map-容器" class="headerlink" title="详解 C++ STL map 容器"></a>详解 C++ STL map 容器</h1><p><a href="https://www.cnblogs.com/fusiwei/p/11823184.html">map 讲解传送门</a></p>
<p>本篇随笔简单讲解一下 C++STL$C++STL$中的 map$map$容器的使用方法和使用技巧。</p>
<h2 id="map-容器的概念"><a href="#map-容器的概念" class="headerlink" title="map 容器的概念"></a>map 容器的概念</h2><p>map$map$的英语释义是 “地图”，但 map$map$容器可和地图没什么关系。map$map$是 <strong>“映射容器”</strong>，其存储的两个变量构成了一个键值到元素的映射关系。</p>
<p>比如下图：</p>
<p><img data-src="https://img-blog.csdn.net/20180808210044289?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmUyMDE2NTEwNDAyNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>我们可以根据键值快速地找到这个映射出的数据。</p>
<p>map$map$容器的内部实现是一棵红黑树（平衡树的一种），因为比较复杂而且与理解并无多大关系，所以不予介绍，有兴趣的读者可以自己查阅相关的资料。</p>
<h2 id="map-容器的声明"><a href="#map-容器的声明" class="headerlink" title="map 容器的声明"></a>map 容器的声明</h2><p>map$map$容器存在于 STL$STL$模板库<code>#include&lt;map&gt;</code>中。使用的时候需要先开这个库。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;map&gt;</span><br><span class="line">map&lt;int,char&gt; mp;</span><br></pre></td></tr></table></figure>
<p>这就建立了一个从一个整型变量到一个字符型变量的映射。</p>
<h2 id="map-容器的用法"><a href="#map-容器的用法" class="headerlink" title="map 容器的用法"></a>map 容器的用法</h2><p>因为 map$map$容器和 set$set$容器都是使用红黑树作为内部结构实现的。所以其用法比较相似。但由于二者用途大有不同，所以其用途还有微妙的差别。对于初学者来讲，其更容易涉及到的应该是 vector$vector$容器、queue$queue$容器等，但是对于大佬们，经常用个 set$set$、map$map$，没事再用 bitset$bitset$压一压状态这都是家常便饭。</p>
<p>如果有想学习 set,bitset$set,bitset$容器的，请参考下面两篇博客，讲的比较详细：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11720118.html">bitset 容器详解</a></p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11820365.html">set 容器详解</a></p>
<p>其实，C++STL$C++STL$容器的使用方式都是差不多的。我们完全可以举一反三地去类比。与 bitset$bitset$重定义了许多~奇形怪状~新的函数之外，其他都是大致相同的。所以笔者在此不再做幼稚的介绍，大家都是竞赛狗，应该都能自己看明白。</p>
<h4 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h4><p>如其他 C++STL$C++STL$容器一样，map$map$支持基本相同的基本操作：</p>
<p>比如清空操作，函数 clear()$clear()$，返回容器大小 size()$size()$，返回首尾迭代器 begin(),end()$begin(),end()$等。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>map$map$容器的插入操作大约有两种方法，第一种是类似于数组类型，可以把键值作为数组下标对 map$map$进行直接赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mp[1]=&#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用 insert()$insert()$函数进行插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mp.insert(map&lt;int,char&gt;::value_type(5,&#x27;d&#x27;));</span><br></pre></td></tr></table></figure>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>可以直接用 erase()$erase()$函数进行删除，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mp.erase(&#x27;b&#x27;);</span><br></pre></td></tr></table></figure>
<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><p>和其他容器差不多，map$map$也是使用迭代器实现遍历的。如果我们要在遍历的时候查询键值（即前面的那个），可以用<code>it-&gt;first</code>来查询，那么，当然也可以用<code>it-&gt;second</code>查询对应值（后面那个）</p>
<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>查找操作类比 set$set$的查找操作。但是 map$map$中查找的都是键值。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mp.find(1);</span><br></pre></td></tr></table></figure>
<p>即查找键值为 1$1$的元素。</p>
<h2 id="map-和-pair-的关系"><a href="#map-和-pair-的关系" class="headerlink" title="map 和 pair 的关系"></a>map 和 pair 的关系</h2><p>我们发现，map$map$和 C++$C++$内置二元组 pair$pair$特别相似。那是不是 map$map$就是 pair$pair$呢？（当然不是）</p>
<p>那么 map$map$和 pair$pair$又有什么关系呢？</p>
<p>@JZYShruraK 大佬</p>
<p>首先，map$map$构建的关系是映射，也就是说，如果我们想查询一个键值，那么只会返回唯一的一个对应值。但是如果使用 pair$pair$的话，不仅不支持 O(log)$O(log)$级别的查找，也不支持知一求一，因为 pair$pair$的第一维可以有很多一样的，也就是说，可能会造成一个键值对应 n$n$多个对应值的情况。这显然不符合映射的概念。</p>
]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>标准库之 find() 和 find_if() 函数_list find_if 与 find 哪个效率高</title>
    <url>/posts/cb2d3688/</url>
    <content><![CDATA[<h4 id="0-1-1-标准库之-find-和-find-if-函数"><a href="#0-1-1-标准库之-find-和-find-if-函数" class="headerlink" title="0.1.1 标准库之 find 和 find_if 函数"></a>0.1.1 标准库之 find 和 find_if 函数</h4><ul>
<li><a href="#find_if_93">find_if()</a></li>
</ul>
<h2 id="1-find"><a href="#1-find" class="headerlink" title="1 find()"></a>1 find()</h2><p>C++ 标准库中的 find，find_if 函数可以用于对数组、容器等进行查找。<br><a href="http://www.cplusplus.com/reference/algorithm/find/">http://www.cplusplus.com/reference/algorithm/find/</a></p>
<p>头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">   InputIterator <span class="title function_">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span>;</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line">template&lt;class InputIterator, class T&gt;</span><br><span class="line">  InputIterator <span class="title function_">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="type">const</span> T&amp; val)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first==val) <span class="keyword">return</span> first;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find 函数在 [first,last) 范围内，查找是否有值为 val 的位置，val 必须要能支持 operator==。</p>
<p>所以对于容器中的元素是基本类型时，可以直接使用 find 函数。<br>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="type">int</span>&gt;::iterator it = find(lst.begin(), lst.end(), <span class="number">2</span>); <span class="comment">// 查找list中是否有元素“2”</span></span><br><span class="line">    <span class="keyword">if</span> (it != lst.end()) <span class="comment">// 找到了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;find it&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 没找到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;not find&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果容器里的元素是一个类，则需要对该类重载 == 操作符, 然后在用 find 查找，<br>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    Person(<span class="built_in">string</span> name):m_name(name)&#123;&#125;</span><br><span class="line">    ~Person(<span class="type">void</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> m_name; <span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> operator==(<span class="type">const</span> Person&amp; rhs) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (m_name==rhs.m_name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;Person&gt; lst&#123;Person(<span class="string">&quot;Mike&quot;</span>),Person(<span class="string">&quot;John&quot;</span>),Person(<span class="string">&quot;Bobby&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    Person <span class="title function_">one</span><span class="params">(<span class="string">&quot;John&quot;</span>)</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;Person&gt;::iterator it = find(lst.begin(), lst.end(), one); <span class="comment">// 查找list中是否有元素one</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != lst.end()) <span class="comment">// 找到了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;find it&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 没找到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;not find&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-find-if"><a href="#2-find-if" class="headerlink" title="2 find_if()"></a>2 find_if()</h2><p>还有一种情况是，容器中是一个指向类的指针，那怎么查找呢？<br>注意我们想比较的是指针指向的对象是否相等，而不是指针本身。</p>
<p>例如 list<Person*>, 这个 list 中的每一个元素都是一个对象的指针，我们要在这个 list 中查找是否存在该指针指向的对象与给定对象相等（当然，这里对象相等由你自定义其含义），找到就返回指向该对象的指针。</p>
<p>这时候，不能再使用 find 函数了，因为比较的是 list<Person*> 的元素 Person*, 即它比较的是指针是否相等，这往往不是我们想要的。</p>
<p>这里，我们需要使用 find_if 函数<br>参考：<a href="http://www.cplusplus.com/reference/algorithm/find_if/">http://www.cplusplus.com/reference/algorithm/find_if/</a></p>
<p>头文件</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">UnaryPredicate</span>&gt;</span><br><span class="line">   <span class="function">InputIterator <span class="title">find_if</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span>;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> UnaryPredicate&gt;</span></span><br><span class="line"><span class="function">  InputIterator <span class="title">find_if</span> <span class="params">(InputIterator first, InputIterator last, UnaryPredicate pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pred</span>(*first)) <span class="keyword">return</span> first;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_if 在 [first,last) 范围内查找能使得 pred 返回 true 的值，并返回指向该值的迭代器。</p>
<p>所以我们先在外面定义一个 的函数对象 fun, 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">fun</span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(string name):<span class="built_in">m_name</span>(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person* rhs)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (m_name==rhs-&gt;m_name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;fun;</span><br></pre></td></tr></table></figure>
<p>然后利用 find_if() 函数查找，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    Person(<span class="built_in">string</span> name):m_name(name)&#123;&#125;</span><br><span class="line">    ~Person(<span class="type">void</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> m_name; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fun</span>&#123;</span></span><br><span class="line">    fun(<span class="built_in">string</span> name):m_name(name)&#123;&#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(Person* rhs)</span><span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (m_name==rhs-&gt;m_name);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">&#125;fun;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;Person*&gt; lst&#123;new Person(<span class="string">&quot;Mike&quot;</span>),new Person(<span class="string">&quot;John&quot;</span>),new Person(<span class="string">&quot;Bobby&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;Person*&gt;::iterator it = find_if(lst.begin(), lst.end(), fun(<span class="string">&quot;John&quot;</span>)); <span class="comment">// 查找list中是否有元素能够使得fun(*it)返回true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != lst.end()) <span class="comment">// 找到了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;find it&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 没找到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;not find&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:lst)&#123;</span><br><span class="line">        delete i;</span><br><span class="line">        i=nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/20200713193729843.png" alt=""></p>
]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Single Round Match 790 Editorials - Topcoder</title>
    <url>/posts/d6976ad7/</url>
    <content><![CDATA[<p>summary: Div2-Easy: Alice’s Birthday For a given , we have to partition the first fibonacci numbers in two set……</p>
<h4 id="Div2-Easy-Alice’s-Birthday"><a href="#Div2-Easy-Alice’s-Birthday" class="headerlink" title="Div2-Easy: Alice’s Birthday"></a>Div2-Easy: Alice’s Birthday</h4><p>For a given , we have to partition the first  fibonacci numbers in two sets with equal sum. The fact that  means that if  is a multiple of 3, then I can give  to Charlie and  to Eric,  to Charlie and  to Eric, so on and so forth eventually giving  to Charlie and  to Eric. The other two cases are  and .</p>
<p>For the first case, let us try to re-use our previous strategy for the last  boxes starting with  going to Charlie and  to Eric. In the end, we will be left with the first two boxes containing  and , respectively. Since,  so we can simply give one box to Charlie and other one to Eric.</p>
<p>For the second case, we can try our previous strategy but will always be left with one extra box. The fact that the sum of  is odd means that we cannot divide them <em>evenly</em> among Charlie and Eric. Had it been possible to divide it equally, it would mean that the total sum is even, which is not possible and can be proven using induction.</p>
<p>Since we only have to run a loop till , so time complexity is .</p>
<p>Reference sol in Java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*; </span><br><span class="line">import java.util.*; </span><br><span class="line">import javafx.util.Pair;</span><br><span class="line"></span><br><span class="line">public class AlicesBirthday &#123;</span><br><span class="line">    public int[] partition(int k) &#123;</span><br><span class="line">	int[] arr = &#123;-1&#125; ;</span><br><span class="line">	if(k % 3 == 1) return arr ; </span><br><span class="line">	</span><br><span class="line">        ArrayList&lt;Integer&gt; charlie = new ArrayList&lt;Integer&gt;(), eric = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">	while(k &gt; 2) &#123;</span><br><span class="line">	    charlie.add(k--);</span><br><span class="line">	    eric.add(k--); eric.add(k--);</span><br><span class="line">	&#125;</span><br><span class="line">	if(k == 2) &#123; </span><br><span class="line">	    eric.add(k--);</span><br><span class="line">	    charlie.add(k--);</span><br><span class="line">	&#125;</span><br><span class="line">	int[] ret = new int[charlie.size()]; int index = 0;</span><br><span class="line">	for (Integer value: charlie) </span><br><span class="line">   		ret[index++] = value;</span><br><span class="line">	return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference sol in Python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AlicesBirthday:</span><br><span class="line">	def partition(self, K):</span><br><span class="line">		F = [1, 1]</span><br><span class="line">		while len(F) &lt; K: F.append( F[-1] + F[-2] )</span><br><span class="line">		F = F[:K]</span><br><span class="line">		charlie, eric, answer = 0, 0, []</span><br><span class="line">		for k in reversed(range(K)):</span><br><span class="line">			if charlie &gt; eric:</span><br><span class="line">				eric += F[k]</span><br><span class="line">			else:</span><br><span class="line">				charlie += F[k]</span><br><span class="line">				answer.append(k+1)</span><br><span class="line">		if charlie == eric:</span><br><span class="line">			return answer</span><br><span class="line">		return [-1]</span><br></pre></td></tr></table></figure>
<h4 id="Div2-Medium-Bob-the-Builder"><a href="#Div2-Medium-Bob-the-Builder" class="headerlink" title="Div2-Medium: Bob the Builder"></a>Div2-Medium: Bob the Builder</h4><p>Suppose we are at the given height . At any step, we can either move to one of its factors or add  to it. While we can move to its factors without any cost, we have to spend $ to add . So, basically, we have a given state, few possible options from there, and we want to find out end whether a specific end state (i.e. height ) is reachable or not. If reachable, we have to do so in minimum cost. This naturally appeals to be modeled by graphs with states representing the nodes and edges representing the transitions. Thus, we have to find the shortest path in a graph, so Dijkstra definitely comes as the first solution in mind.</p>
<p>One may use Dijkstra to solve the problem, but it is not immediately clear when to stop exploring if there does not exist any path. We would never actually need to go beyond  (<strong>proof is shown below</strong>). But going so high, Dijkstra may get TLE. The fact that edge weights are only  and  means that we can use  instead of Dijkstra and the time limit was high enough to allow that in case exploration goes so high. However, in practice, the max step explored before reaching a goal seems to be quite low (the worst case we could find was not more than ); hence normal Dijkstra passes easily.</p>
<p>Reference sol in Java using 0-1 BFS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class BobtheBuilder &#123;</span><br><span class="line">    public int N = (int) 5e5 + 2 ; </span><br><span class="line">    public int maxStep = -1 ; </span><br><span class="line">    public List &lt;Integer&gt;[] factors = new ArrayList[N];</span><br><span class="line">    public int dist[] = new int[N] ; </span><br><span class="line">    public boolean seen[] = new boolean[N] ; </span><br><span class="line">    </span><br><span class="line">    void prep() &#123;</span><br><span class="line">	    for(int i = 1; i &lt; N; i++) &#123;</span><br><span class="line">	        factors[i] = new ArrayList&lt;Integer&gt; (); </span><br><span class="line">	        dist[i] = (int) 2e9 ; seen[i] = false ; </span><br><span class="line">	        int sq = (int) Math.sqrt(i);</span><br><span class="line">	        for(int j = 1; j &lt;= sq; j++) &#123;</span><br><span class="line">	            if(i % j == 0) &#123;</span><br><span class="line">	                factors[i].add(j); factors[i].add(i/j);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public int minimumPrice(int b, int k, int h) &#123;</span><br><span class="line">	prep();</span><br><span class="line">        Deque&lt;Integer&gt; deq = new ArrayDeque&lt;Integer&gt;(); // seen[b] = true ; </span><br><span class="line">        dist[b] = 0 ;</span><br><span class="line">        deq.addFirst(b);</span><br><span class="line">        while(deq.size() &gt; 0) &#123;</span><br><span class="line">            int top = deq.removeFirst(); if(top &gt; maxStep) maxStep = top ; </span><br><span class="line">            if(top == h) return dist[top] ;</span><br><span class="line">            for(int f : factors[top]) &#123;</span><br><span class="line">                if(dist[top] &lt; dist[f]) &#123;</span><br><span class="line">                    deq.addFirst(f);</span><br><span class="line">                    dist[f] = dist[top] ; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if( (top + k) &lt; N) &#123;</span><br><span class="line">                if( (dist[top] + 1) &lt; dist[top + k]) &#123;</span><br><span class="line">                    dist[top + k] = dist[top] + 1 ;</span><br><span class="line">                    deq.addLast(top + k); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1 ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference sol in C++ using Dijkstra</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct record &#123;</span><br><span class="line">    int id;</span><br><span class="line">    int dist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator&lt;(const record &amp;A, const record &amp;B) &#123;</span><br><span class="line">    if (A.dist != B.dist) return A.dist &lt; B.dist;</span><br><span class="line">    return A.id &lt; B.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve(int start, int add, int goal) &#123;</span><br><span class="line">    int div = __gcd(add,goal);</span><br><span class="line">    if (start % div) return -1;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; D(1002000,2000000);</span><br><span class="line">    D[start] = 0;</span><br><span class="line">    set&lt;record&gt; Q;</span><br><span class="line">    Q.insert( &#123;start, 0&#125; );</span><br><span class="line">    while (!Q.empty()) &#123;</span><br><span class="line">        record kde = *Q.begin();</span><br><span class="line">        Q.erase( Q.begin() );</span><br><span class="line">        if (kde.id &gt;= 1002000) continue;</span><br><span class="line">        if (kde.id == goal) break;</span><br><span class="line">        for (int div=1; div*div&lt;=kde.id; ++div) if (kde.id % div == 0) &#123;</span><br><span class="line">            vector&lt;int&gt; opts = &#123;div, kde.id/div&#125;;</span><br><span class="line">            for (int kam : opts) &#123;</span><br><span class="line">                int ndist = kde.dist;</span><br><span class="line">                if (ndist &gt;= D[kam]) continue;</span><br><span class="line">                Q.erase( &#123;kam, D[kam]&#125; );</span><br><span class="line">                D[kam] = ndist;</span><br><span class="line">                Q.insert( &#123;kam, D[kam]&#125; );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; opts = &#123; kde.id + add &#125;;</span><br><span class="line">        for (int kam : opts) &#123;</span><br><span class="line">            int ndist = kde.dist + 1;</span><br><span class="line">            if (ndist &gt;= D[kam]) continue;</span><br><span class="line">            Q.erase( &#123;kam, D[kam]&#125; );</span><br><span class="line">            D[kam] = ndist;</span><br><span class="line">            Q.insert( &#123;kam, D[kam]&#125; );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (D[goal] == 2000000) return -1;</span><br><span class="line">    return D[goal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct BobtheBuilder &#123;</span><br><span class="line">    int minimumPrice(int B, int K, int H) &#123; return solve(B,K,H); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Proof</strong><br>If we are at some state , then at anytime, we can go to one of its factors (possibly  itself) or add . We do this starting from  until we reach . Suppose it is possible to reach , then thinking about the process in reverse is basically from  we can go to one of its <em>multiple</em> (possibly  itself) or subtract  and continue this loop until we reach . Thus, we can model this in the following form:</p>
<p>Simplifying this, we reduce it to a well-known form:</p>
<p>So, we end up with a linear diophantine equation. Let</p>
<p>. This is only solvable when</p>
<p>so we can instantly return -1 if</p>
<p>is not a multiple of</p>
<p>. The fact that</p>
<p>have opposite signs means that this admits infinite positive solutions. From</p>
<p><em>Bezuot’s Identity</em></p>
<p>, we can always find a pair</p>
<p>such that</p>
<p>and</p>
<p>. So we can always find</p>
<p>lie in the range</p>
<p>and since infinite positive solutions are possible and we can shift</p>
<p>, so it’s always possible to find a pair</p>
<p>with both lying in</p>
<p>. Since</p>
<p>, so the max state we need to explore to ensure we always find a solution is bounded by</p>
<p>. Once we reach</p>
<p>from</p>
<p>, we can repeat the same process to reach</p>
<p>from</p>
<p>. While we did the derivation in the reverse form, it obviously holds in the forward manner starting from</p>
<p>. Some useful links:</p>
<ol>
<li><a href="https://math.stackexchange.com/questions/670405/does-the-extended-euclidean-algorithm-always-return-the-smallest-coefficients-of">Details on Bezout’s Identity</a></li>
<li><a href="https://math.stackexchange.com/questions/1470541/existence-of-positive-solution-of-a-diophantine-equation">Positive Solution of Linear Diophantine Eq</a></li>
</ol>
<h4 id="Div2-Hard-Div1-Easy-The-Social-Network"><a href="#Div2-Hard-Div1-Easy-The-Social-Network" class="headerlink" title="Div2-Hard / Div1-Easy: The Social Network"></a>Div2-Hard / Div1-Easy: The Social Network</h4><p>We are given an undirected connected graph  with exponential weights of the form , and we have to find its minimum cut. The problem may look intimidating but what is in favor for us is the fact that <em>all edge weights are distinct</em>.</p>
<p>Let the given weights sorted in decreasing order be  (i.e. edge weight is ). Then, for any valid  between  and , we have</p>
<p><img data-src="https://www.topcoder.com/wp-content/uploads//2020/09/image-14-1024x145.png" alt=""></p>
<p>So, we would like to keep the edge with the highest weight <em>out of the cut edges set</em> at the cost of ending up with all other edges in the cut since their total sum is <em>strictly</em> less than the highest weight. Thus, we can keep adding edges one by one in the graph (in decreasing order of their weight) as long as <em>one whole connected component</em> does not form.</p>
<p>The edges which do not get added in the graph form our <em>cut edges</em>, and their sum is the answer. This can be done by DSU but was not required since the constraints were significantly small. If we do use DSU, then sorting dominates the runtime with total complexity as .</p>
<p>Reference Sol in Java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.lang.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class TheSocialNetwork &#123;</span><br><span class="line">    </span><br><span class="line">    class Edge implements Comparable&lt;Edge&gt; &#123;</span><br><span class="line">        public int u;</span><br><span class="line">        public int v;</span><br><span class="line">        public int w;</span><br><span class="line">        </span><br><span class="line">        public Edge(int uu, int vv, int cc) &#123;</span><br><span class="line">            this.u = uu;</span><br><span class="line">            this.v = vv;</span><br><span class="line">            this.w = cc;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public int compareTo(Edge c) &#123;</span><br><span class="line">            if (w &lt; c.w) return 1;</span><br><span class="line">            if (w &gt; c.w) return -1;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    int M = 1002 ; int C = 100002 ; int N = 302 ; </span><br><span class="line">    List &lt;Edge&gt; edges = new ArrayList&lt;Edge&gt;() ; </span><br><span class="line">    int[] par = new int[N] ; int[] sz = new int[N] ; int[] pwr = new int[C] ; </span><br><span class="line">    int MOD = (int) (1e9 + 7); int comp ; </span><br><span class="line">    </span><br><span class="line">    boolean[] seen = new boolean[C] ;</span><br><span class="line">    List &lt; Integer &gt;[] adj = new ArrayList[N] ; </span><br><span class="line">    boolean[] visited = new boolean[N] ;</span><br><span class="line">    int connected ;</span><br><span class="line">    </span><br><span class="line">    void prepare() &#123;</span><br><span class="line">        pwr[0] = 1 ; seen[0] = false ; </span><br><span class="line">        for(int i = 1; i &lt; C; i++) &#123;</span><br><span class="line">            pwr[i] = (pwr[i-1] * 2) % MOD ;</span><br><span class="line">            seen[i] = false ;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; N; i++) &#123;</span><br><span class="line">            par[i] = i ; sz[i] = 1 ;</span><br><span class="line">            adj[i] = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">            visited[i] = false ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int getPar(int v) &#123;</span><br><span class="line">        if(par[v] == v) return v ;</span><br><span class="line">        else return par[v] = getPar(par[v]); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int dsu(int u, int v) &#123;</span><br><span class="line">        int parU = getPar(u) ; int parV = getPar(v);</span><br><span class="line">        if(parU == parV) return 0;</span><br><span class="line">        </span><br><span class="line">        if(sz[u] &lt; sz[v]) &#123; // swap</span><br><span class="line">            u ^= v ; v ^= u ; u ^= v ; </span><br><span class="line">        &#125;</span><br><span class="line">        sz[u] += sz[v] ;</span><br><span class="line">        par[parV] = parU ; </span><br><span class="line">        return 1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int minimumCut(int n, int m, int[] u, int[] v, int[] l) &#123;</span><br><span class="line">        prepare();</span><br><span class="line">        for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            Edge e = new Edge(u[i], v[i], l[i]);</span><br><span class="line">            edges.add(e); </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(edges);</span><br><span class="line">        int ans = 0; comp = n ; </span><br><span class="line">        for(Edge e : edges) &#123;</span><br><span class="line">            System.out.println(e.w);</span><br><span class="line">            int parU = getPar(e.u) ; int parV = getPar(e.v);</span><br><span class="line">            if(parU == parV) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if(comp &gt; 2) &#123; </span><br><span class="line">                    comp-- ;</span><br><span class="line">                    dsu(e.u, e.v);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    ans += pwr[e.w] ; </span><br><span class="line">                    ans %= MOD ; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans ; </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference Sol in Python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def pow2(n):</span><br><span class="line">	if n == 0: return 1</span><br><span class="line">	t = pow2(n//2)</span><br><span class="line">	t *= t</span><br><span class="line">	if n % 2: t *= 2</span><br><span class="line">	return t % 1000000007</span><br><span class="line"></span><br><span class="line">class TheSocialNetwork:</span><br><span class="line">	def minimumCut(self, n, m, u, v, l):</span><br><span class="line">		edges = [ (-z,x-1,y-1) for x,y,z in zip(u,v,l) ]</span><br><span class="line">                edges.sort()</span><br><span class="line">                component_count = n</span><br><span class="line">                component = list(range(n))</span><br><span class="line">		answer = 0</span><br><span class="line">		for w,x,y in edges:</span><br><span class="line">			if component[x] == component[y]: continue</span><br><span class="line">			if component_count == 2:</span><br><span class="line">				answer = (answer + pow2(-w)) % 1000000007</span><br><span class="line">			else:</span><br><span class="line">				cx, cy = component[x], component[y]</span><br><span class="line">				component = [ cx if c==cy else c for c in component ]</span><br><span class="line">				component_count -= 1</span><br><span class="line">		return answer</span><br></pre></td></tr></table></figure>
<p><em>Side Thought</em>: We were wondering whether it is possible to solve this problem using <em>max-flow</em>?</p>
<h4 id="Div1-Medium-Proposal-Optimization"><a href="#Div1-Medium-Proposal-Optimization" class="headerlink" title="Div1-Medium: Proposal Optimization"></a>Div1-Medium: Proposal Optimization</h4><p>Such kind of ratio problems can be solved by using a niche trick. I think it is hard to develop this line of thinking unless you have encountered it before.</p>
<p>Let us say the optimal ratio is . Thus, . What we can do is a binary search on , and check if a ratio is feasible or not. So, for a given , we have to check whether  is possible, which is the same thing as  (let’s call the L.H.S. ). The constraints on  seem to be quite high to do any form of <em>DP</em> while constraints on the grid’s dimension,  are quite low although obviously not permitting brute force solutions. However, meet-in-the-middle looks promising since we can store  while doing brute force from one corner of the grid and checking from another (meeting in cells lying on <em>some sort of diagonal</em> of the grid).</p>
<p>In fact, it is the intended solution, and we also have to take care of the costs along with  to actually know if any of the options is actually feasible. So, when doing brute from one side, we store  pairs on <em>those diagonal cells</em> and later sort them according to  to ease our process in the next brute. While doing brute from the other end, we have , and we want the highest  whose cost satisfies . By storing  in prefix maximum manner, we can binary search on the highest index option with cost  and take its  (since we already sorted) to get our answer.</p>
<p>The best diagonal cells for a grid of size  would be the set . Since x, so the number of <em>such diagonal</em> cells (let us denote that by ) can’t exceed . We can focus on the analysis of square matrix since it will dominate the rectangular grids. Let the number of binary search iterations required to find the optimal ratio be  (80 iterations suffice for  error). To reach a diagonal cell  there are  ways and then we have to binary search on those many paths which we got from first brute force. Thus, doing meet-in-the-middle takes</p>
<p>Hence, the total time required is bounded by</p>
<p>.</p>
<p>Reference Sol in C++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;ext/pb_ds/assoc_container.hpp&gt;</span><br><span class="line">#include&lt;ext/pb_ds/tree_policy.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace std ;</span><br><span class="line">using namespace __gnu_pbds;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; // *s.find_by_order(0), s.order_of_key(2) ;</span><br><span class="line">using ordered_set = tree&lt;T, null_type, less&lt;T&gt;, rb_tree_tag, tree_order_statistics_node_update&gt;;</span><br><span class="line"></span><br><span class="line">#define reMin(a, b) a = min(a, b)</span><br><span class="line">#define reMax(a, b) a = max(a, b)</span><br><span class="line"></span><br><span class="line">#define lint long long</span><br><span class="line">#define pb push_back</span><br><span class="line">#define F first </span><br><span class="line">#define S second </span><br><span class="line">#define sz(x) (int)x.size()</span><br><span class="line">#define all(x) begin(x), end(x)</span><br><span class="line">#define SET(x, val) memset(x, val, sizeof(x))</span><br><span class="line">#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)</span><br><span class="line"></span><br><span class="line">typedef vector &lt; int &gt; vi ;</span><br><span class="line">typedef pair &lt; int, int &gt; pii ;</span><br><span class="line"></span><br><span class="line">const int N = 300 + 2 ;</span><br><span class="line">const int MOD = 1e9 + 7 ;</span><br><span class="line">const lint INF = 1e18 ;</span><br><span class="line"></span><br><span class="line">double best = 0 ;</span><br><span class="line">int n, m, k ;</span><br><span class="line">int roses[N][N], tulips[N][N], cost[N][N] ;</span><br><span class="line"></span><br><span class="line">vector &lt; pair &lt; int, double &gt; &gt; meet[N][N] ;</span><br><span class="line">vector &lt; double &gt; ratios[N][N] ; </span><br><span class="line">int diagonal ;</span><br><span class="line">bool possible = 0 ;</span><br><span class="line">bool ratioSatisfied = 0 ; </span><br><span class="line"></span><br><span class="line">void down(int i, int j, int rose, int tulip, int totalCost, double&amp; R) &#123;</span><br><span class="line">	if(i &gt;= n or j &gt;= m) return ;</span><br><span class="line">	rose += roses[i][j] ; tulip += tulips[i][j] ; totalCost += cost[i][j] ; </span><br><span class="line">	if(totalCost &gt; k) return ; </span><br><span class="line">	if(i + j == diagonal) &#123;</span><br><span class="line">		double cur = rose ; cur -= R * tulip ; </span><br><span class="line">		meet[i][j].pb(&#123;totalCost, cur&#125;);</span><br><span class="line">		return ; </span><br><span class="line">	&#125;</span><br><span class="line">	down(i+1, j, rose, tulip, totalCost, R); down(i, j+1, rose, tulip, totalCost, R); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void up(int i, int j, int rose, int tulip, int totalCost, double&amp; R) &#123;</span><br><span class="line">	if(i &lt; 0 or j &lt; 0) return ;</span><br><span class="line">	rose += roses[i][j] ; tulip += tulips[i][j] ; totalCost += cost[i][j] ; </span><br><span class="line">	if(totalCost &gt; k) return ; </span><br><span class="line">	if(i + j == diagonal) &#123;</span><br><span class="line">		rose -= roses[i][j] ; tulip -= tulips[i][j] ; totalCost -= cost[i][j] ; </span><br><span class="line">		double cur = rose ; cur -= R * tulip ; </span><br><span class="line"></span><br><span class="line">		pair &lt; int, double &gt; item = &#123;k - totalCost, 2e9&#125; ;</span><br><span class="line">		int idx = upper_bound(all(meet[i][j]), item) - meet[i][j].begin();</span><br><span class="line">		idx-- ;</span><br><span class="line">		if(idx &gt;= 0) &#123;</span><br><span class="line">			possible = 1 ; assert(idx &lt; sz(ratios[i][j]) and sz(ratios[i][j]) == sz(meet[i][j]));</span><br><span class="line">			double mx = ratios[i][j][idx] ; </span><br><span class="line">			</span><br><span class="line">			if((mx + cur) &gt;= 0) // should be EPS!! </span><br><span class="line">				ratioSatisfied = 1 ; </span><br><span class="line">		&#125;</span><br><span class="line">		return ; </span><br><span class="line">	&#125;</span><br><span class="line">	up(i-1, j, rose, tulip, totalCost, R); up(i, j-1, rose, tulip, totalCost, R); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void check(double ratio) &#123;</span><br><span class="line">	down(0, 0, 0, 0, 0, ratio);</span><br><span class="line"></span><br><span class="line">	for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		int j = diagonal - i ;</span><br><span class="line">		if(j &gt;= m or j &lt; 0) continue ; </span><br><span class="line">		</span><br><span class="line">        if(sz(meet[i][j]) &lt;= 0) continue ; </span><br><span class="line">		sort(all(meet[i][j]));</span><br><span class="line"></span><br><span class="line">		ratios[i][j].pb(meet[i][j][0].S);</span><br><span class="line">		for(int p = 1; p &lt; sz(meet[i][j]); p++)</span><br><span class="line">			ratios[i][j].pb(max(meet[i][j][p].S, ratios[i][j].back()));</span><br><span class="line">	&#125;</span><br><span class="line">	up(n-1, m-1, 0, 0, 0, ratio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double solve() &#123;</span><br><span class="line">	double low = 0, high = 1e6 ; ratioSatisfied = 0 ;</span><br><span class="line">	</span><br><span class="line">	for(int iter = 0; iter &lt; 70; iter++) &#123;</span><br><span class="line">		double mid = (low + high) / 2 ;</span><br><span class="line">		check(mid); </span><br><span class="line">		if(ratioSatisfied) low = mid ;</span><br><span class="line">		else high = mid ;</span><br><span class="line">		</span><br><span class="line">		// clear stuff</span><br><span class="line">		ratioSatisfied = 0 ; </span><br><span class="line">		for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			int j = diagonal - i ;</span><br><span class="line">			if(j &lt; 0 or j &gt;= m) continue ; </span><br><span class="line">			ratios[i][j].clear(); meet[i][j].clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return low ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProposalOptimization &#123;</span><br><span class="line">public:</span><br><span class="line">	double bestPath(int rows, int cols, int K, vi roz,  vi tolip, vi expense);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double ProposalOptimization::bestPath(int rows, int cols, int K, vi roz,  vi tolip, vi expense )&#123;</span><br><span class="line">	n = rows ; m = cols ; k = K ;</span><br><span class="line">	for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) roses[i][j] = roz[i*cols + j] ; </span><br><span class="line">	for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) tulips[i][j] = tolip[i* cols + j] ; </span><br><span class="line">	for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cost[i][j] = expense[i*cols + j] ; </span><br><span class="line">	double best = solve();</span><br><span class="line">	if(!possible) return -1 ;</span><br><span class="line">	else return best ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference Sol in Java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.math.*;</span><br><span class="line"> </span><br><span class="line">public class ProposalOptimization &#123;</span><br><span class="line">    class Option implements Comparable&lt;Option&gt; &#123;</span><br><span class="line">        public int orchids;</span><br><span class="line">        public int tulips;</span><br><span class="line">        public int cost;</span><br><span class="line"> </span><br><span class="line">        public Option(int orchids, int tulips, int cost) &#123;</span><br><span class="line">            this.orchids = orchids;</span><br><span class="line">            this.tulips = tulips;</span><br><span class="line">            this.cost = cost;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public int compareTo(Option c) &#123;</span><br><span class="line">            if (cost &lt; c.cost) return -1;</span><br><span class="line">            if (cost &gt; c.cost) return 1;</span><br><span class="line">            if (orchids &lt; c.orchids) return -1;</span><br><span class="line">            if (orchids &gt; c.orchids) return 1;</span><br><span class="line">            if (tulips &lt; c.tulips) return -1;</span><br><span class="line">            if (tulips &gt; c.tulips) return 1;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Option[][] getOptions(int[][] orchids, int[][] tulips, int[][] costs, int steps, boolean secondPass) &#123;</span><br><span class="line">        int R = orchids.length, C = orchids[0].length;</span><br><span class="line">        int[][] options = new int[][] &#123; &#123;0,0,0,0,0&#125; &#125;;</span><br><span class="line">        for (int d=1; d&lt;=steps; ++d) &#123;</span><br><span class="line">            int newOptionCount = 0;</span><br><span class="line">            for (int i=0; i&lt;options.length; ++i) &#123;</span><br><span class="line">                if (options[i][0] + 1 &lt; R) ++newOptionCount;</span><br><span class="line">                if (options[i][1] + 1 &lt; C) ++newOptionCount;</span><br><span class="line">            &#125;</span><br><span class="line">            int[][] newOptions = new int[newOptionCount][5];</span><br><span class="line">            for (int i=0, j=0; i&lt;options.length; ++i) &#123;</span><br><span class="line">                if (options[i][0] + 1 &lt; R) &#123;</span><br><span class="line">                    int r = newOptions[j][0] = options[i][0] + 1;</span><br><span class="line">                    int c = newOptions[j][1] = options[i][1];</span><br><span class="line">                    int mul = (secondPass &amp;&amp; d == steps) ? 0 : 1;</span><br><span class="line">                    newOptions[j][2] = options[i][2] + mul * orchids[r][c];</span><br><span class="line">                    newOptions[j][3] = options[i][3] + mul * tulips[r][c];</span><br><span class="line">                    newOptions[j][4] = options[i][4] + mul * costs[r][c];</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                if (options[i][1] + 1 &lt; C) &#123;</span><br><span class="line">                    int r = newOptions[j][0] = options[i][0];</span><br><span class="line">                    int c = newOptions[j][1] = options[i][1] + 1;</span><br><span class="line">                    int mul = (secondPass &amp;&amp; d == steps) ? 0 : 1;</span><br><span class="line">                    newOptions[j][2] = options[i][2] + mul * orchids[r][c];</span><br><span class="line">                    newOptions[j][3] = options[i][3] + mul * tulips[r][c];</span><br><span class="line">                    newOptions[j][4] = options[i][4] + mul * costs[r][c];</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            options = newOptions;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] answerCounts = new int[R];</span><br><span class="line">        for (int i=0; i&lt;options.length; ++i) ++answerCounts[options[i][0]];</span><br><span class="line">        Option[][] answer = new Option[R][];</span><br><span class="line">        for (int r=0; r&lt;R; ++r) answer[secondPass ? R-1-r : r] = new Option[answerCounts[r]];</span><br><span class="line">        for (int i=0; i&lt;options.length; ++i) &#123;</span><br><span class="line">            int r = options[i][0];</span><br><span class="line">            answer[secondPass ? R-1-r : r][ --answerCounts[r] ] = new Option( options[i][2], options[i][3], options[i][4] );</span><br><span class="line">            // System.out.println(&quot;row &quot;+r+&quot; added option &quot;+options[i][2]+&quot; &quot;+options[i][3]+&quot; &quot;+options[i][4] );</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int[][] flip(int[][] array) &#123;</span><br><span class="line">        int R = array.length, C = array[0].length;</span><br><span class="line">        int[][] answer = new int[R][C];</span><br><span class="line">        for (int r=0; r&lt;R; ++r) for (int c=0; c&lt;C; ++c) answer[r][c] = array[R-1-r][C-1-c];</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    boolean solvable(double x, Option[] options1, Option[] options2, int K) &#123;</span><br><span class="line">        int b = 0;</span><br><span class="line">        double bestb = -1e20;</span><br><span class="line">        for (int a=options1.length-1; a&gt;=0; --a) &#123;</span><br><span class="line">            while (b &lt; options2.length &amp;&amp; options1[a].cost + options2[b].cost &lt;= K) &#123;</span><br><span class="line">                bestb = Math.max( bestb, options2[b].orchids - x * options2[b].tulips );</span><br><span class="line">                ++b;</span><br><span class="line">            &#125;</span><br><span class="line">            if (options1[a].orchids - x * options1[a].tulips + bestb &gt;= 0) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public double bestPath(int R, int C, int K, int[] _orchids, int[] _tulips, int[] _costs) &#123;</span><br><span class="line"> </span><br><span class="line">        int[][] orchids = new int[R][C];</span><br><span class="line">        int[][] tulips = new int[R][C];</span><br><span class="line">        int[][] costs = new int[R][C];</span><br><span class="line">        for (int r=0; r&lt;R; ++r) for (int c=0; c&lt;C; ++c) &#123;</span><br><span class="line">            orchids[r][c] = _orchids[r*C + c];</span><br><span class="line">            tulips[r][c] = _tulips[r*C + c];</span><br><span class="line">            costs[r][c] = _costs[r*C + c];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Option[][] options1 = getOptions( orchids, tulips, costs, (R+C-2)/2, false);</span><br><span class="line">        Option[][] options2 = getOptions( flip(orchids), flip(tulips), flip(costs), (R+C-1)/2, true);</span><br><span class="line"> </span><br><span class="line">        for (int i=0; i&lt;options1.length; ++i) Arrays.sort(options1[i]);</span><br><span class="line">        for (int i=0; i&lt;options2.length; ++i) Arrays.sort(options2[i]);</span><br><span class="line"> </span><br><span class="line">        int bestCost = K+1;</span><br><span class="line">        for (int i=0; i&lt;options1.length; ++i) if (options1[i].length &gt; 0 &amp;&amp; options2[i].length &gt; 0) bestCost = Math.min( bestCost, options1[i][0].cost + options2[i][0].cost );</span><br><span class="line">        if (bestCost &gt; K) return -1;</span><br><span class="line"> </span><br><span class="line">        double lo = 0, hi = 1e6 + 1;</span><br><span class="line">        for (int step=0; step&lt;200; ++step) &#123;</span><br><span class="line">            double med = (lo+hi) / 2;</span><br><span class="line">            boolean isSolvable = false;</span><br><span class="line">            for (int i=0; i&lt;options1.length; ++i) if (solvable(med,options1[i],options2[i],K)) &#123;</span><br><span class="line">                isSolvable = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (isSolvable) lo = med; else hi = med;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Div1-Hard-Tale-Of-Two-Squares"><a href="#Div1-Hard-Tale-Of-Two-Squares" class="headerlink" title="Div1-Hard: Tale Of Two Squares:"></a>Div1-Hard: Tale Of Two Squares:</h4><h1 id="div1"><a href="#div1" class="headerlink" title="div1"></a>div1</h1><p>A number can be expressed as a <em>sum of two sqaures</em> if and only if all its prime factors of the form  occur <em>even</em> times. So while taking the product of few numbers, we are only interested in its prime decomposition; hence, we can store a bit-vector for each  $A_{i}$  denoting <strong>odd/even</strong> occurrence of such prime factors.</p>
<p>From now on, **whenever I talk about primes it is assumed to be of the form $4K+3$ (for some $k \in Z$ ) and that the reader is familar with basis of a vector space and gaussian elimination. Please go through this if you are not familiar with the usage of those concepts in CP:<br><a href="https://codeforces.com/blog/entry/68953">Introductory Blog on using Linear Algebraic techniques to solve XOR related problems</a></p>
<p>Now, $A<em>{i}≤10^7$ so # primes  is around $3∗10^5$. Normal Gaussian elimination would easily TLE, even with bitsets. Still, lets imagine doing Gaussian elimination traversing from the highest bit to the lowest and xoring when necessary. Notice that, when you are traversing, if any prime factor $&gt;\sqrt{ A</em>{i} }$  exists (at max one can exist), the moment you xor it, no more bits $&gt;\sqrt{ A<em>{i} }$ will be on anymore (since only one such was on earlier and now you have xored it). Now, you can simply simulate Gaussian elimination on lower-order primes (i.e. primes$≤\sqrt{ A</em>{i} }$) and handle that one highest bit (if it exists) separately. This way, combined with bitset for lower-order primes, solves the problem without queries.</p>
<p>For queries, let us process them offline. Let $queries[l]$ store all the queries with their left endpoint as $l$. We will insert $A_{i}$ into our basis from the right side, $i$ going from $N−1$ to $0$. After we have inserted the element at index $i$, we will answer all the queries which begin their, i.e., the ones in $queries[i]$.</p>
<p>We will use a simple fact about linear combination of vectors but in a clever manner to answer the queries. Suppose we are about to try and insert v into our $Basis$ (may not insert if it turns out to be dependant). If $v=b <em>{1}+b </em>{2}+⋯b<em>{k} (where b</em>{i}∈Basis)$, then we can remove one of the $b_i$ and instead insert $v$ into its place, keeping the basis intact. So, we will use this fact while inserting — we will try to keep such elements in the basis which have leftmost index so as to answer as many queries as possible. We can do this greedily: while inserting $v$, whenever we are about to xor it with some $b_i$, we will first check which has the least index and $swap (b_i, v)$ if $v$ ‘s index is smaller than $b_i$. If we do end up swapping, then $v$ becomes a part of the basis (in place of $b_i$), and we progress doing Gaussian Elimination with $b_i$ instead. Otherwise, we move forward with v like we normally do. Please refer to the attached code for more details.</p>
<p>Now, when we answer queries which have left index $i$, we will have the basis vectors from $A[i: N]$ having the least possible index. So for a query $i$ $R$, we simply need to count how many vectors in our basis have index $≤R$. This can be easily done with some BIT or set.</p>
<p>Let $K$ denote the number of primes $\leq \sqrt{ A_{i} }$$(=225)$. We store a bitset of size $K$ for every prime. While doing Gaussian elimination, we handle the large bit manually while following the normal procedure for lower-order primes; hence it takes $O (\frac{K^2}{64})$ time to insert a $A_i$. After that, we answer queries at index i in $O (log (N))$ time by querying in our BIT. Hence, the overall complexity is $O \left( N⋅ \frac{k^2}{64}+Q⋅log (N) \right)$, dominated by Gaussian elimination using bitsets:</p>
<p>一个数字可以被表示为两个平方数的和，当且仅当它所有形式为 $4K+3$ 的质因数出现偶数次。所以，当我们计算几个数字的乘积时，我们只关心它的质因数分解；因此，我们可以为每个 $A_{i}$ 存储一个位向量，表示这些质因数的奇数/偶数出现。</p>
<p>从现在开始，<strong>每当我谈到质数时，假定它们为形式为 $4K+3$（对于某个 $k \in Z$），并且读者熟悉向量空间的基础和高斯消元。如果您对在竞赛编程中如何应用这些概念不熟悉，请阅读这篇文章：<a href="https://codeforces.com/blog/entry/68953">使用线性代数技术解决异或相关问题的入门博客</a></strong></p>
<p>现在，$A<em>{i}≤10^7$，因此质数的数量大约为 $3∗10^5$。普通的高斯消元甚至使用位集合也可能很容易超时。不过，让我们假设从最高位到最低位进行高斯消元并在必要时进行异或操作。注意，当您遍历时，如果存在任何大于 $\sqrt{ A</em>{i} }$ 的质因数（最多可以存在一个），一旦异或了它，就不会再有大于 $\sqrt{ A<em>{i} }$ 的位了（因为之前只有一个位是打开的，现在您已经异或了它）。现在，您可以简单地模拟对低阶质数（即质数 $≤\sqrt{ A</em>{i} }$）进行高斯消元，并单独处理那个最高位（如果存在的话）。这样，结合对低阶质数的位集合处理，就可以解决问题。</p>
<p>对于查询，让我们离线处理它们。让 $queries[l]$ 存储所有左端点为 $l$ 的查询。我们将从右侧将 $A_{i}$ 插入到我们的基向量中，其中 $i$ 从 $N-1$ 到 $0$。在我们插入索引 $i$ 处的元素之后，我们将回答所有在那里开始的查询，即 $queries[i]$ 中的查询。</p>
<p>我们将使用一个关于向量的线性组合的简单事实，但以聪明的方式来回答这些查询。假设我们将要尝试插入 $v$ 到我们的 $Basis$（如果结果是依赖的话，可能不会插入）。如果 $v=b<em>{1}+b</em>{2}+\dots+b<em>{k}$（其中 $b</em>{i}∈Basis$），那么我们可以删除 $b_i$ 中的一个，并将 $v$ 放在它的位置，保持基向量不变。因此，我们在插入时将使用这一事实。我们将尝试保留基向量中左端的索引，以回答尽可能多的查询。我们可以贪婪地实现这一点：在插入 $v$ 时，每当我们要与一些 $b_i$ 进行异或操作时，我们将首先检查哪个索引最小，如果 $v$ 的索引小于 $b_i$，我们将 $swap(b_i, v)$。如果最终进行了交换，那么 $v$ 将成为基向量的一部分（代替 $b_i$），并且我们将使用 $b_i$ 进行高斯消元。否则，我们将像正常情况一样继续进行。更多细节，请参考附加的代码。</p>
<p>现在，当我们回答左端点为 $i$ 的查询时，我们将拥有基向量 $A[i:N]$，其具有可能的最小索引。因此，对于一个查询 $i$ 到 $R$，我们只需要计算基向量中索引 $≤R$ 的数量。这可以很容易地使用一些 BIT 或 set 完成。</p>
<p>让 $K$ 表示 $\leq \sqrt{ A_{i} }$ 的质数的数量（$=225$）。我们为每个质数存储一个大小为 $K$ 的 [[bitset]] 。在进行高斯消元时，我们手动处理大位数，然后按照常规程序处理低阶质数；因此，插入 $A_i$ 花费 $O (\frac{K^2}{64})$ 的时间。之后，在 $O (log (N))$ 的时间内回答 $O (log (N))$ 中的查询。因此，总体复杂度是 $O \left( N⋅ \frac{k^2}{64}+Q⋅log (N) \right)$，由使用 [[bitset]] 的高斯消元支配。</p>
<p>Reference sol in C++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SQRTMAX = <span class="number">3162</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SMALL_PRIME_COUNT = <span class="number">225</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SMALL_PRIMES[] = &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">127</span>, <span class="number">131</span>, <span class="number">139</span>, <span class="number">151</span>, <span class="number">163</span>, <span class="number">167</span>, <span class="number">179</span>, <span class="number">191</span>, <span class="number">199</span>, <span class="number">211</span>, <span class="number">223</span>, <span class="number">227</span>, <span class="number">239</span>, <span class="number">251</span>, <span class="number">263</span>, <span class="number">271</span>, <span class="number">283</span>, <span class="number">307</span>, <span class="number">311</span>, <span class="number">331</span>, <span class="number">347</span>, <span class="number">359</span>, <span class="number">367</span>, <span class="number">379</span>, <span class="number">383</span>, <span class="number">419</span>, <span class="number">431</span>, <span class="number">439</span>, <span class="number">443</span>, <span class="number">463</span>, <span class="number">467</span>, <span class="number">479</span>, <span class="number">487</span>, <span class="number">491</span>, <span class="number">499</span>, <span class="number">503</span>, <span class="number">523</span>, <span class="number">547</span>, <span class="number">563</span>, <span class="number">571</span>, <span class="number">587</span>, <span class="number">599</span>, <span class="number">607</span>, <span class="number">619</span>, <span class="number">631</span>, <span class="number">643</span>, <span class="number">647</span>, <span class="number">659</span>, <span class="number">683</span>, <span class="number">691</span>, <span class="number">719</span>, <span class="number">727</span>, <span class="number">739</span>, <span class="number">743</span>, <span class="number">751</span>, <span class="number">787</span>, <span class="number">811</span>, <span class="number">823</span>, <span class="number">827</span>, <span class="number">839</span>, <span class="number">859</span>, <span class="number">863</span>, <span class="number">883</span>, <span class="number">887</span>, <span class="number">907</span>, <span class="number">911</span>, <span class="number">919</span>, <span class="number">947</span>, <span class="number">967</span>, <span class="number">971</span>, <span class="number">983</span>, <span class="number">991</span>, <span class="number">1019</span>, <span class="number">1031</span>, <span class="number">1039</span>, <span class="number">1051</span>, <span class="number">1063</span>, <span class="number">1087</span>, <span class="number">1091</span>, <span class="number">1103</span>, <span class="number">1123</span>, <span class="number">1151</span>, <span class="number">1163</span>, <span class="number">1171</span>, <span class="number">1187</span>, <span class="number">1223</span>, <span class="number">1231</span>, <span class="number">1259</span>, <span class="number">1279</span>, <span class="number">1283</span>, <span class="number">1291</span>, <span class="number">1303</span>, <span class="number">1307</span>, <span class="number">1319</span>, <span class="number">1327</span>, <span class="number">1367</span>, <span class="number">1399</span>, <span class="number">1423</span>, <span class="number">1427</span>, <span class="number">1439</span>, <span class="number">1447</span>, <span class="number">1451</span>, <span class="number">1459</span>, <span class="number">1471</span>, <span class="number">1483</span>, <span class="number">1487</span>, <span class="number">1499</span>, <span class="number">1511</span>, <span class="number">1523</span>, <span class="number">1531</span>, <span class="number">1543</span>, <span class="number">1559</span>, <span class="number">1567</span>, <span class="number">1571</span>, <span class="number">1579</span>, <span class="number">1583</span>, <span class="number">1607</span>, <span class="number">1619</span>, <span class="number">1627</span>, <span class="number">1663</span>, <span class="number">1667</span>, <span class="number">1699</span>, <span class="number">1723</span>, <span class="number">1747</span>, <span class="number">1759</span>, <span class="number">1783</span>, <span class="number">1787</span>, <span class="number">1811</span>, <span class="number">1823</span>, <span class="number">1831</span>, <span class="number">1847</span>, <span class="number">1867</span>, <span class="number">1871</span>, <span class="number">1879</span>, <span class="number">1907</span>, <span class="number">1931</span>, <span class="number">1951</span>, <span class="number">1979</span>, <span class="number">1987</span>, <span class="number">1999</span>, <span class="number">2003</span>, <span class="number">2011</span>, <span class="number">2027</span>, <span class="number">2039</span>, <span class="number">2063</span>, <span class="number">2083</span>, <span class="number">2087</span>, <span class="number">2099</span>, <span class="number">2111</span>, <span class="number">2131</span>, <span class="number">2143</span>, <span class="number">2179</span>, <span class="number">2203</span>, <span class="number">2207</span>, <span class="number">2239</span>, <span class="number">2243</span>, <span class="number">2251</span>, <span class="number">2267</span>, <span class="number">2287</span>, <span class="number">2311</span>, <span class="number">2339</span>, <span class="number">2347</span>, <span class="number">2351</span>, <span class="number">2371</span>, <span class="number">2383</span>, <span class="number">2399</span>, <span class="number">2411</span>, <span class="number">2423</span>, <span class="number">2447</span>, <span class="number">2459</span>, <span class="number">2467</span>, <span class="number">2503</span>, <span class="number">2531</span>, <span class="number">2539</span>, <span class="number">2543</span>, <span class="number">2551</span>, <span class="number">2579</span>, <span class="number">2591</span>, <span class="number">2647</span>, <span class="number">2659</span>, <span class="number">2663</span>, <span class="number">2671</span>, <span class="number">2683</span>, <span class="number">2687</span>, <span class="number">2699</span>, <span class="number">2707</span>, <span class="number">2711</span>, <span class="number">2719</span>, <span class="number">2731</span>, <span class="number">2767</span>, <span class="number">2791</span>, <span class="number">2803</span>, <span class="number">2819</span>, <span class="number">2843</span>, <span class="number">2851</span>, <span class="number">2879</span>, <span class="number">2887</span>, <span class="number">2903</span>, <span class="number">2927</span>, <span class="number">2939</span>, <span class="number">2963</span>, <span class="number">2971</span>, <span class="number">2999</span>, <span class="number">3011</span>, <span class="number">3019</span>, <span class="number">3023</span>, <span class="number">3067</span>, <span class="number">3079</span>, <span class="number">3083</span>, <span class="number">3119</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; SMALL_PRIME_ID, pow2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick1D</span> &#123; <span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Fenwick1D</span>(<span class="type">int</span> maxval) &#123;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size &lt; maxval) size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        T.<span class="built_in">clear</span>();</span><br><span class="line">        T.<span class="built_in">resize</span>(size+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> delta)</span> </span>&#123; <span class="comment">// assumes 1 &lt;= x &lt;= init_maxval</span></span><br><span class="line">        <span class="keyword">while</span> (x &lt;= size) &#123; T[x] += delta; x += x &amp; -x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span> </span>&#123; <span class="comment">// sum in the closed interval [x1,x2]</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        --x1;</span><br><span class="line">        <span class="keyword">while</span> (x2) &#123; res += T[x2]; x2 -= x2 &amp; -x2; &#125;</span><br><span class="line">        <span class="keyword">while</span> (x1) &#123; res -= T[x1]; x1 -= x1 &amp; -x1; &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> sum)</span> </span>&#123; <span class="comment">// largest z such that sum( [1,z] ) &lt;= sum</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>, bitMask = size;</span><br><span class="line">        <span class="keyword">while</span> (bitMask &amp;&amp; (idx &lt; size)) &#123;</span><br><span class="line">            <span class="type">int</span> tIdx = idx + bitMask;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= T[tIdx]) &#123; idx=tIdx; sum -= T[tIdx]; &#125;</span><br><span class="line">            bitMask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SMALL_PRIME_ID.<span class="built_in">clear</span>();</span><br><span class="line">    SMALL_PRIME_ID.<span class="built_in">resize</span>(SQRTMAX+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SMALL_PRIME_COUNT; ++i) SMALL_PRIME_ID[ SMALL_PRIMES[i] ] = i;</span><br><span class="line">    pow2.<span class="built_in">clear</span>();</span><br><span class="line">    pow2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100005</span>; ++i) pow2.<span class="built_in">push_back</span>( (pow2.<span class="built_in">back</span>()*<span class="number">2</span>) % <span class="number">998244353</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">signature</span> &#123;</span><br><span class="line">    bitset&lt; SMALL_PRIME_COUNT &gt; small_bits;</span><br><span class="line">    <span class="type">int</span> large_bit;</span><br><span class="line">    <span class="built_in">signature</span>() : <span class="built_in">large_bit</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">highest_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (large_bit != <span class="number">-1</span>) <span class="keyword">return</span> large_bit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=SMALL_PRIME_COUNT<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) <span class="keyword">if</span> (small_bits.<span class="built_in">test</span>(i)) <span class="keyword">return</span> SMALL_PRIMES[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_xor</span><span class="params">(<span class="type">const</span> signature &amp;other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other.large_bit != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (large_bit != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">assert</span>( large_bit == other.large_bit );</span><br><span class="line">                large_bit = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                large_bit = other.large_bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small_bits ^= other.small_bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="type">const</span> signature &amp;S) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int max = SMALL_PRIME_COUNT - 1;</span></span><br><span class="line"><span class="comment">    while (max &gt; 0 &amp;&amp; !S.small_bits.test(max)) --max;</span></span><br><span class="line"><span class="comment">    for (int i=0; i&lt;=max; ++i) out &lt;&lt; int( S.small_bits.test(i) );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (S.large_bit != <span class="number">-1</span>) out &lt;&lt; S.large_bit &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">9</span>; i&gt;=<span class="number">0</span>; --i) out &lt;&lt; <span class="built_in">int</span>(S.small_bits.<span class="built_in">test</span>(i));</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> query &amp;A, <span class="type">const</span> query &amp;B) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.l != B.l) <span class="keyword">return</span> A.l &gt; B.l;</span><br><span class="line">    <span class="keyword">return</span> A.r &lt; B.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signature <span class="title">get_signature</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    signature answer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d=<span class="number">2</span>; d*d&lt;=N; ++d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N % d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (N % d == <span class="number">0</span>) &#123; ++cnt; N /= d; &#125;</span><br><span class="line">        <span class="keyword">if</span> (d % <span class="number">4</span> != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        answer.small_bits.<span class="built_in">set</span>( SMALL_PRIME_ID[d] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">1</span> &amp;&amp; N % <span class="number">4</span> == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt; SQRTMAX) answer.large_bit = N; <span class="keyword">else</span> answer.small_bits.<span class="built_in">set</span>( SMALL_PRIME_ID[N] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaleOfTwoSquares</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt; Aprefix, <span class="type">int</span> Q, vector&lt;<span class="type">int</span>&gt; Lprefix, vector&lt;<span class="type">int</span>&gt; Rprefix, <span class="type">int</span> seed)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> state = seed;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A = Aprefix;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">int</span>(A.<span class="built_in">size</span>()) &lt; N) &#123;</span><br><span class="line">            state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) % (<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">            A.<span class="built_in">push_back</span>(<span class="number">1</span> + (state % <span class="number">10000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">20</span>) <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;N; ++n) cout &lt;&lt; A[n] &lt;&lt; <span class="string">&quot;, &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; L = Lprefix, R = Rprefix;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">int</span>(L.<span class="built_in">size</span>()) &lt; Q) &#123;</span><br><span class="line">            state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) % (<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">            <span class="type">int</span> x = state % N;</span><br><span class="line">            state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) % (<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">            <span class="type">int</span> y = state % N;</span><br><span class="line">            L.<span class="built_in">push_back</span>( <span class="built_in">min</span>(x,y) );</span><br><span class="line">            R.<span class="built_in">push_back</span>( <span class="built_in">max</span>(x,y) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Q &lt;= <span class="number">20</span>) <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;Q; ++n) cout &lt;&lt; L[n] &lt;&lt; <span class="string">&quot;, &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (Q &lt;= <span class="number">20</span>) <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;Q; ++n) cout &lt;&lt; R[n] &lt;&lt; <span class="string">&quot;, &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        vector&lt;signature&gt; B;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;N; ++n) B.<span class="built_in">push_back</span>( <span class="built_in">get_signature</span>(A[n]) );</span><br><span class="line"></span><br><span class="line">        vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">query_by_L</span>(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q=<span class="number">0</span>; q&lt;Q; ++q) query_by_L[ L[q] ].<span class="built_in">push_back</span>( R[q] );</span><br><span class="line"></span><br><span class="line">        <span class="function">Fenwick1D <span class="title">InBase</span><span class="params">(N+<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; base_by_highest_prime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n=N<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n) &#123;</span><br><span class="line">            <span class="comment">// two dummy updates</span></span><br><span class="line">            InBase.<span class="built_in">update</span>(N+<span class="number">1</span>,+<span class="number">1</span>);</span><br><span class="line">            InBase.<span class="built_in">update</span>(N+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// add number A[n] to the base</span></span><br><span class="line">            <span class="keyword">if</span> (B[n].<span class="built_in">highest_prime</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">                InBase.<span class="built_in">update</span>(n+<span class="number">1</span>,+<span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> where = n;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> p = B[where].<span class="built_in">highest_prime</span>();</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">                        InBase.<span class="built_in">update</span>(where+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!base_by_highest_prime.<span class="built_in">count</span>(p)) &#123;</span><br><span class="line">                        base_by_highest_prime[p] = where;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> nxt = base_by_highest_prime[p];</span><br><span class="line">                    <span class="keyword">if</span> (nxt &gt; where) &#123;</span><br><span class="line">                        base_by_highest_prime[p] = where;</span><br><span class="line">                        B[nxt].<span class="built_in">do_xor</span>( B[where] );</span><br><span class="line">                        where = nxt;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        B[where].<span class="built_in">do_xor</span>( B[nxt] );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// answer queries that begin here</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r : query_by_L[n]) &#123;</span><br><span class="line">                <span class="type">int</span> length = r-n+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> base_size = InBase.<span class="built_in">sum</span>(n+<span class="number">1</span>,r+<span class="number">1</span>);</span><br><span class="line">                answer += pow2[length-base_size] - <span class="number">1</span>;</span><br><span class="line">                answer %= <span class="number">998244353</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>div2</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈基环树（环套树）</title>
    <url>/posts/b9ef90d5/</url>
    <content><![CDATA[<h1 id="浅谈基环树（环套树）"><a href="#浅谈基环树（环套树）" class="headerlink" title="浅谈基环树（环套树）"></a>浅谈基环树（环套树）</h1><p>本篇随笔简单讲解一下算法竞赛中的基环树。也叫环套树。</p>
<h2 id="一、基环树概念"><a href="#一、基环树概念" class="headerlink" title="一、基环树概念"></a>一、基环树概念</h2><p>其实我个人更喜欢叫它基环树。更好理解。</p>
<p>它的标准定义是：具有 N 个点 N 条边的连通图。</p>
<p>如果不保证联通，它就会成为基环树森林。</p>
<p>上张图直观理解一下。</p>
<p><img data-src="https://s1.ax1x.com/2020/10/14/05B5M6.png" alt=""></p>
<p>这就是一棵基环树。</p>
<p>如果我们把中间那个醒目的环断开任意一条边，它就会成为一棵树，如果我们把这个环全部断掉，就会成为一个森林。</p>
<h2 id="二、内向树和外向树"><a href="#二、内向树和外向树" class="headerlink" title="二、内向树和外向树"></a>二、内向树和外向树</h2><p>~啥？树还会害羞么？~</p>
<p>所谓内向树的定义是每个点有且只有一条出边。也就是这棵树给人的大体感觉是向内的。</p>
<p>所谓外向树的定义是每个点有且只有一条入边。也就是这棵树给人的大题感觉是外向的。</p>
<p>比如上面的基环树，变成内向树就是：</p>
<p><img data-src="https://s1.ax1x.com/2020/10/14/05Dxh9.png" alt=""></p>
<p>变成外向树就是：</p>
<p><img data-src="https://s1.ax1x.com/2020/10/14/05rSpR.png" alt=""></p>
<p>嗯，也就是基环树变成有向图的一种子定义。</p>
<h2 id="三、基环树的处理"><a href="#三、基环树的处理" class="headerlink" title="三、基环树的处理"></a>三、基环树的处理</h2><p>根据上面的定义介绍，我们可以感觉到，基环树虽然被单独拿出来讨论，但是其本质上还是一个比较简单且好理解的数据结构之一。所以它只能适当地提升题目难度，并不能说一个树的题变成基环树就大大增强了。</p>
<p>一些经典例题有：</p>
<p>基环树直径、基环树两点之间距离，基环树 DP，等。</p>
<p>这些模型的解决通法一般是：</p>
<p>断环成树，然后将若干棵树处理好之后，再考虑环对答案的影响。也就是将环、树分开讨论解决问题。这时，用” 环套树 “这个名词来形容基环树，很是容易理解。</p>
<p>比如例题：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/13756109.html">ZJOI2008 骑士</a><br>[[P2607 骑士 - 洛谷]]</p>
<p>这道题是基环树 DP 的题目，在这道题中，我们对每一棵基环树断掉环上的一条边，然后对断开的两个点分别跑树形 DP，就可以得到正确的答案。</p>
<p><strong>总的来说，基环树的一种常用处理方式是” 断环 “。</strong></p>
<p>再比如例题：</p>
<p>IOI2008 岛屿</p>
<p>这道题要求基环树的最长链。</p>
<p>基环树的最长链有两种情况：</p>
<p>第一种是在某棵树里，不经过环。</p>
<p>第二种是经过环。</p>
<p>所以我们可以先用一次 DFS 找出环，在每个环上节点出发处理树上的最长路径，并计算出从根节点最远到达节点距离根节点的距离。显然，如果经过环的话，肯定要经过这个最大的距离。</p>
<p>所以比较即可。</p>
<p><strong>总的来说，基环树的另一种常用处理方式是分类讨论。</strong></p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>整数环以及丢番图方程</title>
    <url>/posts/19fa0856/</url>
    <content><![CDATA[<p><strong>定义</strong> 带余除法<br>对于给定的任意整数 $a,b$a,b 其中 $b&gt;0$b&gt;0，存在唯一的整数对 $q,r$q,r 使得 $a=bq+r$a=bq+r 且 $r\in [0,b-1]$r\in [0,b-1]。</p>
<p>证明用到良序原则（自然数的非空子集必然存在一个最小元素）。</p>
<p>先考虑存在性的证明。构造集合 $S={a-bk|k\in \mathbb Z,a-bk\ge 0}$，那么必然存在一个最小元 $r$ ，满足 $a-qb=r,a=qb+r$ a-qb=r,a=qb+r。接下来证明 $r&lt;b$ r&lt;b，这很显然，因为如果 $r\ge b$  则存在 $r’=r-b\ge 0$ r’=r-b\ge 0，也在集合 $S$  中，矛盾。接下来证明唯一性。由于 $r\ge 0$ ，所以只存在唯一的 $r$ r 满足 $0\le r&lt;b$ 0\le r&lt;b，那么也就只有唯一 $q$ 。</p>
<p><strong>定义</strong> 整除</p>
<p>若 $a=bq$a=bq 则称 $b$b 整除 $a$a，记作 $b\mid a$b\mid a。称 $b$b 是 $a$a 的约数。整除具有传递性。</p>
<p><strong>定义</strong> 最大公约数</p>
<p>对于两个数 $a,b$a,b，如果 $d\mid a$d\mid a 且 $d\mid b$d\mid b 则称其为公约数，其中最大的称为最大公约数记作 $\gcd(a,b)$\gcd(a,b)。</p>
<p><strong>定义</strong> 素数 只有 $1$1 和其本身两个约数的数是素数，除了 $1$1 和其本身还有其他的约数的数是合数，$1$1 和 $0$0 既不是素数也不是合数。</p>
<p><strong>定理</strong> 唯一分解定理</p>
<p>任意正整数 $n=\prod\limits<em>{i=1}^{m}p</em>{i}^{c<em>i}$n=$\prod\limits</em>{i=1}^{m}p_{i}^{c_i}$，其中 $p_i$p_i 是质数。</p>
<p><strong>定理</strong> 欧几里德算法</p>
<p>$\gcd(a,b)=\gcd(b,a\bmod b)$\gcd(a,b)=\gcd(b,a\bmod b)。其中 $a\bmod b$a\bmod b 代表 $a$a 带余除法 $b$b 所得的余数 $r$r。</p>
<p>证明之前先证一个引理，$\gcd(a,b)=\gcd(b,a-b)$\gcd(a,b)=\gcd(b,a-b)。假设 $\gcd(a,b)=d$\gcd(a,b)=d，设 $a=ud,b=vd,\gcd(u,v)=1$a=ud,b=vd,\gcd(u,v)=1，那么 $a-b=d(u-v)$a-b=d(u-v)。所以 $\gcd(b,a-b)=d\gcd(v,u-v)=d$\gcd(b,a-b)=d\gcd(v,u-v)=d。这里用反证法，如果 $\gcd(v,u-v)=k&gt;1$\gcd(v,u-v)=k&gt;1，那么设 $v=kx,(u-v)=ky$v=kx,(u-v)=ky 则 $u=k(x+y)$u=k(x+y)，那么 $\gcd(u,v)$\gcd(u,v) 至少是 $k$k。这和 $\gcd(u,v)=1$\gcd(u,v)=1 矛盾。</p>
<p>有了这个引理之后，根据带余除法的定义，就可以证明该定理了。</p>
<p><strong>定理</strong> 扩展欧几里德算法</p>
<p><strong>定理</strong> 裴蜀定理 方程 $ax+by=\gcd(a,b)$ax+by=\gcd(a,b) 存在整数解 $x=s,y=t$x=s,y=t。</p>
<p>纯数学证明可以构造集合并继续应用良序定理，这里给出扩展欧几里德算法的直接构造。</p>
<p>设 $\gcd(a,b)=d$\gcd(a,b)=d，欧几里得算法的最后一步会得到两个数 $d, 0$d, 0，然后令 $s=1,t=0$s=1,t=0，就得到了一组解 $d+0=d$d+0=d。假设当前我们要求一组解满足 $ax+by=d$ax+by=d，且我们已经得到了一组解满足 $bs+(a\bmod b)t=d$bs+(a\bmod b)t=d。拆开来得到 $at+b(s-\lfloor\frac{a}{b}t)=d$at+b(s-\lfloor\frac{a}{b}t)=d，所以我们可以令 $s’=t, t’=s-\lfloor\frac{a}{b}\rfloor b t$s’=t, t’=s-\lfloor\frac{a}{b}\rfloor b t 而得到一组解 $s’,t’$s’,t’。一直这么推下去就可以得到最后的答案，其实这是一个高斯消元的过程。</p>
<p><strong>定义</strong> 同余</p>
<p>如果整数 $a,b$a,b 和 $m$m 满足 $m\mid (a-b)$m\mid (a-b)，则称 $a,b$a,b 模 $m$m 同余。记作 $a\equiv b\pmod m$a\equiv b\pmod m。</p>
<p><strong>命题</strong> 如果 $a_1\equiv b_1\pmod m$a_1\equiv b_1\pmod m 而且 $a_2\equiv b_2\pmod m$a_2\equiv b_2\pmod m，则 $a_1\pm a_2\equiv b1\pm b2 \pmod m$a_1\pm a_2\equiv b1\pm b2 \pmod m 且 $a_1a_2\equiv b_1b_2 \pmod m$a_1a_2\equiv b_1b_2 \pmod m。</p>
<p><strong>定理</strong> 消去律</p>
<p>设 $a,b,c\in \mathbb Z$a,b,c\in \mathbb Z，$m$m 是一个正整数。如果 $\gcd(c,m)=1$\gcd(c,m)=1，且 $ac\equiv bc \pmod m$ac\equiv bc \pmod m，则 $a\equiv b \pmod m$a\equiv b \pmod m。</p>
<p>$m\mid (ac-bc)=c(a-b)$m\mid (ac-bc)=c(a-b)，由于 $\gcd(c,m)=1$\gcd(c,m)=1 所以 $m\mid a-b$m\mid a-b。</p>
<p><strong>定义</strong> 乘法逆元</p>
<p>$a^{-1}$a^{-1} 满足 $aa^{-1}\equiv 1\pmod m$aa^{-1}\equiv 1\pmod m。显然乘法逆元不一定存在。</p>
<p>求关于 $x$x 的同余方程 $ax\equiv 1\pmod b$ax\equiv 1\pmod b 的最小正整数解。</p>
<p>也就是 $ax+by=1$ax+by=1 的最小正整数解，运用扩展欧几里德算法即可。</p>
<p>求 $1,2\cdots,n$1,2\cdots,n 模 $p$p 的逆元。</p>
<p>设 $p=ki+j, 0 \le j &lt; i$p=ki+j, 0 \le j &lt; i。</p>
<script type="math/tex; mode=display">ki+j \equiv 0 \pmod p\\<br>(ki+j)i^{-1}j^{-1} \equiv 0 \pmod p\\<br>kj^{-1}+i^{-1} \equiv 0 \pmod p\\<br>i^{-1} \equiv -kj^{-1} \pmod p\\<br>i^{-1} \equiv (p-[p/i]) \times (p \mod i)^{-1} \pmod p\\</script><p>$$</p>
<p><strong>定义</strong> 等价类</p>
<p>显然，同余关系是一种等价关系。如果有一种等价关系定义在集合 $S$S 上，则该等价关系会把集合 $S$S 划分为不相交的子<br>集，这些子集我们称为等价类。</p>
<p><strong>定义</strong> 同余类</p>
<p>考虑整数集合 $\mathbb Z$\mathbb Z，设 $m$m 为正整数，则模 $m$m 的同余关系把 $\mathbb Z$\mathbb Z 划分为 $m$m 个等价类。任意整数 $a$a 所落在的等价类记为 $[a]_m$[a]_m，即所有模 $m$m 同余的整数形成的集合。</p>
<p>模 $m$m 同余类的集合记为 $\mathbb Z/m\mathbb Z$\mathbb Z/m\mathbb Z，该集合恰好有 $m$m 个元素，即：$\mathbb Z/m\mathbb Z={[0]_m,[1]_m,\dots,[m − 1]_m}$\mathbb Z/m\mathbb Z={[0]_m,[1]_m,\dots,[m − 1]_m}。</p>
<p><strong>定义</strong> 最小剩余系</p>
<p>$\mathbb Z/m\mathbb Z$\mathbb Z/m\mathbb Z 的所有最小非负代表元的集合 ${0,1,2,\dots,m-1}${0,1,2,\dots,m-1}。</p>
<p><strong>定理</strong> 费马小定理</p>
<p>$a^{p-1}\equiv 1\pmod p$a^{p-1}\equiv 1\pmod p。</p>
<p><strong>引理</strong> $a\times i\bmod p,1\le a&lt;i$a\times i\bmod p,1\le a&lt;i 是 $1,2,\dots,p-1$1,2,\dots,p-1 的一个置换。</p>
<p>反证法，若存在 $ai\equiv aj\pmod p$ai\equiv aj\pmod p，则 $i\equiv j\pmod p$i\equiv j\pmod p 矛盾。</p>
<p>下证费马小定理</p>
<p>$\prod<em>{i=1}^{p-1}i\equiv \prod</em>{i=1}^{p-1}ai=a^{p-1}\prod{i=1}^{p-1}i\pmod p$\prod<em>{i=1}^{p-1}i\equiv \prod</em>{i=1}^{p-1}ai=a^{p-1}\prod{i=1}^{p-1}i\pmod p</p>
<p>所以显然有 $a^{p-1}\equiv 1\pmod p$a^{p-1}\equiv 1\pmod p。</p>
<p><strong>定义</strong> 欧拉函数</p>
<p>记 $1,2,\dots, n$1,2,\dots, n 中与 $n$n 互质的数的个数为 $\varphi(n)$\varphi(n)，即为欧拉函数。</p>
<p><strong>命题</strong> 若 $p$p 是素数，$\varphi(p)=p-1,\varphi(p^c)=p^{c-1}(p-1)$\varphi(p)=p-1,\varphi(p^c)=p^{c-1}(p-1)。</p>
<p>显然 $p$p 的剩余系里都与 $p$p 互质，那么每 $p$p 个数里会有 $p-1$p-1 个互质，于是 $\varphi(p^c)=p^c\frac{p-1}{p}$\varphi(p^c)=p^c\frac{p-1}{p}。</p>
<p><strong>定理</strong> 欧拉函数是积性函数，即 $\gcd(a,b)=1\Rightarrow \varphi(ab)=\varphi(a)\varphi(b)$\gcd(a,b)=1\Rightarrow \varphi(ab)=\varphi(a)\varphi(b)。</p>
<p>这其实可以用剩余系得思想来推，即证明 $\mathbb Z/a\mathbb Z\times \mathbb Z/b\mathbb Z$\mathbb Z/a\mathbb Z\times \mathbb Z/b\mathbb Z 双射 $\mathbb Z/ab\mathbb Z$\mathbb Z/ab\mathbb Z。当然还可以用容斥的角度，类似上面的证明。还有一个比较巧妙的用了狄利克雷卷积，这里就不过论述。</p>
<p><strong>命题</strong> $\sum\limits<em>{d|n} \varphi(d) = n$\sum\limits</em>{d|n} \varphi(d) = n</p>
<p>${1,2,\dots,n}=\cup<em>{d\mid n}{x\in [1,n]\cap \mathbb Z|\gcd(x,n)=d}${1,2,\dots,n}=\cup</em>{d\mid n}{x\in [1,n]\cap \mathbb Z|\gcd(x,n)=d}，而后者刚好就是 $\varphi(\frac{n}{d})$\varphi(\frac{n}{d})。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zcr-blog/p/14897337.html">欧拉函数的应用</a></p>
<p><strong>定理</strong> 欧拉定理</p>
<p>$a^{\varphi(m)}\equiv 1\pmod m,\gcd(a,m)=1$a^{\varphi(m)}\equiv 1\pmod m,\gcd(a,m)=1。</p>
<p><strong>定义</strong> 简化剩余系</p>
<p>所有和 $m$m 互质的数构成的剩余类的集合。</p>
<p>证明欧拉定理等价于证明简化剩余系 $\times a$\times a 是简化剩余系的置换，其实和上面的反证法一模一样。</p>
<p><strong>定理</strong> 扩展欧拉定理</p>
<p><img data-src="https://pic4.zhimg.com/v2-7fc1f566850ef4450749aeab7739859b_b.png" alt=""></p>
<p>好复杂，但是可以根据欧拉定理记忆，先丢一个<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ywwyww/p/8510981.html">证明</a>。</p>
<p><strong>定理</strong> 素数的整除性</p>
<p>设 $a,b\in \mathbb Z$a,b\in \mathbb Z，$p$p 为素数。如果 $p\mid ab$p\mid ab，则 $p\mid a$p\mid a 或 $p\mid b$p\mid b。</p>
<p>推论，$n&gt;0,n\mid ab,\gcd(n,a)=1\Rightarrow n\mid b$n&gt;0,n\mid ab,\gcd(n,a)=1\Rightarrow n\mid b。</p>
<p><strong>定理</strong> 欧几里得定理</p>
<p>素数有无穷多。</p>
<p>使用反证法。设素数有穷，$p<em>1,p_2,\dots p</em>{n}$p<em>1,p_2,\dots p</em>{n}，构造 $N=1+\prod\limits<em>{i=1}^{n}p_i$N=1+\prod\limits</em>{i=1}^{n}p_i，这个数显然不能被任意一个素数整除，那么也就不能被任意一个数整除，所以它也是一个素数。</p>
<p><strong>定理</strong> 狄利克雷定理</p>
<p>存在无穷多的素数满足 $p\equiv a\pmod m$p\equiv a\pmod m，其中 $\gcd(a,m)=1$\gcd(a,m)=1。</p>
<p><strong>定理</strong> 素数定理</p>
<p>记 $\pi(x)$\pi(x) 为素数个数，则 $\lim\limits<em>{x\to \infty}\frac{\pi(x)}{x/\ln x}=1$\lim\limits</em>{x\to \infty}\frac{\pi(x)}{x/\ln x}=1</p>
<p><strong>定理</strong> 威尔逊定理</p>
<p>$p$p 是素数的充要条件是 $(p-1)! \equiv -1 \pmod p$(p-1)! \equiv -1 \pmod p</p>
<p>$p=1$p=1 时显然不行。</p>
<p>先证充分性，对于 $2\le a&lt;b\le p-2$2\le a&lt;b\le p-2 有 $a^{-1}\ne b^{-1}$a^{-1}\ne b^{-1}，我们只需将 $a\in[2,p-2]$a\in[2,p-2] 与 $a^{-1}$a^{-1} 配对即可，充分性得证。</p>
<p>必要性显然，若 $p$p 为合数则取一个质因子即可。</p>
<p><strong>定理</strong> Lucas 定理</p>
<p>$p$p 是质数。</p>
<p>$\binom{n}{m}\bmod p=\binom{n/p}{m/p}\times \binom{n\bmod p}{m\bmod p}\bmod p$</p>
<p><strong>定理</strong> 库默尔定理</p>
<p>$p$p 在 $\binom{n}{m}$\binom{n}{m} 中的位数等于 $n+m$n+m 在 $p$p 进制下进位的次数。</p>
<p><strong>定理</strong> 扩展 Lucas 定理</p>
<p>等价于求</p>
<p>$\binom{n}{m}\bmod p^{c}$\binom{n}{m}\bmod p^{c}</p>
<p>考虑由于逆元不一定存在所有不能直接求逆元，把 $p$p 的倍数全部除掉，得到 $n!=p^{[n/p]}([n/p])!\prod\dots$n!=p^{[n/p]}([n/p])!\prod\dots，后面的东西显然可以预处理。前面的部分递归做即可。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.luogu.com.cn/record/47187917">code</a></p>
<p><strong>定义</strong> 素性测试</p>
<p>素性测试问题，即如何判断一个大的奇整数 n 是否素数。</p>
<p><strong>试除法</strong></p>
<p>枚举 $2\sim n-1$2\sim n-1，看看能不能整除 $n$n。这是最暴力的方法，时间复杂度 $O(n)$O(n)</p>
<p>对上述算法优化，约数是成对出现的所以枚举到 $\sqrt{n}$\sqrt{n} 即可，时间复杂度 $O(\sqrt{n})$O(\sqrt{n})。</p>
<p><strong>Miller-Rabin 素性测试</strong></p>
<p>费马小定理的逆定理虽然不成立，但是可以勉强用来判断。而满足费马小定理的合数称作卡麦尔数。</p>
<p><strong>定理</strong> 二次探测定理</p>
<p>如果 $p$p 为质数，则 $x^2 \equiv 1 \mod p$x^2 \equiv 1 \mod p 且 $x \in [1, p-1]$x \in [1, p-1] 的解为 $x=1,p-1$x=1,p-1。</p>
<p>我们可以在费马小定理后以此判断 $a^{(p-1)/2},a^{(p-1)/4}$a^{(p-1)/2},a^{(p-1)/4} 是不是 $1/-1$1/-1。</p>
<p>已经证明若随机选择 $k$k 个底数则这样做出现伪素数的概率不大于 $\frac{1}{4^k}$\frac{1}{4^k}。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//paste.ubuntu.com/p/p6Fkx3Snzf/">code</a></p>
<p><strong>定义</strong> 原根</p>
<p>对于群 $\mathbb{Z}_n^{<em>}$\mathbb{Z}_n^{</em>} 是循环群，则称其生成元是 $n$n 的原根。即满足阶是 $\varphi(n)$\varphi(n) 的元素 $g$g。</p>
<p>满足 $n=2,4,p^a,2p^a$n=2,4,p^a,2p^a 的群 $\mathbb{Z}_n^{<em>}$\mathbb{Z}_n^{</em>} 都是循环群。</p>
<p>原根可以生成群内所有元素，原根有 $\varphi(\varphi(n))$\varphi(\varphi(n)) 个。</p>
<p><strong>定理</strong> 原根判定定理</p>
<p>$g$g 是原根，当且仅当 $\forall i,g^{\frac{\varphi(n)}{p_i}}\not\equiv 1\pmod {\varphi(n)},\varphi(n)=\prod p_i^{c_i}$\forall i,g^{\frac{\varphi(n)}{p_i}}\not\equiv 1\pmod {\varphi(n)},\varphi(n)=\prod p_i^{c_i}。</p>
<p>最小原根的数量级是 $n^{0.25}$n^{0.25} 的。</p>
<p><strong>定理</strong> 中国剩余定理</p>
<p>物不知数问题：</p>
<p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？<br>化解为线性方程组来表示即为：</p>
<p>$\begin{cases}x \equiv 2 \pmod 3\x \equiv 3 \pmod 5\x \equiv 2 \pmod 7\\end{cases}$\begin{cases}x \equiv 2 \pmod 3\x \equiv 3 \pmod 5\x \equiv 2 \pmod 7\\end{cases}</p>
<p>对于这个方程组我们可以对于每个方程构造一个数使得其模其它模数为 0，模自己的模数为答案。</p>
<p>即对于上面的方程可以构造：</p>
<p>$\begin{cases}a_1=35\a_2=63\a_3=30\\end{cases}$\begin{cases}a_1=35\a_2=63\a_3=30\\end{cases}</p>
<p>全部加起来即可得到一组特解 $x_0=128$x_0=128。然后得到通解 $x=x_0+Mt, t \in \mathbb{Z}$x=x_0+Mt, t \in \mathbb{Z}。$M$M 是模数的最小公倍数。</p>
<p>可以得到最小正整数解：$x=23$x=23。</p>
<p>通过这个例子我们可以得到下面的结论：</p>
<p>如果模数两两互素，设 $M=\Pi<em>{i=1}^{n}m_i, M_i=\frac{M}{m_i}$M=\Pi</em>{i=1}^{n}m<em>i, M_i=\frac{M}{m_i}。根据古人的智慧我们可以构造出一个特解：$x_0=\sum\limits</em>{i=1}^{n}b<em>iM_i{M_i}^{-1}$x_0=\sum\limits</em>{i=1}^{n}b_iM_i{M_i}^{-1}。</p>
<p>容易证明这个特解是对的，然后我们就可以得到通解：$x=x0+M$x=x0+M。</p>
<p>多数情况下模数不是质数，所以要用 exgcd 求逆元。</p>
<p><strong>定理</strong> 扩展中国剩余定理</p>
<p>这个时候，我们就要每个方程轮流按顺序求解。</p>
<p>假设我们已经求出一个解 $x=x_0+Mt, t \in \mathbb{Z}$x=x_0+Mt, t \in \mathbb{Z}。这个解满足前 $i-1$i-1 个方程。现在我们将其和第 $i$i 个方程合并。</p>
<p>具体操作就是将其代入第 $i$i 个方程来解出得到未知数 $t$t 的一个通解。</p>
<p>设第 $i$i 个方程是形如 $x \equiv a \pmod b$x \equiv a \pmod b 的。</p>
<p>解方程的过程：</p>
<p>$x_0+Mt \equiv a \pmod b$x_0+Mt \equiv a \pmod b</p>
<p>$Mt \equiv a - x_0 \pmod b$Mt \equiv a - x_0 \pmod b</p>
<p>如果这个方程无解则整个方程组无解。</p>
<p>设 $g=\gcd(M,b)$g=\gcd(M,b)</p>
<p>解得：$t=t_0+\frac{b}{g}t’, t’ \in \mathbb{Z}$t=t_0+\frac{b}{g}t’, t’ \in \mathbb{Z}。</p>
<p>带回 $x$x 的解，得：$x=x_0+M(t_0+\frac{b}{g}t’)=x_0+Mt_0+lcm(M,b)t’,t’ \in \mathbb{Z}$x=x_0+M(t_0+\frac{b}{g}t’)=x_0+Mt_0+lcm(M,b)t’,t’ \in \mathbb{Z}。</p>
<p>将 $x_0$x_0 更新为 $x_0+Mt_0$x_0+Mt_0，$M$M 更新为 $lcm(M,b)$lcm(M,b) 即可。</p>
<p>第一个方程显然可以得到一组解 $x=a+bt, t \in \mathbb{Z}$x=a+bt, t \in \mathbb{Z}</p>
<p><strong>定义</strong> 二次剩余</p>
<p>设 $p$p 是奇素数，$a$a 是与 $p$p 互质的整数，询问是否存在 $x$x 使得 $x^2\equiv a\pmod p$x^2\equiv a\pmod p。</p>
<p><strong>定义</strong> 勒让德符号</p>
<p>定义 $a\bmod p$a\bmod p 的勒让德符号为：</p>
<p>$\left(\frac{a}{p}\right) =\begin{cases}1(exist)\-1(not)\0(p\mid a)\end{cases}$\left(\frac{a}{p}\right) =\begin{cases}1(exist)\-1(not)\0(p\mid a)\end{cases}</p>
<p><strong>定义</strong> 欧拉准则</p>
<p>$\left(\frac{a}{p}\right)\equiv a^{\frac{p-1}{2}}\pmod p$\left(\frac{a}{p}\right)\equiv a^{\frac{p-1}{2}}\pmod p</p>
<p>当 $\left(\frac{a}{p}\right)=1$\left(\frac{a}{p}\right)=1 时，$\exists x,x^2\equiv a,(x^2)^{(p-1)/2}\equiv 1\Rightarrow a^{\frac{p-1}{2}}\equiv 1$\exists x,x^2\equiv a,(x^2)^{(p-1)/2}\equiv 1\Rightarrow a^{\frac{p-1}{2}}\equiv 1。</p>
<p>否则，$a^{(p-1)/2}-1\not\equiv 0$a^{(p-1)/2}-1\not\equiv 0，又 $0\equiv a^{p-1}-1=(a^{(p-1)/2}-1)(a^{(p-1)/2}+1)\Rightarrow a^{(p-1)/2}+1\equiv 0$0\equiv a^{p-1}-1=(a^{(p-1)/2}-1)(a^{(p-1)/2}+1)\Rightarrow a^{(p-1)/2}+1\equiv 0。</p>
<p><strong>推论</strong></p>
<p>设 $p$p 是奇素数，则</p>
<p>$\left(\frac{-1}{p}\right)=\begin{cases} -1&amp;(p\bmod 4=-1)\ 1&amp;(p\bmod 4=1)\\end{cases}$\left(\frac{-1}{p}\right)=\begin{cases} -1&amp;(p\bmod 4=-1)\ 1&amp;(p\bmod 4=1)\\end{cases}</p>
<p><strong>定理</strong> 二次互反律</p>
<p>$\left(\frac{p}{q}\right)\left(\frac{q}{p}\right)=(-1)^{\frac{(p-1)(q-1)}{4}}$\left(\frac{p}{q}\right)\left(\frac{q}{p}\right)=(-1)^{\frac{(p-1)(q-1)}{4}}</p>
<p><strong>定理</strong> Cipolla 算法</p>
<p>我们随机一个 $n$n，令 $\omega=\sqrt{n^2-a}$\omega=\sqrt{n^2-a}。将数系扩充成 $\mathbb{F<em>\omega}$\mathbb{F</em>\omega}，相当于复数里面的 $i$i。我们反复随机 $n$n，直到 $n^2-a$n^2-a 不是一个二次剩余。然后大概可以证明这样的 $n$n 的大概有一半，所以期望随机二次既可以随机出一个，然后答案就是 $(n+\omega)^{\frac{p+1}{2}}$(n+\omega)^{\frac{p+1}{2}}。</p>
<p>证明先考虑两个引理：</p>
<p>$\omega^p=-\omega\<br>a^p+b^p\equiv (a+b)^p\pmod p$\omega^p=-\omega\<br>a^p+b^p\equiv (a+b)^p\pmod p</p>
<p>第一个考虑拆成 $(\omega^2)^{\frac{p-1}{2}}\times \omega$(\omega^2)^{\frac{p-1}{2}}\times \omega，第二个考虑二项式定理展开。</p>
<p>然后这个证明就很显然了，直接暴力平方展开然后替换，最后是一个平方差的形式，相信大家都会。</p>
<p>显然 $x,-x$x,-x 都是二次剩余。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.luogu.com.cn/record/47543229">提交记录</a></p>
<p><strong>定义</strong> 离散对数</p>
<p>是一个整数 $x$x 对于给定的 $a,b,m$a,b,m 满足下面的方程：</p>
<p>$a^{x}\equiv b\pmod m$a^{x}\equiv b\pmod m</p>
<p>记作 $x=\log<em>{a}{b}$x=\log</em>{a}{b}。通常情况先我们把这叫做 【阶】，$\text{index}$\text{index}。记作 $\text{ind}<em>{a}{b}$\text{ind}</em>{a}{b}。</p>
<p>显然离散对数不一定存在。比如：$2^{x}\equiv 3\pmod 7$2^{x}\equiv 3\pmod 7。</p>
<p><strong>定理</strong> BSGS</p>
<p>当 $(a,m)=1$(a,m)=1 时我们可以使用大步小步（Baby Step Giant Step）算法。</p>
<p>注意到 $(a,m)=1$(a,m)=1，我们有<a href="https://link.zhihu.com/?target=https%3A//oi-wiki.org/math/number-theory/fermat/">欧拉定理</a> $a^{\varphi(m)}\equiv 1$a^{\varphi(m)}\equiv 1。所以 $a^k$a^k 至多有 $\varphi(m)$\varphi(m) 种取值（也就是其循环节为 $\varphi(m)$\varphi(m)）。设 $x=kB-r,0\le r\le B-1$x=kB-r,0\le r\le B-1，$B$B 是我们随便取的一个数，那么有 $a^{kB}\equiv ba^{r}$a^{kB}\equiv ba^{r}，我们预处理 $a^{0},a^{1}\dots a^{B-1}$a^{0},a^{1}\dots a^{B-1}，枚举 $k$k 即可求出 $x$x（其实这个过程已经可以求出<a href="https://link.zhihu.com/?target=https%3A//oi-wiki.org/math/number-theory/primitive-root/%23_2">阶</a>了）。</p>
<p>时间复杂度 $O(B+\frac{\varphi(m)}{B})$O(B+\frac{\varphi(m)}{B})，随便根号平衡一下得 $O(\sqrt{\varphi(m)})$O(\sqrt{\varphi(m)})。</p>
<p><strong>定理</strong> 扩展 BSGS</p>
<p>用于解决 $(a,m)\neq 1$(a,m)\neq 1 时的情况。设 $d=\gcd(a,m)$d=\gcd(a,m)，那么有 $\frac{a}{d}a^{x-1}\equiv \frac{b}{d}\pmod {\frac{m}{d}}$\frac{a}{d}a^{x-1}\equiv \frac{b}{d}\pmod {\frac{m}{d}}。于是这么一路递归除下去即可。注意判断无解，当 $d$d 不整除 $b$b 时即无解。</p>
<p>递归完之后就可以正常的 bsgs 了。</p>
<p><strong>定理</strong> pohlig-hellman 算法</p>
<p>这里我们不妨设模数是个大质数 $P$P。我们可以找出一个原根 $g$g，然后求 $g^x\equiv h\pmod P$g^x\equiv h\pmod P。</p>
<p>算法思想大概就是想把 $p-1$p-1 质因数分解为 $\prod p_i^{e_i}$\prod p_i^{e_i}，然后计算 $x\equiv x_i\pmod{p_i^{e_i}}$x\equiv x_i\pmod{p_i^{e_i}}。</p>
<p>考虑 $g^{p-1}\equiv 1\pmod P$g^{p-1}\equiv 1\pmod P。所以有</p>
<p>$(g^x)^{\frac{p-1}{p_i^{e_i}}}=(g^{x_i+kp_i^{e_i}})^{\frac{p-1}{p_i^{e_i}}}\equiv (g^{\frac{p-1}{p_i^{e_i}}})^{x_i}\equiv h^{\frac{p-1}{p_i^{e_i}}}\pmod P$(g^x)^{\frac{p-1}{p_i^{e_i}}}=(g^{x_i+kp_i^{e_i}})^{\frac{p-1}{p_i^{e_i}}}\equiv (g^{\frac{p-1}{p_i^{e_i}}})^{x_i}\equiv h^{\frac{p-1}{p_i^{e_i}}}\pmod P</p>
<p>所以令 $g^{\frac{p-1}{p_i^{e_i}}},h^{\frac{p-1}{p_i^{e_i}}}$g^{\frac{p-1}{p_i^{e_i}}},h^{\frac{p-1}{p_i^{e_i}}} 取代原来的 $g,h$g,h 就可以在 $p_i^{e_i}$p_i^{e_i} 范围内求 $x_i$x_i 了。</p>
<p>所以我们需要解决的问题变成了 $g^x\equiv h\pmod P$g^x\equiv h\pmod P，其中 $x\in [0,p<em>i^{e_i}-1]$x\in [0,p_i^{e_i}-1]。考虑将 $x$x 写成 $p_i$p_i 进制数，显然有 $e_i$e_i 位，从低到高逐位确定。即 $x=x_0+x_1p_i+x_2p_i^2+\dots+x</em>{e-1}p<em>i^{e_i-1}$x=x_0+x_1p_i+x_2p_i^2+\dots+x</em>{e-1}p_i^{e_i-1}。然后当我们想要求 $x_j$x_j 的时候，就计算 $(g^x)^{\frac{p-1}{p_i^{j+1}}}$(g^x)^{\frac{p-1}{p_i^{j+1}}}，容易发现这又可以写成 $g^{x_j}\equiv h\pmod P$g^{x_j}\equiv h\pmod P 的形式，但是这时 $x_j$x_j 的范围就变成了 $[0,p_i-1]$[0,p_i-1]。这个时候我们就可以直接 BSGS 了。</p>
<p>综上所述，整个算法的复杂度为 $O(\sum e_i(\log P+\sqrt{p_i}))$O(\sum e_i(\log P+\sqrt{p_i}))。比普通 BSGS 有了不小的提升。</p>
<p><strong>定理</strong> pollard-rho 算法</p>
<p><strong>定义</strong> 线性递推数列</p>
<p>主要研究二阶常系数齐次线性递推，即斐波那契数列。下面的公式仅考虑一般情况（$n\ge 2$n\ge 2）</p>
<p>$f<em>n=f</em>{n-1}+f<em>{n-2}\f</em>{n-1}f^{n+1}-f{n}^{2}=(-1)^{n}\f<em>{n+k}=f_kf</em>{n+1}+f<em>{k-1}f</em>{n}\f<em>{a}\mid f</em>{b}\Leftrightarrow a\mid b\\gcd(f<em>{a},f</em>{b})=f_{\gcd(a,b)}$</p>
<p><strong>定理</strong> 皮萨诺周期</p>
<p>斐波那契数列模 $m$ 的周期不超过 $6m$6m。</p>
<blockquote>
<p>WC2021 斐波那契</p>
</blockquote>
<p>这种分析的方法太经典了。</p>
<p>设 $f<em>0=0,f_1=,f</em>{n}=f<em>{n-2}+f</em>{n-1}$f<em>0=0,f_1=,f</em>{n}=f<em>{n-2}+f</em>{n-1}，$f<em>n$f_n 就是常见的斐波那契数列，易得 $F_n=af</em>{n-1}+bf{n}$F<em>n=af</em>{n-1}+bf{n}。</p>
<p>于是我们只需找出最小的 $n$n 使得 $a’f<em>{n-1}=b’f</em>{n}\pmod m$a’f<em>{n-1}=b’f</em>{n}\pmod m，如果 $m$m 是质数我们可以直接预处理（这里用到结论 $f$f 的循环节是 $O(m)$O(m) 的）。</p>
<p>否则考虑除掉 $\gcd(a’,b’,m)$\gcd(a’,b’,m)，变成 $a<em>1f</em>{n-1}=b<em>1f</em>{n}\pmod {m<em>1}$a_1f</em>{n-1}=b<em>1f</em>{n}\pmod {m_1}，注意到这时还是有可能不互质。</p>
<p>但是相邻斐波那契数是互质的，记 $p=\gcd(a<em>1,m_1)=\gcd(f_n,m_1),q=\gcd(b_1,m_1)=\gcd(f</em>{n-1},m<em>1)$，可以再除掉这个 $p,q$。于是有 $a_2f</em>{n-1}=b<em>2f</em>{n}\pmod {m<em>2}$，这时直接预处理 $\dfrac{f</em>{n}}{f_{n-1}}\bmod m_2$ 即可。</p>
<p>用一个三元组维护  $(p,q,\dfrac{f<em>{n}}{f</em>{n-1}})$维护即可。</p>
<p>本文使用  <a href="https://zhuanlan.zhihu.com/p/106057556">Zhihu On VSCode</a> 创作并发布</p>
]]></content>
      <categories>
        <category>ACMWeb</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>slides</title>
    <url>/posts/b8c02091/</url>
    <content><![CDATA[<h1 id="My-Test-For-Slides"><a href="#My-Test-For-Slides" class="headerlink" title="My Test For Slides"></a>My Test For Slides</h1><p>—</p>
<h1 id="Test-1"><a href="#Test-1" class="headerlink" title="Test 1"></a>Test 1</h1><blockquote>
<p>[!success] Title<br>123111111111111111111</p>
</blockquote>
<p>—</p>
<h2 id="Test-1-1"><a href="#Test-1-1" class="headerlink" title="Test 1.1"></a>Test 1.1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;hello,world!&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Test-3"><a href="#Test-3" class="headerlink" title="Test 3"></a>Test 3</h2><ul>
<li>1</li>
<li>2</li>
</ul>
<ul>
<li>3</li>
</ul>
<ol>
<li>1</li>
<li>2<h2 id="3-3"><a href="#3-3" class="headerlink" title="3) 3"></a>3) 3</h2><!-- slide: data-auto-animate -->
<h2 id="Test-A"><a href="#Test-A" class="headerlink" title="Test A"></a>Test A</h2>—<!-- slide: data-auto-animate --></li>
</ol>
<ul>
<li>123</li>
<li>23233</li>
<li>123</li>
</ul>
<h2 id="1"><a href="#1" class="headerlink" title="+ 1"></a>+ 1</h2><split even gap="1">
水平段落 1
水平段落 2
</split>

<split even gap="1">
![[Pasted image 20240108201230.png|500]]
![[Pasted image 20240106215550.png|500]]
</split>

<p>—</p>
<grid drag="100 20" drop="top" bg="orange">
# TopLove
</grid>

<grid drag="68 70" drop="0 20" bg="pink" frag="1">
# Love 1
</grid>

<grid drag="32 70" drop="68 20" bg="green" frag="2">
# Love 2
</grid>

<grid drag="100 10" drop="0 90" bg="gray" frag="3">
## LowerLove
</grid>

<p>—</p>
<h1 id="文档的嵌套"><a href="#文档的嵌套" class="headerlink" title="文档的嵌套"></a>文档的嵌套</h1><p>note: 这是提词器</p>
<hr>
<h1 id="文档属性"><a href="#文档属性" class="headerlink" title="文档属性"></a>文档属性</h1><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><i class="fas fa-camera fa-7x" /></p>
]]></content>
      <tags>
        <tag>slides</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的学习</title>
    <url>/posts/9c5fc61f/</url>
    <content><![CDATA[<p>==待更==</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>学习路线</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客</title>
    <url>/posts/c442673f/</url>
    <content><![CDATA[<p>之前试过用 Digital-Garden 来搭建个人博客<br><a href="https://fxjfxj.vercel.app/">vercel</a><br><a href="https://stalwart-lamington-7652f6.netlify.app">netlify</a><br>但是似乎出现了故障，以我现在的实力仍然不好解决。<br>所以我还是通过更方便的方式来搭建。<br>现在需要完善一些功能。<br><a href="https://blog.csdn.net/weixin_42665200/article/details/104633560#:~:text=Hexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%201%201%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE%EF%BC%9A%202%202%EF%BC%9A%E8%8F%9C%E5%8D%95%E9%85%8D%E7%BD%AE%203%203%EF%BC%9ANext%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%204,5%EF%BC%9A%E5%A4%B4%E5%83%8F%E8%AE%BE%E7%BD%AE%206%206%EF%BC%9A%E8%AE%BE%E7%BD%AERSS%207%207%E3%80%81%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9D%97%208%208%E3%80%81%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E6%A8%A1%E5%9D%97%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE">Hexo的Next主题详细配置_next主题如何添加日程表-CSDN博客</a><br>hexo clean &amp; hexo g &amp; hexo d<br><span id="more"></span><br><a href="https://bakebakebakebake.github.io/">My_Blog</a><br>我的梦中博客是：<a href="https://crcrc.cn/archives/darkmode-implement">基于 DarkMode 实现的深色主题（Next） - ruchan</a><br>Digital-Garden 的网站<br><a href="https://fxjfxj.vercel.app/">Site Unreachable</a><br><a href="https://stalwart-lamington-7652f6.netlify.app">Site Unreachable</a><br>可以设置第一个为 fxj.wiki 。作为知识类网站，或者也可以将 github 的设置为这个，但是很麻烦。</p>
<p>博客的 latex 不支持 <code>\left</code><br>这下好了，又得浪费时间了………… LATEX 害人……… 我 latex 用的其实不多，适应一下就好了。不要再瞎搞了.<br>可以注意一下在使用 latex 时：</p>
<ul>
<li>复杂的加上两个$，就可以渲染出来</li>
</ul>
<p>关于博客与 ob 的适应：</p>
<ul>
<li><span style="color:#ffc000">图片大小的调整</span></li>
<li>使用图片：<code>![](pasted的图片，空格记得加上%20)，这个方式是通用的</code> 如果要<span style="color:#c00000">调整大小</span>则使用：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> <span class="attr">width</span>= <span class="string">xx%</span> <span class="attr">height</span>=<span class="string">xx%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display:inline-block;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left; margin-right: 10px;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;$url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;$fileName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
等，markdown 博客不完全支持(不如直接学 html，css，js)</li>
<li>链接方式 ((/posts/~abblink~/)</li>
<li>注意：- # 1.  前面要空一行, 后面也要空一行</li>
</ul>
<p>不要随便删除东西呀，不然要死。</p>
<h1 id="搭建了博客-待做"><a href="#搭建了博客-待做" class="headerlink" title="搭建了博客~待做"></a>搭建了博客~待做</h1><ul>
<li>升级 next 主题问题(暂时不考虑)</li>
<li>需要设置站点地图的问题(搞不懂)<br><mark style="background: #FFB8EBA6;">- 域名已经购买，现在需要购买云服务器以及备案。</mark>备案的提交，回去马上办身份证去备案</li>
<li><span style="color:#ffc000">买了 fxj. wiki 的域名，映射到自己网站</span>，具体看知乎收藏的教程</li>
<li>直接插入视频的方法</li>
<li>对目录旁边滑动的 UI 的修改</li>
<li>选中时背景是黑色，改变颜色</li>
<li>全屏看代码，最好还可以修改.</li>
<li>使得支持 callout</li>
<li>文件链接的问题(../aa/bb/cc/test. md)，与博客方式不一致(/posts/abbrlink) 使之兼容的问题</li>
</ul>
<p>对于个人博客网站：（非必需）(<span style="color:#92d050">之后有时间再说</span>)</p>
<ul>
<li>设置百度和谷歌的站点地图，这样就可以搜到我。</li>
<li>更换主题，使变得更炫酷（没必要</li>
<li>将 busuanzi 的显示 bug 修复，这样可以看到阅读量</li>
<li>设置 RSS. xml 配置文件</li>
<li>/设置主页，使向“梦中博客”方向逼近，达到要求：主页进去也是很多博客，但是每个博客都是矩形的含有相关信息和图片的，各种矩形组成的主页。但是内容又不能太花哨了，至少在博文中不能花哨，主页可以花哨。</li>
<li>同上，向我“梦中博客”逼近，搞清楚他的 callout 是怎么搞的，theme 是怎么可以随便更换的，深色模式如何设置成为他那样，主页也是如何弄成他那样。</li>
<li>mac 代码块由于代码块展开显示两个的问题，且使得 mac 后面可以显示编程语言名称</li>
<li>将边栏向左边移动一点</li>
<li>彩色标签</li>
<li>设置主页界面 (需要自定义，感觉太耗费时间了，先不管了)</li>
<li><span style="color:#ffc000">下方的访问人数不见了的</span> bug 需要修复 (暂时不打算修复了，太费时间了)</li>
<li>鼠标滑动的特效，那种直的就行</li>
<li>hexo s 部署的 warning 问题 (问题不大，对平时无影响)</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/posts/a378bd8e/</url>
    <content><![CDATA[<p><a href="https://docs.python.org/zh-cn/3/tutorial/index.html">Python 教程 — Python 3.12.0 文档</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>cyaron库</title>
    <url>/posts/10aba810/</url>
    <content><![CDATA[<p>造数据的工具，教程见 url</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>manim</title>
    <url>/posts/e16fffa6/</url>
    <content><![CDATA[<p><a href="https://github.com/cai-hust/manim-tutorial-CN">cai-hust/manim-tutorial-CN: manim中文入门教程</a> url 即是教程</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>jupyter notebook</title>
    <url>/posts/2641cf45/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/33105153">Jupyter Notebook介绍、安装及使用教程 - 知乎</a><br>需要打开这个网页。<br><a href="http://localhost:8888/tree">http://localhost:8888/tree</a></p>
<p><a href="https://docs.jupyter.org/en/latest/">Project Jupyter Documentation — Jupyter Documentation 4.1.1 alpha documentation</a><br><a href="https://github.com/jupyter/notebook">GitHub - jupyter/notebook: Jupyter Interactive Notebook</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/posts/784dd132/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------+           +---------------+           +-----------------+</span><br><span class="line">|   天然气公司    |----(1,n)- -|   监测地点    |-----(1,n)-|     计量表     |</span><br><span class="line">+-----------------+           +---------------+           +-----------------+</span><br><span class="line">| 公司编号(PK)    |           | 地点编号(PK) |            | 设备序列号(PK)  |</span><br><span class="line">| 公司名称        |           | 纬度          |           | 编码口令        |</span><br><span class="line">| 联系电话        |           | 经度          |           | 设备型号        |</span><br><span class="line">| 联系人          |           | 名称          |           | 出厂日期        |</span><br><span class="line">| 联系地址        |           | 备注          |           | ...             |</span><br><span class="line">+-----------------+           | 安全负责人    |           +-----------------+</span><br><span class="line">                             +---------------+</span><br><span class="line">+-------------------+</span><br><span class="line">| 测量数据包       |</span><br><span class="line">+-------------------+</span><br><span class="line">| 时间戳            |</span><br><span class="line">| 设备序列号(FK)   |</span><br><span class="line">| 温度              |</span><br><span class="line">| 压力              |</span><br><span class="line">| 电池电压          |</span><br><span class="line">| 工况流量          |</span><br><span class="line">| 累积流量          |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure>
<p>天然气公司</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>公司编号</th>
<th>公司名称</th>
<th>联系电话</th>
<th>联系人</th>
<th>联系地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>PK (VarChar (10))</td>
<td>VarChar (100)</td>
<td>VarChar (20)</td>
<td>VarChar (10)</td>
<td>VarChar (200)</td>
</tr>
</tbody>
</table>
</div>
<p>监测地点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>监测地点编号</th>
<th>公司编号 FK</th>
<th>纬度</th>
<th>经度</th>
<th>名称</th>
<th>备注</th>
<th>安全负责人</th>
</tr>
</thead>
<tbody>
<tr>
<td>PK (int)</td>
<td>FK (VarChar (10))</td>
<td>VarChar (20)</td>
<td>VarChar (20)</td>
<td>VarChar (100)</td>
<td>VarChar (100)</td>
<td>VarChar (10)</td>
</tr>
</tbody>
</table>
</div>
<p>计量表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>设备序列号</th>
<th>监测地点编号 FK</th>
<th>编码口令</th>
<th>设备型号</th>
<th>出厂日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>PK (VarChar (15))</td>
<td>FK (int)</td>
<td>VarChar (20)</td>
<td>VarChar (10)</td>
<td>Date</td>
</tr>
</tbody>
</table>
</div>
<p>测量数据包</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>时间戳</th>
<th>设备序列号 FK</th>
<th>温度</th>
<th>压力</th>
<th>电池电压</th>
<th>工况流量</th>
<th>累积流量</th>
</tr>
</thead>
<tbody>
<tr>
<td>PK (DateTime)</td>
<td>FK (VarChar (15))</td>
<td>Float</td>
<td>Float</td>
<td>Float</td>
<td>Float</td>
<td>Float</td>
</tr>
</tbody>
</table>
</div>
<p>(PK 表示主键，FK 表示外键，VarChar 表示字符类型，Int 表示整数类型，DateTime 表示日期时间类型，Float 表示浮点数类型) </p>
<p>主键、外键参照如下：</p>
<ul>
<li>监测地点表中的 “公司编号 FK” 是天然气公司表中”公司编号”的外键。</li>
<li>计量表表中的 “监测地点编号 FK” 是监测地点表中的”监测地点编号”的外键。</li>
<li>测量数据包表中的 “设备序列号 FK” 是计量表表中的 “设备序列号” 的外键。</li>
</ul>
<p>![[../../../images/Z-attachment/Pasted image 20231127204702.png]]</p>
<h2 id="1-LaTeX"><a href="#1-LaTeX" class="headerlink" title="1 LaTeX"></a>1 LaTeX</h2><p> <a href="https://mirrors.bfsu.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf">The Short Introduction to LaTeX2e (Chinese Simplified) (bfsu.edu.cn)</a><br><a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-ru-men">$\LaTeX$入门</a></p>
<p><a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan">$\LaTeX$数学公式大全</a></p>
<p><a href="https://zh.wikibooks.org/wiki/LaTeX">$\LaTeX$ $wiki$  较为全面</a></p>
<p>$\oint\overrightarrow{B}\cdot d\overrightarrow{l}=u_0I$  $B=\dfrac {u_0 I}{2\pi r}(r&gt;R)$ </p>
<p>$\LaTeX$     <code>code</code><br><code>code</code>  </p>
<blockquote>
<p>$\LaTeX$ </p>
<script type="math/tex; mode=display">\begin{bmatrix}
1 & 2 & \cdots \\
67 & 95 & \cdots \\
\vdots  & \vdots & \ddots \\
\end{bmatrix}</script></blockquote>
<p>表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Title 1</th>
<th>Title 2</th>
<th>Title 3</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-Codeblock-example"><a href="#2-Codeblock-example" class="headerlink" title="2 Codeblock example"></a>2 Codeblock example</h2><h3 id="2-1-缺点："><a href="#2-1-缺点：" class="headerlink" title="2.1 缺点："></a>2.1 缺点：</h3><p>每次修改需要重新改一下语言，所以非必须可以不用特别在意<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;Hello&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><code>Code</code> </p>
<p><code>code</code>  www.baidu.com</p>
<h2 id="3-时间戳实例-："><a href="#3-时间戳实例-：" class="headerlink" title="3 时间戳实例 ："></a>3 时间戳实例 ：</h2><p><img data-src="https://www.bilibili.com/video/BV1594y1y76N/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=cb670d82714ee9baee22c33ef083884d" alt="【4K/120帧】“悬溺一响，眼泪登场！”\_哔哩哔哩\_bilibili"></p>
<p><a href="https://www.bilibili.com/video/BV1594y1y76N/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=cb670d82714ee9baee22c33ef083884d?#t=141.592848">02:21</a></p>
<p><img data-src="https://www.bilibili.com/video/BV1594y1y76N/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=cb670d82714ee9baee22c33ef083884d?#t=120" alt="02:00"></p>
<p>加入时间戳方式：</p>
<p>格式： ?# t=秒数</p>
<p>或者点击视频加入收藏</p>
<h2 id="4-示例："><a href="#4-示例：" class="headerlink" title="4 示例："></a>4 示例：</h2><h2 id="5-设-a-b-是不全为零的整数，则存在整数-x-y-使得-ax-by-gcd-a-b"><a href="#5-设-a-b-是不全为零的整数，则存在整数-x-y-使得-ax-by-gcd-a-b" class="headerlink" title="5 设 $a,b$ 是不全为零的整数，则存在整数 $x,y$, 使得 $ax+by=gcd(a,b)$."></a>5 设 $a,b$ 是不全为零的整数，则存在整数 $x,y$, 使得 $ax+by=gcd(a,b)$.</h2><h3 id="5-1-证明："><a href="#5-1-证明：" class="headerlink" title="5.1 证明："></a>5.1 证明：</h3><p>设取 $x_0$, $y_0$ 时，$ax+by$ 的最小整数是 $s$.即 $ax_0+by_0$ = $s$</p>
<p>因 $gcd(a,b)|ax_0$ ， $gcd(a,b)|ay_0$</p>
<p>所以 $gcd(a,b)|s$ $………(1)$</p>
<p>设 $a=qs+r(0\le r\le s)$</p>
<p>$r=a-qs=a-q(ax0+by0)=a(1-qx0)+b(-qy0)=ax+by$</p>
<p>因为 $s$ 是最小整数，$\Rightarrow r=0$</p>
<p>所以 $s|a$,同理 $s|b$</p>
<p>$\Rightarrow s|gcd(a,b)$ $……….(2)$</p>
<p>由 $(1)(2)$ 可得 $s=gcd(a,b)$.</p>
<p>证毕。</p>
<h2 id="6-PDF-Reading"><a href="#6-PDF-Reading" class="headerlink" title="6 PDF Reading"></a>6 PDF Reading</h2><blockquote>
<p>Granted to copy, distribute and/or modify this document under the<br>[[../../../images/Z-attachment/lshort-zh-cn.pdf#page=2&amp;selection=1,14,1,80|lshort-zh-cn, page 2]]</p>
<p>\newcommand{\⟨name⟩}[⟨num⟩]{⟨definition⟩}<br>[[../../../images/Z-attachment/lshort-zh-cn.pdf#page=107&amp;selection=69,0,81,1|lshort-zh-cn, page 107]]</p>
<p>The Pythagorean theorem is: \begin{equation} a^2 + b^2 = c^2 \label{pythagorean} \end{equation} Equation \eqref{pythagorean} is called `Gougu theorem’ in Chinese.</p>
</blockquote>
<p>[[../../../images/Z-attachment/lshort-zh-cn.pdf#page=51&amp;selection=156,0,161,34|lshort-zh-cn, page 51]]</p>
<p><a href="https://www.bilibili.com/video/BV1V34y1k7St/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=cb670d82714ee9baee22c33ef083884d">也许是B站最全面的Obsidian公开课 ！【课时2 认识Ob】顶级知识管理神器、双链笔记先驱——OB保姆级教程_哔哩哔哩_bilibili</a> </p>
<p>[[#进一步结论]]</p>
<iframe width="637" height="357" src="https://www.youtube.com/embed/QgbLb6QCK88" title="Obsidian for Beginners: Start HERE — How to Use the Obsidian App for Notes" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>



<h2 id="7-Test"><a href="#7-Test" class="headerlink" title="7 Test"></a>7 Test</h2><p>==可信度标准==</p>
<p>==1==2</p>
<script type="math/tex; mode=display">A^2 \times B^2 = C^2</script><blockquote>
<p>[ $a\xleftarrow{x+y+z} b$ ]</p>
</blockquote>
<p>[[../../../images/Z-attachment/lshort-zh-cn.pdf#page=57&amp;selection=103,0,103,27|lshort-zh-cn, page 57]]</p>
<h2 id="8-Highlight"><a href="#8-Highlight" class="headerlink" title="8 Highlight"></a>8 Highlight</h2><blockquote>
<p>In text: \sum\limits<em>{i=1}^n \quad \int\limits_0^{\frac{\pi}{2}} \quad \prod\limits</em>\epsilon $ \ In display: [\sum\nolimits<em>{i=1}^n \quad \int\limits_0^{\frac{\pi}{2}} \quad \prod\nolimits</em>\epsilon ]</p>
</blockquote>
<p>$In \ text:$</p>
<script type="math/tex; mode=display">In\ text: \sum\limits_{i=1}^n \quad \int\limits_0^{\frac{\pi}{2}} \quad
\prod\limits_\epsilon</script><p>$In\  display:$</p>
<script type="math/tex; mode=display">In\ display:  \sum\nolimits_{i=1}^n \quad \int\limits_0^{\frac{\pi}{2}} \quad \prod\nolimits_\epsilon</script><p>[[../../../images/Z-attachment/lshort-zh-cn.pdf#page=56&amp;selection=20,1,30,26|lshort-zh-cn, page 56]]</p>
<p>$\otimes$<br>$\dot{x}^{2}$<br>$\boxed{\begin{align}\end{align}}$<br>$\dot{x}$<br>$\dot{1}$<br>$\frac{a}{a}$<br>$\dot{x}^{2}+\dot{y}^2$<br>$\sqrt{ 1+\beta^2 }$<br>$\begin{vmatrix}a&amp;b   \b&amp;a\end{vmatrix}$<br>$\varepsilon$<br>$\prod$<br>![[../../../images/Z-attachment/Pasted image 20231127212241.png]]</p>
<h2 id="9-LaTeX-的正则替换"><a href="#9-LaTeX-的正则替换" class="headerlink" title="9 LaTeX 的正则替换"></a>9 LaTeX 的正则替换</h2><h3 id="9-1-说明"><a href="#9-1-说明" class="headerlink" title="9.1 说明"></a>9.1 说明</h3><p>其中 trigger 字段指定触发字符，replacement 代表将触发字符替换后的字符，option 是选项，t 代表文本模式，m 代表 latex 模式，r 代表正则模式，A 代表自动触发。文本模式指仅在正文中触发，latex 模式指仅在 latex 块中触发——$ 包裹的部分，r 是使用正则表达式，w 代表词边界，仅当触发字符前面（和后面）有单词分隔符时才运行此代码段。$0$ 代表光标跳转的位置，$[[0]]$ 代表正则表达式替换的位置。 Description 是片段描述，可选，priority 是优先级，当有多个同样的触发字符时，优先级高的会优先触发，默认是 0 优先级。</p>
<p>以第一个片段为例：指明 $ 为触发字符，将字符替换成，替换后光标在两个 $ 符号中间，option 中的 t 代表文本模式，不会自动触发。</p>
<h3 id="9-2-我的代码"><a href="#9-2-我的代码" class="headerlink" title="9.2 我的代码"></a>9.2 我的代码</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">	<span class="comment">// Math mode</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;mk&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;$$0$&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;tA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;dm&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;$$\n$0\n$$&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;tAw&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;beg&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;$0&#125;\n$1\n\\end&#123;$0&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;bx&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;$\\boxed&#123;\\begin&#123;align&#125;&#123;$0&#125;\\end&#123;align&#125;&#125;$&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Dashes</span></span><br><span class="line">	<span class="comment">// &#123;trigger: &quot;--&quot;, replacement: &quot;–&quot;, options: &quot;tA&quot;&#125;,</span></span><br><span class="line">	<span class="comment">// &#123;trigger: &quot;–-&quot;, replacement: &quot;—&quot;, options: &quot;tA&quot;&#125;,</span></span><br><span class="line">	<span class="comment">// &#123;trigger: &quot;—-&quot;, replacement: &quot;---&quot;, options: &quot;tA&quot;&#125;,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Greek letters</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@a&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\alpha&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@A&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\alpha&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@b&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\beta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@B&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\beta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@c&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\chi&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@C&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\chi&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@g&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\gamma&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@G&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\Gamma&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@d&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\delta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@D&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\Delta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@e&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\epsilon&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@E&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\epsilon&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:e&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\varepsilon&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:E&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\varepsilon&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@z&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\zeta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@Z&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\zeta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@t&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\theta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@T&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\Theta&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@k&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\kappa&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@K&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\kappa&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@l&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\lambda&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@L&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\Lambda&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@m&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mu&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@M&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mu&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@r&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\rho&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@R&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\rho&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@s&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\sigma&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@S&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\Sigma&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ome&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\omega&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@o&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\omega&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@O&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\Omega&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@u&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\upsilon&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;@U&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\Upsilon&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([^\\\\])($&#123;GREEK&#125;|$&#123;SYMBOL&#125;)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[[0]]\\[[1]]&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">,</span> description<span class="punctuation">:</span> <span class="string">&quot;Add backslash before greek letters and symbols&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Insert space after greek letters and symbols, etc</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;|$&#123;SHORT_SYMBOL&#125;)([A-Za-z])&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\[[0]] [[1]]&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) sr&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\[[0]]^&#123;2&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) cb&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\[[0]]^&#123;3&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) rd&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\[[0]]^&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) hat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) dot&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\dot&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) bar&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\bar&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) vec&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\vec&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) tilde&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\tilde&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;|$&#123;SYMBOL&#125;) und&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\underline&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;),\\.&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\boldsymbol&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\($&#123;GREEK&#125;)\\.,&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\boldsymbol&#123;\\[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Operations</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;te&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\text&#123;$0&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;m&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\text&#123;$0&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;bf&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;$0&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;sr&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;^&#123;2&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;cb&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;^&#123;3&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;rd&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;^&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;_&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;_&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;sts&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;_\\text&#123;$0&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;sq&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\sqrt&#123; $0 &#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;//&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123;$0&#125;&#123;$1&#125;$2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ee&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;e^&#123; $0 &#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;rm&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathrm&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;conj&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;^&#123;*&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;trace&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathrm&#123;Tr&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;det&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\det&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;re&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathrm&#123;Re&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;im&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathrm&#123;Im&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z]),\\.&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])\\.,&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([A-Za-z])(\\d)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[[0]]_&#123;[[1]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">,</span> description<span class="punctuation">:</span> <span class="string">&quot;Auto letter subscript&quot;</span><span class="punctuation">,</span> priority<span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([A-Za-z])_(\\d\\d)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[[0]]_&#123;[[1]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;([A-Za-z])&#125;(\\d)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;hat&#123;[[0]]&#125;_&#123;[[1]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\mathbf&#123;([A-Za-z])&#125;(\\d)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;[[0]]&#125;_&#123;[[1]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\vec&#123;([A-Za-z])&#125;(\\d)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\vec&#123;[[0]]&#125;_&#123;[[1]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])bar&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\bar&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])hat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])ddot&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ddot&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">,</span> priority<span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])dot&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\dot&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">,</span> priority<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])vec&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\vec&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])tilde&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\tilde&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([a-zA-Z])und&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\underline&#123;[[0]]&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;bar&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\bar&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;hat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;dot&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\dot&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ddot&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ddot&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">,</span> priority<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;cdot&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\cdot&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">,</span> priority<span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;vec&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\vec&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;tilde&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\tilde&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;und&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\underline&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([^\\\\])(arcsin|arccos|arctan|arccot|arccsc|arcsec|sin|cos|tan|cot|csc|sec)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[[0]]\\[[1]]&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\(arcsin|arccos|arctan|arccot|arccsc|arcsec|sin|cos|tan|cot|csc|sec)([A-Za-gi-z])&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\[[0]] [[1]]&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// Insert space after trig funcs. Skips letter &quot;h&quot; to allow sinh, cosh, etc.</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\(arcsinh|arccosh|arctanh|arccoth|arcsch|arcsech|sinh|cosh|tanh|coth|csch|sech)([A-Za-z])&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\[[0]] [[1]]&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// Insert space after trig funcs</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\(neq|geq|leq|gg|ll|sim)([0-9]+)&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\[[0]] [[1]]&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// Insert space after inequality symbols</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Visual operations</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;U&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\underbrace&#123; $&#123;VISUAL&#125; &#125;_&#123; $0 &#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;B&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\underset&#123; $0 &#125;&#123; $&#123;VISUAL&#125; &#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;C&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\cancel&#123; $&#123;VISUAL&#125; &#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;K&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\cancelto&#123; $0 &#125;&#123; $&#123;VISUAL&#125; &#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;S&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\sqrt&#123; $&#123;VISUAL&#125; &#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Symbols</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ooo&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\infty&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;sum&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\sum&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;prod&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\prod&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;lim&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\lim_&#123; $&#123;0:n&#125; \\to $&#123;1:\\infty&#125; &#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([^\\\\])pm&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[[0]]\\pm&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rm&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;([^\\\\])mp&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[[0]]\\mp&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rm&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;+-&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\pm&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;-+&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mp&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\dots&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;&lt;-&gt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\leftrightarrow &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;-&gt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\to&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;!&gt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mapsto&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;invs&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;^&#123;-1&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\\\&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\setminus&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;||&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mid&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;and&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\cap&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;orr&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\cup&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;inn&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\in&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;notin&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\not\\in&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\subset eq&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\subseteq&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;eset&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\emptyset&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;set&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\&#123; $0 \\&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;=&gt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\implies&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;=&lt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\impliedby&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;iff&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\iff&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;e\\xi sts&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\exists&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">,</span> priority<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;===&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\equiv&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;Sq&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\square&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;!=&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\neq&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;&gt;=&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\geq&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;&lt;=&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\leq&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;&gt;&gt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\gg&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;&lt;&lt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ll&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;~~&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\sim&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\sim ~&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\approx&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;prop&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\propto&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;nabl&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\nabla&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;del&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\nabla&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;xx&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\times&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;**&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\cdot&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;para&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\parallel&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;xnn&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;x_&#123;n&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;xii&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;x_&#123;i&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;xjj&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;x_&#123;j&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;xp1&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;x_&#123;n+1&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ynn&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;y_&#123;n&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;yii&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;y_&#123;i&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;yjj&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;y_&#123;j&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;mcal&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathcal&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;mbb&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbb&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ell&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ell&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;lll&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ell&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;LL&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathcal&#123;L&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;HH&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathcal&#123;H&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;CC&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbb&#123;C&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;RR&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbb&#123;R&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ZZ&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbb&#123;Z&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;NN&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbb&#123;N&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;II&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbb&#123;1&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\mathbb&#123;1&#125;I&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;\\mathbb&#123;1&#125;&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;AA&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathcal&#123;A&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;BB&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;B&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;EE&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;E&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unit vectors</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:i&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;i&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:j&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;j&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:k&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\mathbf&#123;k&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:x&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;\\mathbf&#123;x&#125;&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:y&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;\\mathbf&#123;y&#125;&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;:z&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hat&#123;\\mathbf&#123;z&#125;&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Derivatives</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;par&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; \\partial $&#123;0:y&#125; &#125;&#123; \\partial $&#123;1:x&#125; &#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;m&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;pa2&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; \\partial^&#123;2&#125; $&#123;0:y&#125; &#125;&#123; \\partial $&#123;1:x&#125;^&#123;2&#125; &#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;pa3&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; \\partial^&#123;3&#125; $&#123;0:y&#125; &#125;&#123; \\partial $&#123;1:x&#125;^&#123;3&#125; &#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;pa([A-Za-z])([A-Za-z])&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; \\partial [[0]] &#125;&#123; \\partial [[1]] &#125; &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rm&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;pa([A-Za-z])([A-Za-z])([A-Za-z])&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; \\partial^&#123;2&#125; [[0]] &#125;&#123; \\partial [[1]] \\partial [[2]] &#125; &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rm&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;pa([A-Za-z])([A-Za-z])2&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; \\partial^&#123;2&#125; [[0]] &#125;&#123; \\partial [[1]]^&#123;2&#125; &#125; &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;de([A-Za-z])([A-Za-z])&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; d[[0]] &#125;&#123; d[[1]] &#125; &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rm&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;de([A-Za-z])([A-Za-z])2&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123; d^&#123;2&#125;[[0]] &#125;&#123; d[[1]]^&#123;2&#125; &#125; &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ddt&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\frac&#123;d&#125;&#123;dt&#125; &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Integrals</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;oinf&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\int_&#123;0&#125;^&#123;\\infty&#125; $0 \\, d$&#123;1:x&#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;infi&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\int_&#123;-\\infty&#125;^&#123;\\infty&#125; $0 \\, d$&#123;1:x&#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;dint&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\int_&#123;$&#123;0:0&#125;&#125;^&#123;$&#123;1:\\infty&#125;&#125; $2 \\, d$&#123;3:x&#125; $4&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;oint&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\oint&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;iiint&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\iiint&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;iint&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\iint&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\int $0 \\, d$&#123;1:x&#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Physics</span></span><br><span class="line">	<span class="comment">//&#123;trigger: &quot;kbt&quot;, replacement: &quot;k_&#123;B&#125;T&quot;, options: &quot;mA&quot;&#125;,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Quantum mechanics</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;hba&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\hbar&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;dag&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;^&#123;\\dagger&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;o+&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\oplus &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ox&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\otimes &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ot\\mathrm&#123;Im&#125;es&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\otimes &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// Handle conflict with &quot;im&quot; snippet</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;bra&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\bra&#123;$0&#125; $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ket&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ket&#123;$0&#125; $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;brk&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\braket&#123; $0 | $1 &#125; $2&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\bra&#123;([^|]+)\\|&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\braket&#123; [[0]] | $0 &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">,</span> description<span class="punctuation">:</span> <span class="string">&quot;Convert bra into braket&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;\\\\bra&#123;(.+)&#125;([^ ]+)&gt;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\braket&#123; [[0]] | $0 &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;rmA&quot;</span><span class="punctuation">,</span> description<span class="punctuation">:</span> <span class="string">&quot;Convert bra into braket (alternate)&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;outp&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ket&#123;$&#123;0:\\psi&#125;&#125; \\bra&#123;$&#123;0:\\psi&#125;&#125; $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Chemistry</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;pu&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\pu&#123; $0 &#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;msun&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;M_&#123;\\odot&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;solm&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;M_&#123;\\odot&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;ce&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\ce&#123; $0 &#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;iso&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;&#123;&#125;^&#123;$&#123;0:4&#125;&#125;_&#123;$&#123;1:2&#125;&#125;$&#123;2:He&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;hel4&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;&#123;&#125;^&#123;4&#125;_&#123;2&#125;He &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;hel3&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;&#123;&#125;^&#123;3&#125;_&#123;2&#125;He &quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Environments</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;pmat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;pmatrix&#125;\n$0\n\\end&#123;pmatrix&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;bmat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;bmatrix&#125;\n$0\n\\end&#123;bmatrix&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;Bmat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;Bmatrix&#125;\n$0\n\\end&#123;Bmatrix&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;vmat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;vmatrix&#125;\n$0\n\\end&#123;vmatrix&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;Vmat&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;Vmatrix&#125;\n$0\n\\end&#123;Vmatrix&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;case&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;cases&#125;\n$0\n\\end&#123;cases&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;align&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;align&#125;\n$0\n\\end&#123;align&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;array&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;array&#125;\n$0\n\\end&#123;array&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;matrix&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;matrix&#125;\n$0\n\\end&#123;matrix&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Brackets</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;avg&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\langle $0 \\rangle $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;norm&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\lvert $0 \\rvert $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">,</span> priority<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;mod&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;|$0|$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;(&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;($&#123;VISUAL&#125;)&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;[&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[$&#123;VISUAL&#125;]&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;&#123;$&#123;VISUAL&#125;&#125;&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;(&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;($0)$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;&#123;$0&#125;$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;[&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;[$0]$1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;lr(&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\left( $0 \\right) $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;lr|&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\left| $0 \\right| $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;lr&#123;&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\left\\&#123; $0 \\right\\&#125; $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;lr[&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\left[ $0 \\right] $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;lra&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;\\left&lt; $0 \\right&gt; $1&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Misc</span></span><br><span class="line">	<span class="punctuation">&#123;</span>trigger<span class="punctuation">:</span> <span class="string">&quot;tayl&quot;</span><span class="punctuation">,</span> replacement<span class="punctuation">:</span> <span class="string">&quot;$&#123;0:f&#125;($&#123;1:x&#125; + $&#123;2:h&#125;) = $&#123;0:f&#125;($&#123;1:x&#125;) + $&#123;0:f&#125;&#x27;($&#123;1:x&#125;)$&#123;2:h&#125; + $&#123;0:f&#125;&#x27;&#x27;($&#123;1:x&#125;) \\frac&#123;$&#123;2:h&#125;^&#123;2&#125;&#125;&#123;2!&#125; + \\dots$3&quot;</span><span class="punctuation">,</span> options<span class="punctuation">:</span> <span class="string">&quot;mA&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h2 id="10-正则表达式的教程"><a href="#10-正则表达式的教程" class="headerlink" title="10 正则表达式的教程"></a>10 正则表达式的教程</h2><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">中文教程_README-cn.md</a></p>
<p>![[../../../images/Z-attachment/Pasted image 20231127210719.png]]</p>
<p>![[../../../images/Z-attachment/Pasted image 20231127210731.png]]</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>sympy库</title>
    <url>/posts/bd875938/</url>
    <content><![CDATA[<p><a href="https://docs.sympy.org/latest/tutorials/intro-tutorial/preliminaries.html">Preliminaries - SymPy 1.12 documentation</a> 是<mark style="background: #CACFD9A6;">官方教学文档</mark><br><a href="https://www.osgeo.cn/sympy/index.html">欢迎使用SymPy的文档！ — SymPy 1.8.dev 文档</a> <mark style="background: #CACFD9A6;">中文的文档</mark><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sympy.abc <span class="keyword">import</span> a,b,c,x,y</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> rc</span><br><span class="line">rc(<span class="string">&#x27;text&#x27;</span>,usetex=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p><mark style="background: #FFB8EBA6;">有很多时间的话我会学一学这个</mark><br>$’\int\limits_{0}^{\pi} \cos^{2}{\left (x \right)}\, dx’$</p>
<p> ${ \frac{3}{2} - \frac{\sqrt{17}}{2} : 1, \  \frac{3}{2} + \frac{\sqrt{17}}{2} : 1}$ </p>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>计算工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM 的正确入门方式是什么？</title>
    <url>/posts/eef20e6f/</url>
    <content><![CDATA[<p><img data-src="https://pic1.zhimg.com/e0fe98fdf12bdc7a144dd00576cb6af2_l.jpg?source=2c26e567" alt="250"></p>
<h1 id="数学-lover​"><a href="#数学-lover​" class="headerlink" title="数学 lover​"></a>数学 lover​</h1><p>一般的入门顺序：</p>
<ol>
<li>C 语言的基本语法 (或者直接开 <a href="https://www.zhihu.com/search?q=C%2B%2B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">C++</a> 也行，当一个 java 选手可能会更受欢迎，并且以后工作好找，但是难度有点大)，【参考书籍：刘汝佳的《<a href="https://www.zhihu.com/search?q=%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">算法竞赛入门经典</a>》，C++ 入门可以考虑《<a href="https://www.zhihu.com/search?q=c%2B%2B%20primer%20plus&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">c++ primer plus</a>》，java 选手可以考虑《think in java》or 中文版《java 编程思想》，请远离谭浩强…】</li>
</ol>
<p>可以选择切一些特别水的题巩固以及适应一下 ACM 中常见的输入输出格式… 例如<a href="https://www.zhihu.com/search?q=%E6%9D%AD%E7%94%B5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">杭电</a>著名的 100 题</p>
<p><a href="https://link.zhihu.com/?target=http%3A//acm.hdu.edu.cn/listproblem.php%3Fvol%3D11">Problem Set</a></p>
<ol>
<li>一些基本算法和<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">数据结构</a> (队列 栈 树 图 并查集 堆 DFS BFS 最短路 最小生成树 拓扑排序 动态规划 贪心 搜索 KMP 哈希 Trie AC 自动机 快速幂 逆元 <a href="https://www.zhihu.com/search?q=%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">费马小定理</a> 欧拉函数 素数筛 <a href="https://www.zhihu.com/search?q=%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">分解质因数</a>) 你可以找两个小伙伴一起分工合作，各自认领专题【参考书籍：刘汝佳《算法竞赛入门经典第二版》or《算法竞赛训练手册》，《<a href="https://www.zhihu.com/search?q=%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">算法导论</a>》】这时候可以刷的题就多了，你可以选择一些专题进行突破，学习一下技巧 例如</li>
</ol>
<p><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/65959%23overview">[kuangbin 带你飞] 专题一 简单搜索</a> <a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66569%23overview">[kuangbin 带你飞] 专题四 最短路练习</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66964%23overview">[kuangbin 带你飞] 专题五 并查集</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66965%23overview">[kuangbin 带你飞] 专题六 最小生成树</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/68966%23overview">[kuangbin 带你飞] 专题十二 基础 DP1</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70017%23overview">[kuangbin 带你飞] 专题十四 数论基础</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70325%23overview">[kuangbin 带你飞] 专题十六 KMP &amp; 扩展 KMP &amp; Manacher</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70326%23overview">[kuangbin 带你飞] 专题十七 AC 自动机</a>  </p>
<p>如果这些你和你的小伙伴都能熟悉掌握，并且能够尽快写出来，那么没有意外的话就可以在网络赛中拿到现场赛的门票（当然还得看出题人的风格…）</p>
<ol>
<li>一些进阶的算法以及复杂一些的数据结构（<a href="https://www.zhihu.com/search?q=%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">树状数组</a> 线段树 平衡树 后缀数组 二分图匹配 网络流 费用流 割点 桥 强联通 双联通 <a href="https://www.zhihu.com/search?q=%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">最近公共祖先</a> 四大 DP(数位 dp 区间 dp 状压 dp 概率 dp) <a href="https://www.zhihu.com/search?q=%E5%8D%9A%E5%BC%88%E8%AE%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">博弈论</a> SG <a href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">函数</a> ）</li>
</ol>
<p>【参考资料：各种博客……】</p>
<p><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/66989%23overview">[kuangbin 带你飞] 专题七 线段树</a> <a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/67418%23overview">[kuangbin 带你飞] 专题九 连通图</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/68127%23overview">[kuangbin 带你飞] 专题十 匹配问题</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/68128%23overview">[kuangbin 带你飞] 专题十一 网络流</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70324%23overview">[kuangbin 带你飞] 专题十五 数位 DP</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/70655%23overview">[kuangbin 带你飞] 专题十八 后缀数组</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/76505%23overview">[kuangbin 带你飞] 专题二十一 概率 &amp; 期望</a><br><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest/77874%23overview">[kuangbin 带你飞] 专题二十二 区间 DP</a>  </p>
<p>这些掌握之后在现场赛中拿到牌子应该就没什么问题了，发挥出色还能拿到银牌。。。不过如果遇到比较凶残的赛区…</p>
<p>2.5 这时候如果开始组队了，就可以去刷一些套题了，例如</p>
<p><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/contest%23contestType%3D1%26contestRunningStatus%3D3%26contestOpenness%3D0%26title%3D%26manager%3D">Contests - Virtual Judge</a></p>
<p>这里每一场比赛都是过去真实发生的录像，你可以 <a href="https://www.zhihu.com/search?q=clone&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">clone</a> 之后和自己的队友一起实操一下。</p>
<ol>
<li>更高深的技巧，更复杂的数据结构（<a href="https://www.zhihu.com/search?q=%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">树链剖分</a>，动态树，可持久化线段树，DLX，后缀自动机，回文树，斜率优化 / 单调队列优化 / 四边形优化 DP，插头 dp，<a href="https://www.zhihu.com/search?q=%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">莫比乌斯反演</a>……）</li>
</ol>
<p>这部分最能体现人与人的差异了… 智商碾压一般就在这部分。而要想拿到金牌，一般来说这些知识都要尽可能掌握。</p>
<p>【参考资料：各种论文，解题报告】</p>
<p>这部分的题目比较杂，因此请自行去 vjudge 上查找….</p>
<p>3.5 同 2.5，并且中国国内的比赛如果已经满足不了你，你可以去</p>
<p><a href="https://link.zhihu.com/?target=https%3A//icpcarchive.ecs.baylor.edu/index.php">https://icpcarchive.ecs.baylor.edu/index.php</a></p>
<p>或者</p>
<p><a href="https://link.zhihu.com/?target=http%3A//codeforces.com/gyms">Gym - Codeforces</a></p>
<p>上找到全世界的区域赛的题目，不过题解就不怎么保证了…</p>
<p>也许你会觉得性价比很低，学这么多东西，才 “ 有可能” 拿到牌子，但是收获的不一定是物质的牌子，还有学习过程的苦辣酸甜的经历（例如各种 WA TLE RE MLE 之后的一次 AC），还有和基友一起并肩作战切套题的同甘共苦，而且还锻炼了自己的学习能力（善用百度，谷歌，<a href="https://www.zhihu.com/search?q=%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">维基百科</a>）。</p>
<p>所以</p>
<p>Good Luck and Have Fun.</p>
<p>=============== 我是 WA 和 AC 之间的分割线 ===============</p>
<p>一言不合就过百赞了，好开心啊~</p>
<p>再补充一下：</p>
<p>这些算法都是说着容易，但是灵活搭配用起来难，然后还能在一定时间内写出来，并顺利通过<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">数据测试</a>拿到 AC 更难。</p>
<p>由于大家手上的模板越来越强大，<a href="https://www.zhihu.com/search?q=%E5%8C%BA%E5%9F%9F%E8%B5%9B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">区域赛</a>一般都不会出现裸的模板题了，一旦出现，肯定就是被大家骂回家的存在。所以在<a href="https://www.zhihu.com/search?q=%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">综合训练</a>的过程中，尽量选择需要动脑的题目，不要一昧追求直接贴一个模板上来 AC 走人特别爽的题目。</p>
<p>一般比较需要动脑的题目类型：贪心，<a href="https://www.zhihu.com/search?q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">动态规划</a>（最好需要加上优化的），组合数学（推<a href="https://www.zhihu.com/search?q=%E7%BB%84%E5%90%88%E6%95%B0%E5%85%AC%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">组合数公式</a>，各种等价变换），图论（网络流，最短路，匹配）的各种建图过程。。。</p>
<p>虽然说年轻人要少水群，多做题，才能进 Finals——kuangbin</p>
<p>但是一直闭门<a href="https://www.zhihu.com/search?q=%E5%8D%95%E5%88%B7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A127265733%7D">单刷</a>也不是一件好事，还是要和大家多多交流心得，这样才能避免自己陷入一个瓶颈。</p>
<hr>
<p><img data-src="https://pic1.zhimg.com/v2-d41c2ceaed8f51999522f903672a521f_l.jpg?source=1def8aca" alt="250"></p>
<h1 id="匿名用户"><a href="#匿名用户" class="headerlink" title="匿名用户"></a>匿名用户</h1><p>2016.10.20 更新</p>
<p>本人背景：大学之前没有搞过竞赛，天赋一般，今年大三出去比赛，今年（2016）区域赛铜。</p>
<p>经过一段时间的反思，结合自己这两年 ACM 训练就 “请问 ACM 的正确入门方式是什么？” 发表一点拙见</p>
<p>目录</p>
<ol>
<li><p>预备知识</p>
</li>
<li><p>基础部分</p>
</li>
<li><p>进阶</p>
</li>
<li><p>做题</p>
</li>
<li><p>训练</p>
</li>
<li><p>杂谈</p>
</li>
</ol>
<p>注：本人对于掌握内容的等级由高到低分为：精通、掌握、了解</p>
<p><strong>0 预备知识</strong></p>
<p><strong>0.1 C++ 基础语法部分</strong></p>
<p>想要入门 ACM，首先你要有一定的编程基础，一般国内的 ACM 选手都是用 C++ 的，所以 C++ 的基本语法你应该有所了解。</p>
<p>0.1.1 库函数的了解</p>
<p>包括但不限于这些库（头文件）：基本输入输出 如 cstdio, iostream，以及一些从 C 的库弄过来的像 cstring, cctype,cmath 等库，具体可以随便百度一个人的代码，然后看看他的头文件</p>
<p>0.1.2 基础知识</p>
<p>如 int 的最大值是多少？int 占多少内存？逻辑运算，循环等，不一一赘述。值得一提的是位运算，应当了解电脑中数据的存储方式，很多时候利用位运算帮助做题非常重要，如树状数组的 lowbit，状压 DP，快速幂等，每次我看到这些的时候都深深的感受到二进制的神奇。</p>
<p><strong>0.2 C++ STL</strong></p>
<p>非常有用的 STL 如 algorithm, vector, list, set, stack, queue, map 等，对于 STL 的学习，本人推荐曾棕根老师的这本书《ACM 程序设计》</p>
<p><a href="https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1bpxa6qb">下载链接</a></p>
<p>，建议初学者了解每一个容器都有什么样的方法以及各个方法的<strong>时间复杂度</strong>。不同的容器利用了不同的数据结构，所以做出相应的操作对于系统的时间开销就大不相同，这点还是挺重要的。原来做一道题，网上看有人用 vector TLE 了，ctrl+f 把所有的 vector 换成 list 就过了。</p>
<p><strong>0.3 Java 基础</strong></p>
<p>个人感觉 Java 并不常用，当然 Java 中的 <strong>BigInteger 类（高精度整数）</strong>是非常有用的，一般情况下，当别人苦逼的粘贴 C++ 的大数类研究方法的时候，Java 可以十行代码优雅的解决问题，同时建议稍微学习一下 BigDecimal 类。</p>
<p><strong>0.4 时间复杂度和空间复杂度的计算</strong></p>
<p>时间复杂度是一个非常重要的概念，相同的问题，有的人给出的方法需要 1s，有的人给出的方法需要 1h，那必然是 1s 的方案在时间方面更优。</p>
<p>空间复杂度同理，如果空间很大，用不完，可以考虑<strong>使用空间换取时间</strong>的方式，很多算法都是以这个为前提的。</p>
<p>研究一下为什么很多题给的数据是 10^5？一般题给出时间是 1s，有的给出 2s, 3s 甚至 15s，是否能给你想法上的暗示？空间复杂度同理。</p>
<p><strong>0.5 ACM 中的基本错误</strong></p>
<p>Wrong Answer： 有自己没有注意到的细节，或者方法错了。</p>
<p>TLE： 运行时间超过给出时间</p>
<p>CE：编译错误，可以点进去看</p>
<p>RE：有时候会 stack overflow，access violation 之类的</p>
<p>PE：空格或者回车有问题</p>
<p><strong>1 基础知识</strong></p>
<p>大一的时候一开始就学了二分 / 三分，BFS、DFS 去找迷宫路径，当时只能循规蹈矩的改模版，当时并不懂栈（stack）和队列（queue），每次都要纠结一下是 FIFO 还是 FILO。后来做着做着题，发现，像 BFS、DFS 这种东西，完全就是个思想啊，哪里有什么模版。此时，我大概可以随手写一些深搜、广搜了，但是我对于这些的应用还是不太敏感，只有多做题才能一直提醒自己灵活的运用这些。</p>
<p>所以，上面这段话，我想表达这样一个事情：基础要学好，达到<strong>精通</strong>的程度，并且要多做题，每一种要做 20 道题左右。（本人训练的时候大概是 10 题的样子，但是感觉并不够，所以建议 20 道）</p>
<p>基础的内容：</p>
<p>BFS、DFS、二分、三分、筛法求素数、快速幂、并查集、矩阵运算及快速幂、最短路相关（Dijkstra， floyd，ford，SPFA）、基础 DP（LIS、LCS、记忆化搜索等）、网络流（EK、Dinic、ISAP+gap）、KMP、线段树、树状数组、二分图、最小生成树（Prim、Kruskal）、计算几何基础等</p>
<p>按照紫书上的来吧，题主看紫书觉得很吃力，其实说实话，我本人看紫书也挺吃力的，建议先从 Vjudge 上找相关专题做，比如高票答案推荐的 kuangbin 带你飞系列的，HDU 的题个人感觉比 UVA 要简单一些。</p>
<p><strong>2. 进阶</strong></p>
<p>这个阶段其实就可以和队友分工搞了，推荐<strong>参考白书以及多校训练</strong>。</p>
<p>我个人对这个阶段的建议是：<strong>一部分内容学会用板子，大概知道板子每一步在干什么，达到了解的程度。一部分内容要掌握原理。</strong>如果实在不知道在干什么，就当用黑箱一样去用。就像你知道 cmath 里有 sqrt，但是很多人完全不知道是怎么实现的。</p>
<p>像很多数论的东西，比如 Lucas，你会用模版大概就可以了，这种东西几乎没有什么改的必要，但是了解一下什么时候用 lucas 求组合数，什么时候打表求组合数之类的还是很有必要的，对于不同情形应使用不同的方法。</p>
<p>但是对于像莫比乌斯反演、sg 函数这种东西，经常就需要对于具体情况分析，然后将思想运用到代码中。</p>
<p>还有一些比较中立的，比如 Tarjan 求联通分量的，改的虽然不多，直接用板子，但是可以存储很多信息，如无向图割点、桥，以及对于强联通分量、双联通分量能发挥不同的功能。只能靠做题量去学习姿势。</p>
<p><strong>3. 做题</strong></p>
<p>ACM 我一直觉得非常靠天赋，对于自己这样天赋一般的人，某些选手简直是智商碾压般的存在。后来发现也不尽然，人家天赋高，做一道题付出的时间相对于自己短，相同的时间可以做更多的题，所以强者更强，弱的还是原来的水平。所以，不管你的天赋强弱，多做题吧，付出和收获都是成正比的，天赋的高低的区别只在于将你的收获乘以 0.8 还是乘以 1.2。比如一个天赋很强的人，做了 400 道题，那么相当于一个普通人做了 400 * 1.2 = 480 题的水平，对于天赋差一点的人来讲，就要做 480 / 0.8 = 600 题。大部分人的智商都是差不多的，真正强的人都是做题做出来的，我个人不太相信有谁看一眼 C++ 的语法就能想出来个主席树、莫队算法的，当达到量的高度以后自然会有质的飞跃。BestCoder 上的</p>
<p><a href="https://link.zhihu.com/?target=http%3A//bestcoder.hdu.edu.cn/rating.php%3Fuser%3Ddoubility">Rating - doubility</a></p>
<p>，我一天无意间看到了人家在 Vjudge 上的做题量 1748，</p>
<p><a href="https://link.zhihu.com/?target=http%3A//vjudge.net/user/doubility">doubility’s profile</a></p>
<p>。Q 神，BNU 做题量 1715，</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.bnuoj.com/v3/userinfo.php%3Fname%3Dquailty">Information of quailty</a></p>
<p>。以上两人还仅限于一个平台，并不知道其他平台还有多少题。就我个人而言，只做了 570 题的水平，其中还包括很多水题。听学长说叉姐的做题量大概是五位数，甚至六位数，所以也并不奇怪人家那么强。在普通人智商差不多的情况下，比赛时金银铜大概都是按做题量分配的，这种大家都喝了无数碗的鸡汤，咱们再干一碗。</p>
<p>回到正题，打开 ACM 的正确方式：</p>
<p><strong>刷题，BestCoder 开了有几十场了，CodeForces 有几百场，你做了多少了？</strong></p>
<p><strong>4. 训练</strong></p>
<p>个人的意志力太薄弱，如果有机会的话还是组队训练吧。有组织的训练至少有竞争，有压力。赛后尽可能的 AK 比赛的题，当时我平时训练的时候没有 ak，现在回想起来，陷入了不会，下次遇到还不会，再遇到还不会的循环。</p>
<p>组队的话尽可能强强联手吧，大家合作拿一个大奖才是最好的结果。当队友心猿意马的时候确实挺让人泄气的，举个杭电某队的例子。</p>
<p>G 题因为题意问题，加上我太蠢没有学会潜在坑点分析 + 脑补。<br>加上 B 题我没有担当起责任，没有解放队友，导致最终打了个铜。</p>
<p>主要原因还是自己太弱。<br>争取在上海的时候拿个金，至少正常水平发挥拿到 ECfinal 参赛权。<br>队友一个进过 WF 没了干劲，另外一个想要找工作，也没了热情。虽然他们水平很厉害，但希望在明年，能够不再和” 马上打比赛的时候嘴里却喊着退役，什么结果都无所谓的人” 组队，消极的队友，会带给你一种无力感，真的很累很累。其实还不如单挑，虽然名次会变低，但是至少充满斗志和热情。</p>
<p>转自 <a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/snowy_smile/article/details/49450163">2015 沈阳赛区总结 与 简单题题解</a></p>
<p><strong>5. 杂谈</strong></p>
<ol>
<li>善用搜索引擎吧，有时候 Google 和百度搜出来的题解不一样，虽然我也不知道他们是怎么排名的。看别人的代码总会发现新姿势。在这里推荐一个利益无关的搜索引擎：</li>
</ol>
<p><a href="https://link.zhihu.com/?target=http%3A//byr.wiki">Byr.wiki· 北邮人导航</a></p>
<ol>
<li><p>写写题解，整理个自己的模版，其实别人能搜到自己的题解和模版，感觉还是挺开心的</p>
</li>
<li><p>别自欺欺人的拿天赋说事了，以绝大部分人努力程度之低，完全到不了拼天赋的地步。沉下心，踏踏实实的学，把紫书白书好好看，做足够量的 BC/CF 题。</p>
</li>
<li><p>只有自己足够强，才能和足够强的人组队，才能比赛拿牌</p>
</li>
<li><p>高票答案谈到性价比，其实我自己也不知道 ACM 的性价比怎么样，但是大学里，有个事做总是好的吧？</p>
</li>
<li><p>原来在网上看到过一篇</p>
</li>
</ol>
<p><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/sjf0115/article/details/8664562">ACM 进阶之路</a></p>
<p>，供大家参考</p>
<p>每次查题解的时候总可以看到两句话，无耻的摘录了</p>
<ol>
<li><p>“每一次 AC 都是一次感动” 这个似乎是一个 CSDN 博主的名字</p>
</li>
<li><p>“人一我百！人十我万！永不放弃~~~ 怀着自信的心，去追逐梦想。” —kuangbin</p>
</li>
</ol>
<p>鄙人水平有限，如有不对的地方还望各位大牛批评指正。</p>
<p>P.S. 被收藏了 60 多次，只有 30 来个赞，如果有用的话请点个赞呗？^^</p>
<hr>
<p><img data-src="https://pic1.zhimg.com/v2-abed1a8c04700ba7d72b45195223e0ff_l.jpg?source=1def8aca" alt="250"></p>
<h1 id="rush-​"><a href="#rush-​" class="headerlink" title="rush ​"></a>rush ​</h1><p>在 icpc 中一定要记住，思维能力和直觉是 acm 能力的核心驱动力，在思维能力达到一定层次以后，算法的学习能力也自然而然上来。</p>
<p>1、快速将语法过关，学习基础算法，如单调栈，dp，树形 dp，dfs，lca，lis，二分，基础图论，整除，取余，尺取，贪心，凸包，逆元等，可以上洛谷官方题单板刷，然后去刷 hdu 入门题，也可以去 acwing 刷刷基础</p>
<p>2、打开 codeforces，千万不要没听过就害怕！只要尝试去做几道题，就会不断收益良多！！！在 problemset 里选 1000 到 1600 级别题中找到适合自己难度的题，可以二分查找 (check 是 30 分钟内能否独立查出），最好选择 contrustive(构造）对思维提高最大，然后看看能不能 30 分钟独立推理出来，一定要独立思考，不要觉得怎么也想不到就觉得受挫，也不要看题解！在怎么也想不到的情况下寻找一条路是锻炼直觉的关键，这种想不到却依旧得去想的经历也是直觉提高的重要铺垫！（除非你是天才），不断去做，如果连续五次在 30 分钟内想出这个级别题，就去做这个级别题 + 100 难度的题，然后坚持想 30 分钟，在想的过程中不断寻找可能的方向，想不出来看题解，有不知道的小技巧，小坑点都要记下来，有不懂的算法或特殊应用可以学会，用这种方法不断把上限提高到 2100.</p>
<p>3、经常打洛谷，牛客，atcoder 和 loj 的比赛，偶尔打 codeforces 比赛 (毕竟对身体不好），不断验证自己的实力，而且打线上比赛很重要的是能提高竞赛能力，同时把比赛中会踩的坑都踩了，一定要打 80 场以上！之后就可以只作为验证实力提高的标准了</p>
<p>4、上限提高到 2100 以后，可以开始板刷 atcoder 的 regular contest 了（arc），先板刷 arc 的 c，倒着刷，从最新的刷到旧的 contest，独立思考，不断想办法找方向，找结论，要想两个小时最好！可能也想不出来，刷完刷 d，一定会感到酣畅淋漓</p>
<p>5、然后用 2 的方法回去板刷 codeforces 的 2200 到 2400 级别题，如果有志同道合的队友可以开始分块分专题了，然后去洛谷找相关专题题单，努力刷紫题黑题，每个小知识点刷个 20 题，还有省选题 (bzoj)</p>
<p>6、然后就到了灵机一动的压轴题提高了，狂刷板刷 arc，agc，再刷 codeforces 的 2500 + 题，经常刷 gym，刷毛营，刷这两年的线上比赛，对标国内强队，刷五个小时 gym 能切实提高长期比赛的实战能力，一定要对名次有要求，甚至可以 8 小时连打两场比赛这样来训练，长期坚持比赛能力一定能大幅提高，可以板刷 sgu，有经典毒瘤题</p>
<p>7、参加国内各种 camp，要求名次</p>
<p>答主是个没有实现梦想的银首败犬，希望喜欢 acmer 且看到文章的同学不要留下我这样的遗憾 qwq</p>
]]></content>
      <tags>
        <tag>常用工具</tag>
        <tag>学习路线</tag>
        <tag>刷题路线</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib</title>
    <url>/posts/9ebec7b8/</url>
    <content><![CDATA[<p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.lines.Line2D.html">matplotlib.lines.Line2D — Matplotlib 3.8.2 documentation</a> 官方教程<br><a href="https://www.matplotlib.org.cn/tutorials/">教程 | Matplotlib</a> 中文文档</p>
]]></content>
      <tags>
        <tag>常用工具</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX</title>
    <url>/posts/ce34127b/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-ru-men">$\LaTeX$入门</a></p>
<p><a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan">$\LaTeX$数学公式大全</a></p>
<p><a href="https://zh.wikibooks.org/wiki/LaTeX">$\LaTeX$$wiki$ 较为全面</a></p>
]]></content>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>kuangbin 专题题目一览 - Virtual Judge</title>
    <url>/posts/8104890e/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/tigerisland45">海岛 Blog</a></p>
<p><a href="https://cn.vjudge.net/group/challenge">挑战 ACM 编程</a>是自由参与组。提供挑战题、水题、白书、紫书和蓝书等等……</p>
<p><a href="https://cn.vjudge.net/contest#category=all&amp;running=0&amp;title=&amp;owner=kuangbin">kuangbin 专题</a></p>
<h2 id="1-专题一-简单搜索"><a href="#1-专题一-简单搜索" class="headerlink" title="1 专题一 简单搜索"></a>1 <a href="https://cn.vjudge.net/contest/65959">专题一 简单搜索</a></h2><ol>
<li><a href="/problem/POJ-1321">POJ 1321</a> 棋盘问题</li>
<li><a href="/problem/POJ-2251">POJ 2251</a> Dungeon Master</li>
<li><a href="/problem/POJ-3278">POJ 3278</a> Catch That Cow</li>
<li><a href="/problem/POJ-3279">POJ 3279</a> Fliptile</li>
<li><a href="/problem/POJ-1426">POJ 1426</a> Find The Multiple</li>
<li><a href="/problem/POJ-3126">POJ 3126</a> Prime Path</li>
<li><a href="/problem/POJ-3087">POJ 3087</a> Shuffle’m Up</li>
<li><a href="/problem/POJ-3414">POJ 3414</a> Pots</li>
<li><a href="/problem/FZU-2150">FZU 2150</a> Fire Game</li>
<li><a href="/problem/UVA-11624">UVA 11624</a> Fire!</li>
<li><a href="/problem/POJ-3984">POJ 3984</a> 迷宫问题</li>
<li><a href="/problem/HDU-1241">HDU 1241</a> Oil Deposits</li>
<li><a href="/problem/HDU-1495">HDU 1495</a> 非常可乐</li>
<li><a href="/problem/HDU-2612">HDU 2612</a> Find a way</li>
</ol>
<h2 id="2-专题二-搜索进阶"><a href="#2-专题二-搜索进阶" class="headerlink" title="2 专题二 搜索进阶"></a>2 <a href="https://cn.vjudge.net/contest/65997">专题二 搜索进阶</a></h2><ol>
<li><a href="/problem/HDU-1043">HDU 1043</a> Eight</li>
<li><a href="/problem/HDU-3567">HDU 3567</a> Eight II</li>
<li><a href="/problem/HDU-2181">HDU 2181</a> 哈密顿绕行世界问题</li>
<li><a href="/problem/HDU-3533">HDU 3533</a> Escape</li>
<li><a href="/problem/HDU-1560">HDU 1560</a> DNA sequence</li>
<li><a href="/problem/ZOJ-2477">ZOJ 2477</a> Magic Cube</li>
<li><a href="/problem/HDU-3085">HDU 3085</a> Nightmare Ⅱ</li>
<li><a href="/problem/HDU-1067">HDU 1067</a> Gap</li>
<li><a href="/problem/HDU-2102">HDU 2102</a> A 计划</li>
<li><a href="/problem/HDU-3001">HDU 3001</a> Travelling</li>
</ol>
<h2 id="3-专题三-Dancing-Links"><a href="#3-专题三-Dancing-Links" class="headerlink" title="3 专题三 Dancing Links"></a>3 <a href="https://cn.vjudge.net/contest/65998">专题三 Dancing Links</a></h2><ol>
<li><a href="/problem/HUST-1017">HUST 1017</a> Exact cover</li>
<li><a href="/problem/ZOJ-3209">ZOJ 3209</a> Treasure Map</li>
<li><a href="/problem/HDU-2295">HDU 2295</a> Radar</li>
<li><a href="/problem/FZU-1686">FZU 1686</a> 神龙的难题</li>
<li><a href="/problem/POJ-1084">POJ 1084</a> Square Destroyer</li>
<li><a href="/problem/POJ-3074">POJ 3074</a> Sudoku</li>
<li><a href="/problem/ZOJ-3122">ZOJ 3122</a> Sudoku</li>
<li><a href="/problem/HDU-4069">HDU 4069</a> Squiggly Sudoku</li>
<li><a href="/problem/HDU-3335">HDU 3335</a> Divisibility</li>
<li><a href="/problem/HDU-4979">HDU 4979</a> A simple math problem.</li>
<li><a href="/problem/HDU-5046">HDU 5046</a> Airport</li>
</ol>
<h2 id="4-专题四-最短路练习"><a href="#4-专题四-最短路练习" class="headerlink" title="4 专题四 最短路练习"></a>4 <a href="https://cn.vjudge.net/contest/66569">专题四 最短路练习</a></h2><ol>
<li><a href="/problem/POJ-2387">POJ 2387</a> Til the Cows Come Home</li>
<li><a href="/problem/POJ-2253">POJ 2253</a> Frogger</li>
<li><a href="/problem/POJ-1797">POJ 1797</a> Heavy Transportation</li>
<li><a href="/problem/POJ-3268">POJ 3268</a> Silver Cow Party</li>
<li><a href="/problem/POJ-1860">POJ 1860</a> Currency Exchange</li>
<li><a href="/problem/POJ-3259">POJ 3259</a> Wormholes</li>
<li><a href="/problem/POJ-1502">POJ 1502</a> MPI Maelstrom</li>
<li><a href="/problem/POJ-3660">POJ 3660</a> Cow Contest</li>
<li><a href="/problem/POJ-2240">POJ 2240</a> Arbitrage</li>
<li><a href="/problem/POJ-1511">POJ 1511</a> Invitation Cards</li>
<li><a href="/problem/POJ-3159">POJ 3159</a> Candies</li>
<li><a href="/problem/POJ-2502">POJ 2502</a> Subway</li>
<li><a href="/problem/POJ-1062">POJ 1062</a> 昂贵的聘礼</li>
<li><a href="/problem/POJ-1847">POJ 1847</a> Tram</li>
<li><a href="/problem/LightOJ-1074">LightOJ 1074</a> Extended Traffic</li>
<li><a href="/problem/HDU-4725">HDU 4725</a> The Shortest Path in Nya Graph</li>
<li><a href="/problem/HDU-3416">HDU 3416</a> Marriage Match IV</li>
<li><a href="/problem/HDU-4370">HDU 4370</a> 0 or 1</li>
<li><a href="/problem/POJ-3169">POJ 3169</a> Layout</li>
</ol>
<h2 id="5-专题五-并查集"><a href="#5-专题五-并查集" class="headerlink" title="5 专题五 并查集"></a>5 <a href="https://cn.vjudge.net/contest/66964">专题五 并查集</a></h2><ol>
<li><a href="/problem/POJ-2236">POJ 2236</a> Wireless Network</li>
<li><a href="/problem/POJ-1611">POJ 1611</a> The Suspects</li>
<li><a href="/problem/HDU-1213">HDU 1213</a> How Many Tables</li>
<li><a href="/problem/HDU-3038">HDU 3038</a> How Many Answers Are Wrong</li>
<li><a href="/problem/POJ-1182">POJ 1182</a> 食物链</li>
<li><a href="/problem/POJ-1417">POJ 1417</a> True Liars</li>
<li><a href="/problem/POJ-1456">POJ 1456</a> Supermarket</li>
<li><a href="/problem/POJ-1733">POJ 1733</a> Parity game</li>
<li><a href="/problem/POJ-1984">POJ 1984</a> Navigation Nightmare</li>
<li><a href="/problem/POJ-2492">POJ 2492</a> A Bug’s Life</li>
<li><a href="/problem/POJ-2912">POJ 2912</a> Rochambeau</li>
<li><a href="/problem/ZOJ-3261">ZOJ 3261</a> Connections in Galaxy War</li>
<li><a href="/problem/HDU-1272">HDU 1272</a> 小希的迷宫</li>
<li><a href="/problem/POJ-1308">POJ 1308</a> Is It A Tree?</li>
</ol>
<h2 id="6-专题六-最小生成树"><a href="#6-专题六-最小生成树" class="headerlink" title="6 专题六 最小生成树"></a>6 <a href="https://cn.vjudge.net/contest/66965">专题六 最小生成树</a></h2><ol>
<li><a href="/problem/POJ-1251">POJ 1251</a> Jungle Roads</li>
<li><a href="/problem/POJ-1287">POJ 1287</a> Networking</li>
<li><a href="/problem/POJ-2031">POJ 2031</a> Building a Space Station</li>
<li><a href="/problem/POJ-2421">POJ 2421</a> Constructing Roads</li>
<li><a href="/problem/ZOJ-1586">ZOJ 1586</a> QS Network</li>
<li><a href="/problem/POJ-1789">POJ 1789</a> Truck History</li>
<li><a href="/problem/POJ-2349">POJ 2349</a> Arctic Network</li>
<li><a href="/problem/POJ-1751">POJ 1751</a> Highways</li>
<li><a href="/problem/POJ-1258">POJ 1258</a> Agri-Net</li>
<li><a href="/problem/POJ-3026">POJ 3026</a> Borg Maze</li>
<li><a href="/problem/POJ-1679">POJ 1679</a> The Unique MST</li>
<li><a href="/problem/HDU-1233">HDU 1233</a> 还是畅通工程</li>
<li><a href="/problem/HDU-1301">HDU 1301</a> Jungle Roads</li>
<li><a href="/problem/HDU-1875">HDU 1875</a> 畅通工程再续</li>
</ol>
<h2 id="7-专题七-线段树"><a href="#7-专题七-线段树" class="headerlink" title="7 专题七 线段树"></a>7 <a href="https://cn.vjudge.net/contest/66989">专题七 线段树</a></h2><ol>
<li><a href="/problem/HDU-1166">HDU 1166</a> 敌兵布阵</li>
<li><a href="/problem/HDU-1754">HDU 1754</a> I Hate It</li>
<li><a href="/problem/POJ-3468">POJ 3468</a> A Simple Problem with Integers</li>
<li><a href="/problem/POJ-2528">POJ 2528</a> Mayor’s posters</li>
<li><a href="/problem/HDU-1698">HDU 1698</a> Just a Hook</li>
<li><a href="/problem/ZOJ-1610">ZOJ 1610</a> Count the Colors</li>
<li><a href="/problem/POJ-3264">POJ 3264</a> Balanced Lineup</li>
<li><a href="/problem/HDU-4027">HDU 4027</a> Can you answer these queries?</li>
<li><a href="/problem/HDU-1540">HDU 1540</a> Tunnel Warfare</li>
<li><a href="/problem/HDU-3974">HDU 3974</a> Assign the task</li>
<li><a href="/problem/HDU-4578">HDU 4578</a> Transformation</li>
<li><a href="/problem/HDU-4614">HDU 4614</a> Vases and Flowers</li>
<li><a href="/problem/HDU-4553">HDU 4553</a> 约会安排</li>
<li><a href="/problem/POJ-1177">POJ 1177</a> Picture</li>
<li><a href="/problem/HDU-1255">HDU 1255</a> 覆盖的面积</li>
<li><a href="/problem/HDU-1542">HDU 1542</a> Atlantis</li>
<li><a href="/problem/HDU-3642">HDU 3642</a> Get The Treasury</li>
</ol>
<h2 id="8-专题八-生成树"><a href="#8-专题八-生成树" class="headerlink" title="8 专题八 生成树"></a>8 <a href="https://cn.vjudge.net/contest/67265">专题八 生成树</a></h2><ol>
<li><a href="/problem/POJ-1679">POJ 1679</a> The Unique MST</li>
<li><a href="/problem/HDU-4081">HDU 4081</a> Qin Shi Huang’s National Road System</li>
<li><a href="/problem/UVA-10600">UVA 10600</a> ACM Contest and Blackout</li>
<li><a href="/problem/UVA-10462">UVA 10462</a> Is There A Second Way Left?</li>
<li><a href="/problem/POJ-3164">POJ 3164</a> Command Network</li>
<li><a href="/problem/UVA-11183">UVA 11183</a> Teen Girl Squad</li>
<li><a href="/problem/HDU-2121">HDU 2121</a> Ice_cream’s world II</li>
<li><a href="/problem/HDU-4009">HDU 4009</a> Transfer water</li>
<li><a href="/problem/UVA-10766">UVA 10766</a> Organising the Organisation</li>
<li><a href="/problem/SPOJ-DETER3">SPOJ DETER3</a> Find The Determinant III</li>
<li><a href="/problem/URAL-1627">URAL 1627</a> Join</li>
<li><a href="/problem/HDU-4305">HDU 4305</a> Lightning</li>
<li><a href="/problem/HDU-4408">HDU 4408</a> Minimum Spanning Tree</li>
<li><a href="/problem/SPOJ-HIGH">SPOJ HIGH</a> Highways</li>
</ol>
<h2 id="9-专题九-连通图"><a href="#9-专题九-连通图" class="headerlink" title="9 专题九 连通图"></a>9 <a href="https://cn.vjudge.net/contest/67418">专题九 连通图</a></h2><ol>
<li><a href="/problem/POJ-1236">POJ 1236</a> Network of Schools</li>
<li><a href="/problem/UVA-315">UVA 315</a> Network</li>
<li><a href="/problem/UVA-796">UVA 796</a> Critical Links</li>
<li><a href="/problem/POJ-3694">POJ 3694</a> Network</li>
<li><a href="/problem/POJ-3177">POJ 3177</a> Redundant Paths</li>
<li><a href="/problem/HDU-4612">HDU 4612</a> Warm up</li>
<li><a href="/problem/HDU-4635">HDU 4635</a> Strongly connected</li>
<li><a href="/problem/HDU-4685">HDU 4685</a> Prince and Princess</li>
<li><a href="/problem/HDU-4738">HDU 4738</a> Caocao’s Bridges</li>
</ol>
<h2 id="10-专题十-匹配问题"><a href="#10-专题十-匹配问题" class="headerlink" title="10 专题十 匹配问题"></a>10 <a href="https://cn.vjudge.net/contest/68127">专题十 匹配问题</a></h2><ol>
<li><a href="/problem/HDU-1045">HDU 1045</a> Fire Net</li>
<li><a href="/problem/HDU-2444">HDU 2444</a> The Accomodation of Students</li>
<li><a href="/problem/HDU-1083">HDU 1083</a> Courses</li>
<li><a href="/problem/HDU-1281">HDU 1281</a> 棋盘游戏</li>
<li><a href="/problem/HDU-2819">HDU 2819</a> Swap</li>
<li><a href="/problem/HDU-2389">HDU 2389</a> Rain on your Parade</li>
<li><a href="/problem/HDU-4185">HDU 4185</a> Oil Skimming</li>
<li><a href="/problem/POJ-3020">POJ 3020</a> Antenna Placement</li>
<li><a href="/problem/HDU-1054">HDU 1054</a> Strategic Game</li>
<li><a href="/problem/HDU-1151">HDU 1151</a> Air Raid</li>
<li><a href="/problem/POJ-2594">POJ 2594</a> Treasure Exploration</li>
<li><a href="/problem/HDU-3829">HDU 3829</a> Cat VS Dog</li>
<li><a href="/problem/POJ-2289">POJ 2289</a> Jamie’s Contact Groups</li>
<li><a href="/problem/POJ-2112">POJ 2112</a> Optimal Milking</li>
<li><a href="/problem/POJ-3189">POJ 3189</a> Steady Cow Assignment</li>
<li><a href="/problem/HDU-2255">HDU 2255</a> 奔小康赚大钱</li>
<li><a href="/problem/HDU-3488">HDU 3488</a> Tour</li>
<li><a href="/problem/URAL-1099">URAL 1099</a> Work Scheduling</li>
<li><a href="/problem/HDU-4687">HDU 4687</a> Boke and Tsukkomi</li>
</ol>
<h2 id="11-专题十一-网络流"><a href="#11-专题十一-网络流" class="headerlink" title="11 专题十一 网络流"></a>11 <a href="https://cn.vjudge.net/contest/68128">专题十一 网络流</a></h2><ol>
<li><a href="/problem/POJ-3436">POJ 3436</a> ACM Computer Factory</li>
<li><a href="/problem/POJ-3281">POJ 3281</a> Dining</li>
<li><a href="/problem/POJ-1087">POJ 1087</a> A Plug for UNIX</li>
<li><a href="/problem/POJ-2195">POJ 2195</a> Going Home</li>
<li><a href="/problem/POJ-2516">POJ 2516</a> Minimum Cost</li>
<li><a href="/problem/POJ-1459">POJ 1459</a> Power Network</li>
<li><a href="/problem/HDU-4280">HDU 4280</a> Island Transport</li>
<li><a href="/problem/HDU-4292">HDU 4292</a> Food</li>
<li><a href="/problem/HDU-4289">HDU 4289</a> Control</li>
<li><a href="/problem/UVA-10480">UVA 10480</a> Sabotage</li>
<li><a href="/problem/HDU-2732">HDU 2732</a> Leapin’ Lizards</li>
<li><a href="/problem/HDU-3338">HDU 3338</a> Kakuro Extension</li>
<li><a href="/problem/HDU-3605">HDU 3605</a> Escape</li>
<li><a href="/problem/HDU-3081">HDU 3081</a> Marriage Match II</li>
<li><a href="/problem/HDU-3416">HDU 3416</a> Marriage Match IV</li>
</ol>
<h2 id="12-专题十二-基础-DP1"><a href="#12-专题十二-基础-DP1" class="headerlink" title="12 专题十二 基础 DP1"></a>12 <a href="https://cn.vjudge.net/contest/68966">专题十二 基础 DP1</a></h2><ol>
<li><a href="/problem/HDU-1024">HDU 1024</a> Max Sum Plus Plus</li>
<li><a href="/problem/HDU-1029">HDU 1029</a> Ignatius and the Princess IV</li>
<li><a href="/problem/HDU-1069">HDU 1069</a> Monkey and Banana</li>
<li><a href="/problem/HDU-1074">HDU 1074</a> Doing Homework</li>
<li><a href="/problem/HDU-1087">HDU 1087</a> Super Jumping! Jumping! Jumping!</li>
<li><a href="/problem/HDU-1114">HDU 1114</a> Piggy-Bank</li>
<li><a href="/problem/HDU-1176">HDU 1176</a> 免费馅饼</li>
<li><a href="/problem/HDU-1260">HDU 1260</a> Tickets</li>
<li><a href="/problem/HDU-1257">HDU 1257</a> 最少拦截系统</li>
<li><a href="/problem/HDU-1160">HDU 1160</a> FatMouse’s Speed</li>
<li><a href="/problem/POJ-1015">POJ 1015</a> Jury Compromise</li>
<li><a href="/problem/POJ-1458">POJ 1458</a> Common Subsequence</li>
<li><a href="/problem/POJ-1661">POJ 1661</a> Help Jimmy</li>
<li><a href="/problem/POJ-2533">POJ 2533</a> Longest Ordered Subsequence</li>
<li><a href="/problem/POJ-3186">POJ 3186</a> Treats for the Cows</li>
<li><a href="/problem/HDU-1078">HDU 1078</a> FatMouse and Cheese</li>
<li><a href="/problem/HDU-2859">HDU 2859</a> Phalanx</li>
<li><a href="/problem/POJ-3616">POJ 3616</a> Milking Time</li>
<li><a href="/problem/POJ-3666">POJ 3666</a> Making the Grade</li>
</ol>
<h2 id="13-专题十三-基础计算几何"><a href="#13-专题十三-基础计算几何" class="headerlink" title="13 专题十三 基础计算几何"></a>13 <a href="https://cn.vjudge.net/contest/68968">专题十三 基础计算几何</a></h2><ol>
<li><a href="/problem/POJ-2318">POJ 2318</a> TOYS</li>
<li><a href="/problem/POJ-2398">POJ 2398</a> Toy Storage</li>
<li><a href="/problem/POJ-3304">POJ 3304</a> Segments</li>
<li><a href="/problem/POJ-1269">POJ 1269</a> Intersecting Lines</li>
<li><a href="/problem/POJ-1556">POJ 1556</a> The Doors</li>
<li><a href="/problem/POJ-2653">POJ 2653</a> Pick-up sticks</li>
<li><a href="/problem/POJ-1066">POJ 1066</a> Treasure Hunt</li>
<li><a href="/problem/POJ-1410">POJ 1410</a> Intersection</li>
<li><a href="/problem/POJ-1696">POJ 1696</a> Space Ant</li>
<li><a href="/problem/POJ-3347">POJ 3347</a> Kadj Squares</li>
<li><a href="/problem/POJ-2826">POJ 2826</a> An Easy Problem?!</li>
<li><a href="/problem/POJ-1039">POJ 1039</a> Pipe</li>
<li><a href="/problem/POJ-3449">POJ 3449</a> Geometric Shapes</li>
<li><a href="/problem/POJ-1584">POJ 1584</a> A Round Peg in a Ground Hole</li>
</ol>
<h2 id="14-专题十四-数论基础"><a href="#14-专题十四-数论基础" class="headerlink" title="14 专题十四 数论基础"></a>14 <a href="https://cn.vjudge.net/contest/70017">专题十四 数论基础</a></h2><ol>
<li><a href="/problem/LightOJ-1370">LightOJ 1370</a> Bi-shoe and Phi-shoe</li>
<li><a href="/problem/LightOJ-1356">LightOJ 1356</a> Prime Independence</li>
<li><a href="/problem/LightOJ-1341">LightOJ 1341</a> Aladdin and the Flying Carpet</li>
<li><a href="/problem/LightOJ-1336">LightOJ 1336</a> Sigma Function</li>
<li><a href="/problem/LightOJ-1282">LightOJ 1282</a> Leading and Trailing</li>
<li><a href="/problem/LightOJ-1259">LightOJ 1259</a> Goldbach`s Conjecture</li>
<li><a href="/problem/LightOJ-1245">LightOJ 1245</a> Harmonic Number (II)</li>
<li><a href="/problem/LightOJ-1236">LightOJ 1236</a> Pairs Forming LCM</li>
<li><a href="/problem/LightOJ-1234">LightOJ 1234</a> Harmonic Number</li>
<li><a href="/problem/LightOJ-1220">LightOJ 1220</a> Mysterious Bacteria</li>
<li><a href="/problem/LightOJ-1214">LightOJ 1214</a> Large Division</li>
<li><a href="/problem/LightOJ-1213">LightOJ 1213</a> Fantasy of a Summation</li>
<li><a href="/problem/LightOJ-1197">LightOJ 1197</a> Help Hanzo</li>
<li><a href="/problem/LightOJ-1138">LightOJ 1138</a> Trailing Zeroes (III)</li>
<li><a href="/problem/UVA-11426">UVA 11426</a> GCD - Extreme (II)</li>
<li><a href="/problem/UVA-11754">UVA 11754</a> Code Feat</li>
<li><a href="/problem/UVA-11916">UVA 11916</a> Emoogle Grid</li>
<li><a href="/problem/POJ-1061">POJ 1061</a> 青蛙的约会</li>
<li><a href="/problem/POJ-2115">POJ 2115</a> C Looooops</li>
<li><a href="/problem/POJ-2116">POJ 2116</a> Death to Binary?</li>
<li><a href="/problem/HDU-2161">HDU 2161</a> Primes</li>
<li><a href="/problem/UVA-11827">UVA 11827</a> Maximum GCD</li>
<li><a href="/problem/UVA-10200">UVA 10200</a> Prime Time</li>
<li><a href="/problem/SGU-106">SGU 106</a> The equation</li>
<li><a href="/problem/POJ-2478">POJ 2478</a> Farey Sequence</li>
<li><a href="/problem/UVA-11752">UVA 11752</a> The Super Powers</li>
</ol>
<h2 id="15-专题十五-数位-DP"><a href="#15-专题十五-数位-DP" class="headerlink" title="15 专题十五 数位 DP"></a>15 <a href="https://cn.vjudge.net/contest/70324">专题十五 数位 DP</a></h2><ol>
<li><a href="/problem/CodeForces-55D">CodeForces 55D</a> Beautiful numbers</li>
<li><a href="/problem/HDU-4352">HDU 4352</a> XHXJ’s LIS</li>
<li><a href="/problem/HDU-2089">HDU 2089</a> 不要 62</li>
<li><a href="/problem/HDU-3555">HDU 3555</a> Bomb</li>
<li><a href="/problem/POJ-3252">POJ 3252</a> Round Numbers</li>
<li><a href="/problem/HDU-3709">HDU 3709</a> Balanced Number</li>
<li><a href="/problem/HDU-3652">HDU 3652</a> B-number</li>
<li><a href="/problem/HDU-4734">HDU 4734</a> F(x)</li>
<li><a href="/problem/ZOJ-3494">ZOJ 3494</a> BCD Code</li>
<li><a href="/problem/HDU-4507">HDU 4507</a> 吉哥系列故事――恨 7 不成妻</li>
<li><a href="/problem/SPOJ-BALNUM">SPOJ BALNUM</a> Balanced Numbers</li>
</ol>
<h2 id="16-专题十六-KMP-amp-扩展-KMP-amp-Manacher"><a href="#16-专题十六-KMP-amp-扩展-KMP-amp-Manacher" class="headerlink" title="16 专题十六 KMP &amp; 扩展 KMP &amp; Manacher"></a>16 <a href="https://cn.vjudge.net/contest/70325">专题十六 KMP &amp; 扩展 KMP &amp; Manacher</a></h2><ol>
<li><a href="/problem/HDU-1711">HDU 1711</a> Number Sequence</li>
<li><a href="/problem/HDU-1686">HDU 1686</a> Oulipo</li>
<li><a href="/problem/HDU-2087">HDU 2087</a> 剪花布条</li>
<li><a href="/problem/HDU-3746">HDU 3746</a> Cyclic Nacklace</li>
<li><a href="/problem/HDU-1358">HDU 1358</a> Period</li>
<li><a href="/problem/HUST-1010">HUST 1010</a> The Minimum Length</li>
<li><a href="/problem/POJ-2406">POJ 2406</a> Power Strings</li>
<li><a href="/problem/POJ-2752">POJ 2752</a> Seek the Name, Seek the Fame</li>
<li><a href="/problem/POJ-3080">POJ 3080</a> Blue Jeans</li>
<li><a href="/problem/HDU-2594">HDU 2594</a> Simpsons’ Hidden Talents</li>
<li><a href="/problem/HDU-3336">HDU 3336</a> Count the string</li>
<li><a href="/problem/HDU-4300">HDU 4300</a> Clairewd’s message</li>
<li><a href="/problem/HDU-1238">HDU 1238</a> Substrings</li>
<li><a href="/problem/HDU-2328">HDU 2328</a> Corporate Identity</li>
<li><a href="/problem/HDU-3374">HDU 3374</a> String Problem</li>
<li><a href="/problem/HDU-2609">HDU 2609</a> How many</li>
<li><a href="/problem/FZU-1901">FZU 1901</a> Period II</li>
<li><a href="/problem/POJ-3746">POJ 3746</a> Teacher YYF</li>
<li><a href="/problem/HDU-3613">HDU 3613</a> Best Reward</li>
<li><a href="/problem/POJ-3376">POJ 3376</a> Finding Palindromes</li>
<li><a href="/problem/POJ-3974">POJ 3974</a> Palindrome</li>
<li><a href="/problem/HDU-4513">HDU 4513</a> 吉哥系列故事――完美队形 II</li>
<li><a href="/problem/HDU-3294">HDU 3294</a> Girls’ research</li>
<li><a href="/problem/HDU-3068">HDU 3068</a> 最长回文</li>
<li><a href="/problem/HDU-4847">HDU 4847</a> Wow! Such Doge!</li>
<li><a href="/problem/HDU-4763">HDU 4763</a> Theme Section</li>
</ol>
<h2 id="17-专题十七-AC-自动机"><a href="#17-专题十七-AC-自动机" class="headerlink" title="17 专题十七 AC 自动机"></a>17 <a href="https://cn.vjudge.net/contest/70326">专题十七 AC 自动机</a></h2><ol>
<li><a href="/problem/HDU-2222">HDU 2222</a> Keywords Search</li>
<li><a href="/problem/HDU-2896">HDU 2896</a> 病毒侵袭</li>
<li><a href="/problem/HDU-3065">HDU 3065</a> 病毒侵袭持续中</li>
<li><a href="/problem/ZOJ-3430">ZOJ 3430</a> Detect the Virus</li>
<li><a href="/problem/POJ-2778">POJ 2778</a> DNA Sequence</li>
<li><a href="/problem/HDU-2243">HDU 2243</a> 考研路茫茫――单词情结</li>
<li><a href="/problem/POJ-1625">POJ 1625</a> Censored!</li>
<li><a href="/problem/HDU-2825">HDU 2825</a> Wireless Password</li>
<li><a href="/problem/HDU-2296">HDU 2296</a> Ring</li>
<li><a href="/problem/HDU-2457">HDU 2457</a> DNA repair</li>
<li><a href="/problem/ZOJ-3228">ZOJ 3228</a> Searching the String</li>
<li><a href="/problem/HDU-3341">HDU 3341</a> Lost’s revenge</li>
<li><a href="/problem/HDU-3247">HDU 3247</a> Resource Archiver</li>
<li><a href="/problem/ZOJ-3494">ZOJ 3494</a> BCD Code</li>
<li><a href="/problem/HDU-4758">HDU 4758</a> Walk Through Squares</li>
<li><a href="/problem/HDU-4511">HDU 4511</a> 小明系列故事――女友的考验</li>
</ol>
<h2 id="18-专题十八-后缀数组"><a href="#18-专题十八-后缀数组" class="headerlink" title="18 专题十八 后缀数组"></a>18 <a href="https://cn.vjudge.net/contest/70655">专题十八 后缀数组</a></h2><ol>
<li><a href="/problem/POJ-1743">POJ 1743</a> Musical Theme</li>
<li><a href="/problem/POJ-3261">POJ 3261</a> Milk Patterns</li>
<li><a href="/problem/SPOJ-DISUBSTR">SPOJ DISUBSTR</a> Distinct Substrings</li>
<li><a href="/problem/SPOJ-SUBST1">SPOJ SUBST1</a> New Distinct Substrings</li>
<li><a href="/problem/POJ-2406">POJ 2406</a> Power Strings</li>
<li><a href="/problem/SPOJ-REPEATS">SPOJ REPEATS</a> Repeats</li>
<li><a href="/problem/POJ-3693">POJ 3693</a> Maximum repetition substring</li>
<li><a href="/problem/POJ-2774">POJ 2774</a> Long Long Message</li>
<li><a href="/problem/POJ-3415">POJ 3415</a> Common Substrings</li>
<li><a href="/problem/POJ-3294">POJ 3294</a> Life Forms</li>
<li><a href="/problem/SPOJ-PHRASES">SPOJ PHRASES</a> Relevant Phrases of Annihilation</li>
<li><a href="/problem/POJ-1226">POJ 1226</a> Substrings</li>
<li><a href="/problem/UVA-11475">UVA 11475</a> Extend to Palindrome</li>
<li><a href="/problem/POJ-3581">POJ 3581</a> Sequence</li>
<li><a href="/problem/POJ-3450">POJ 3450</a> Corporate Identity</li>
<li><a href="/problem/POJ-3080">POJ 3080</a> Blue Jeans</li>
<li><a href="/problem/POJ-2758">POJ 2758</a> Checking the Text</li>
</ol>
<h2 id="19-专题十九-矩阵"><a href="#19-专题十九-矩阵" class="headerlink" title="19 专题十九 矩阵"></a>19 <a href="https://cn.vjudge.net/contest/71746">专题十九 矩阵</a></h2><ol>
<li><a href="/problem/CodeForces-450B">CodeForces 450B</a> Jzzhu and Sequences</li>
<li><a href="/problem/HDU-5015">HDU 5015</a> 233 Matrix</li>
<li><a href="/problem/HDU-4990">HDU 4990</a> Reading comprehension</li>
<li><a href="/problem/UVA-11651">UVA 11651</a> Krypton Number System</li>
<li><a href="/problem/HDU-4965">HDU 4965</a> Fast Matrix Calculation</li>
<li><a href="/problem/UVA-11551">UVA 11551</a> Experienced Endeavour</li>
<li><a href="/problem/UVA-10689">UVA 10689</a> Yet another Number Sequence</li>
<li><a href="/problem/UVA-11149">UVA 11149</a> Power of Matrix</li>
<li><a href="/problem/UVA-10655">UVA 10655</a> Contemplation! Algebra</li>
<li><a href="/problem/UVA-1386">UVA 1386</a> Cellular Automaton</li>
<li><a href="/problem/UVA-10870">UVA 10870</a> Recurrences</li>
<li><a href="/problem/UVA-11885">UVA 11885</a> Number of Battlefields</li>
<li><a href="/problem/HDU-4565">HDU 4565</a> So Easy!</li>
<li><a href="/problem/CodeForces-392C">CodeForces 392C</a> Yet Another Number Sequence</li>
<li><a href="/problem/CodeForces-385E">CodeForces 385E</a> Bear in the Field</li>
<li><a href="/problem/FZU-1911">FZU 1911</a> Construct a Matrix</li>
<li><a href="/problem/UVA-10518">UVA 10518</a> How Many Calls?</li>
<li><a href="/problem/HDU-4549">HDU 4549</a> M 斐波那契数列</li>
<li><a href="/problem/HDU-4686">HDU 4686</a> Arc of Dream</li>
</ol>
<h2 id="20-专题二十-斜率-DP"><a href="#20-专题二十-斜率-DP" class="headerlink" title="20 专题二十 斜率 DP"></a>20 <a href="https://cn.vjudge.net/contest/76380">专题二十 斜率 DP</a></h2><ol>
<li><a href="/problem/HDU-3507">HDU 3507</a> Print Article</li>
<li><a href="/problem/HDU-2829">HDU 2829</a> Lawrence</li>
<li><a href="/problem/HDU-4528">HDU 4528</a> 小明系列故事――捉迷藏</li>
<li><a href="/problem/HDU-1300">HDU 1300</a> Pearls</li>
<li><a href="/problem/HDU-2993">HDU 2993</a> MAX Average Problem</li>
<li><a href="/problem/UVALive-5097">UVALive 5097</a> Cross the Wall</li>
<li><a href="/problem/HDU-3045">HDU 3045</a> Picnic Cows</li>
<li><a href="/problem/HDU-3516">HDU 3516</a> Tree Construction</li>
<li><a href="/problem/POJ-1160">POJ 1160</a> Post Office</li>
<li><a href="/problem/POJ-1180">POJ 1180</a> Batch Scheduling</li>
<li><a href="/problem/POJ-2018">POJ 2018</a> Best Cow Fences</li>
<li><a href="/problem/POJ-3709">POJ 3709</a> K-Anonymous Sequence</li>
<li><a href="/problem/POJ-2841">POJ 2841</a> Navigation Game</li>
<li><a href="/problem/POJ-1260">POJ 1260</a> Pearls</li>
<li><a href="/problem/UVA-12594">UVA 12594</a> Naming Babies</li>
<li><a href="/problem/HDU-3480">HDU 3480</a> Division</li>
<li><a href="/problem/UVALive-6771">UVALive 6771</a> Buffed Buffet</li>
</ol>
<h2 id="21-专题二十一-概率-amp-期望"><a href="#21-专题二十一-概率-amp-期望" class="headerlink" title="21 专题二十一 概率 &amp; 期望"></a>21 <a href="https://cn.vjudge.net/contest/76505">专题二十一 概率 &amp; 期望</a></h2><ol>
<li><a href="/problem/LightOJ-1027">LightOJ 1027</a> A Dangerous Maze</li>
<li><a href="/problem/LightOJ-1030">LightOJ 1030</a> Discovering Gold</li>
<li><a href="/problem/LightOJ-1038">LightOJ 1038</a> Race to 1 Again</li>
<li><a href="/problem/LightOJ-1079">LightOJ 1079</a> Just another Robbery</li>
<li><a href="/problem/LightOJ-1104">LightOJ 1104</a> Birthday Paradox</li>
<li><a href="/problem/LightOJ-1151">LightOJ 1151</a> Snakes and Ladders</li>
<li><a href="/problem/LightOJ-1248">LightOJ 1248</a> Dice (III)</li>
<li><a href="/problem/LightOJ-1265">LightOJ 1265</a> Island of Survival</li>
<li><a href="/problem/LightOJ-1274">LightOJ 1274</a> Beating the Dataset</li>
<li><a href="/problem/LightOJ-1284">LightOJ 1284</a> Lights inside 3D Grid</li>
<li><a href="/problem/LightOJ-1287">LightOJ 1287</a> Where to Run</li>
<li><a href="/problem/LightOJ-1317">LightOJ 1317</a> Throwing Balls into the Baskets</li>
<li><a href="/problem/LightOJ-1321">LightOJ 1321</a> Sending Packets</li>
<li><a href="/problem/LightOJ-1342">LightOJ 1342</a> Aladdin and the Magical Sticks</li>
<li><a href="/problem/LightOJ-1364">LightOJ 1364</a> Expected Cards</li>
<li><a href="/problem/LightOJ-1395">LightOJ 1395</a> A Dangerous Maze (II)</li>
<li><a href="/problem/LightOJ-1408">LightOJ 1408</a> Batting Practice</li>
</ol>
<h2 id="22-专题二十二-区间-DP"><a href="#22-专题二十二-区间-DP" class="headerlink" title="22 专题二十二 区间 DP"></a>22 <a href="https://cn.vjudge.net/contest/77874">专题二十二 区间 DP</a></h2><ol>
<li><a href="/problem/ZOJ-3537">ZOJ 3537</a> Cake</li>
<li><a href="/problem/LightOJ-1422">LightOJ 1422</a> Halloween Costumes</li>
<li><a href="/problem/POJ-2955">POJ 2955</a> Brackets</li>
<li><a href="/problem/CodeForces-149D">CodeForces 149D</a> Coloring Brackets</li>
<li><a href="/problem/POJ-1651">POJ 1651</a> Multiplication Puzzle</li>
<li><a href="/problem/ZOJ-3469">ZOJ 3469</a> Food Delivery</li>
<li><a href="/problem/HDU-4283">HDU 4283</a> You Are the One</li>
<li><a href="/problem/HDU-2476">HDU 2476</a> String painter</li>
</ol>
<h2 id="23-专题二十三-计算几何之半平面交"><a href="#23-专题二十三-计算几何之半平面交" class="headerlink" title="23 专题二十三 计算几何之半平面交"></a>23 <a href="https://cn.vjudge.net/contest/105570">专题二十三 计算几何之半平面交</a></h2><ol>
<li><a href="/problem/POJ-3335">POJ 3335</a> Rotating Scoreboard</li>
<li><a href="/problem/POJ-3130">POJ 3130</a> How I Mathematician Wonder What You Are!</li>
<li><a href="/problem/POJ-1474">POJ 1474</a> Video Surveillance</li>
<li><a href="/problem/POJ-1279">POJ 1279</a> Art Gallery</li>
<li><a href="/problem/POJ-3525">POJ 3525</a> Most Distant Point from the Sea</li>
<li><a href="/problem/POJ-3384">POJ 3384</a> Feng Shui</li>
<li><a href="/problem/POJ-1755">POJ 1755</a> Triathlon</li>
<li><a href="/problem/POJ-2540">POJ 2540</a> Hotter Colder</li>
<li><a href="/problem/POJ-2451">POJ 2451</a> Uyuw’s Concert</li>
<li><a href="/problem/POJ-1271">POJ 1271</a> Nice Milk</li>
<li><a href="/problem/UVA-11722">UVA 11722</a> Joining with Friend</li>
<li><a href="/problem/UVA-11722">UVA 11722</a> he Sea</li>
<li><a href="/problem/UVALive-7295">UVALive 7295</a> Positive Con Sequences</li>
<li><a href="/problem/UVALive-7292">UVALive 7292</a> Refract Facts</li>
<li><a href="/problem/UVALive-7297">UVALive 7297</a> Hounded by Indecision</li>
<li><a href="/problem/UVALive-7346">UVALive 7346</a> Avoiding an Arrrgument</li>
<li><a href="/problem/UVALive-7521">UVALive 7521</a> Kinfolk</li>
<li><a href="/problem/UVALive-7347">UVALive 7347</a> Of the Children</li>
<li><a href="/problem/UVALive-7348">UVALive 7348</a> Talking About Numbers</li>
<li><a href="/problem/UVALive-7349">UVALive 7349</a> The Scheming Gardener</li>
<li><a href="/problem/LightOJ-1433">LightOJ 1433</a> Minimum Arc Distance</li>
<li><a href="/problem/LightOJ-1387">LightOJ 1387</a> Setu</li>
<li><a href="/problem/LightOJ-1338">LightOJ 1338</a> Hidden Secret!</li>
<li><a href="/problem/LightOJ-1261">LightOJ 1261</a> K-SAT Problem</li>
<li><a href="/problem/LightOJ-1249">LightOJ 1249</a> Chocolate Thief</li>
</ol>
<h2 id="24-SHU-训练一——图论一"><a href="#24-SHU-训练一——图论一" class="headerlink" title="24 SHU 训练一——图论一"></a>24 <a href="https://cn.vjudge.net/contest/32331">SHU 训练一——图论一</a></h2><ol>
<li><a href="/problem/LightOJ-1251">LightOJ 1251</a> Forming the Council</li>
<li><a href="/problem/LightOJ-1026">LightOJ 1026</a> Critical Links</li>
<li><a href="/problem/LightOJ-1063">LightOJ 1063</a> Ant Hills</li>
<li><a href="/problem/LightOJ-1291">LightOJ 1291</a> Real Life Traffic</li>
<li><a href="/problem/LightOJ-1308">LightOJ 1308</a> Ant Network</li>
<li><a href="/problem/LightOJ-1074">LightOJ 1074</a> Extended Traffic</li>
<li><a href="/problem/LightOJ-1108">LightOJ 1108</a> Instant View of Big Bang</li>
<li><a href="/problem/LightOJ-1221">LightOJ 1221</a> Travel Company</li>
<li><a href="/problem/LightOJ-1002">LightOJ 1002</a> Country Roads</li>
<li><a href="/problem/LightOJ-1029">LightOJ 1029</a> Civil and Evil Engineer</li>
<li><a href="/problem/LightOJ-1040">LightOJ 1040</a> Donation</li>
<li><a href="/problem/LightOJ-1041">LightOJ 1041</a> Road Construction</li>
<li><a href="/problem/LightOJ-1059">LightOJ 1059</a> Air Ports</li>
<li><a href="/problem/LightOJ-1123">LightOJ 1123</a> Trail Maintenance</li>
<li><a href="/problem/LightOJ-1124">LightOJ 1124</a> Cricket Ranking</li>
<li><a href="/problem/LightOJ-1380">LightOJ 1380</a> Teleport</li>
<li><a href="/problem/LightOJ-1384">LightOJ 1384</a> Stream My Contest</li>
<li><a href="/problem/LightOJ-1348">LightOJ 1348</a> Aladdin and the Return Journey</li>
<li><a href="/problem/LightOJ-1250">LightOJ 1250</a> Village Postman</li>
<li><a href="/problem/LightOJ-1256">LightOJ 1256</a> Word Puzzle</li>
<li><a href="/problem/LightOJ-1003">LightOJ 1003</a> Drunk</li>
</ol>
<h2 id="25-SHU-训练二——图论二-匹配和网络流"><a href="#25-SHU-训练二——图论二-匹配和网络流" class="headerlink" title="25 SHU 训练二——图论二 (匹配和网络流)"></a>25 <a href="https://cn.vjudge.net/contest/32332">SHU 训练二——图论二 (匹配和网络流)</a></h2><ol>
<li><a href="/problem/LightOJ-1149">LightOJ 1149</a> Factors and Multiples</li>
<li><a href="/problem/LightOJ-1150">LightOJ 1150</a> Ghosts!</li>
<li><a href="/problem/LightOJ-1152">LightOJ 1152</a> Hiding Gold</li>
<li><a href="/problem/LightOJ-1429">LightOJ 1429</a> Assassin`s Creed (II)</li>
<li><a href="/problem/LightOJ-1171">LightOJ 1171</a> Knights in Chessboard (II)</li>
<li><a href="/problem/LightOJ-1356">LightOJ 1356</a> Prime Independence</li>
<li><a href="/problem/LightOJ-1153">LightOJ 1153</a> Internet Bandwidth</li>
<li><a href="/problem/LightOJ-1154">LightOJ 1154</a> Penguins</li>
<li><a href="/problem/LightOJ-1155">LightOJ 1155</a> Power Transmission</li>
<li><a href="/problem/LightOJ-1156">LightOJ 1156</a> Jumping Frogs</li>
<li><a href="/problem/LightOJ-1167">LightOJ 1167</a> Dangerous Tunnels</li>
<li><a href="/problem/LightOJ-1176">LightOJ 1176</a> Getting a T-shirt</li>
<li><a href="/problem/LightOJ-1177">LightOJ 1177</a> Angry Programmer</li>
<li><a href="/problem/LightOJ-1330">LightOJ 1330</a> Binary Matrix</li>
<li><a href="/problem/LightOJ-1405">LightOJ 1405</a> The Great Escape</li>
<li><a href="/problem/LightOJ-1071">LightOJ 1071</a> Baker Vai</li>
<li><a href="/problem/LightOJ-1222">LightOJ 1222</a> Gift Packing</li>
<li><a href="/problem/LightOJ-1237">LightOJ 1237</a> Cyber Cafe</li>
<li><a href="/problem/LightOJ-1243">LightOJ 1243</a> Guardian Knights</li>
<li><a href="/problem/LightOJ-1290">LightOJ 1290</a> The Great Merger</li>
<li><a href="/problem/LightOJ-1198">LightOJ 1198</a> Karate Competition</li>
<li><a href="/problem/LightOJ-1431">LightOJ 1431</a> The Party for the Rich</li>
</ol>
<h2 id="26-SHU-训练三——字符串"><a href="#26-SHU-训练三——字符串" class="headerlink" title="26 SHU 训练三——字符串"></a>26 <a href="https://cn.vjudge.net/contest/32333">SHU 训练三——字符串</a></h2><ol>
<li><a href="/problem/LightOJ-1427">LightOJ 1427</a> Substring Frequency (II)</li>
<li><a href="/problem/LightOJ-1258">LightOJ 1258</a> Making Huge Palindromes</li>
<li><a href="/problem/LightOJ-1268">LightOJ 1268</a> Unlucky Strings</li>
<li><a href="/problem/LightOJ-1334">LightOJ 1334</a> Genes in DNA</li>
<li><a href="/problem/LightOJ-1428">LightOJ 1428</a> Melody Comparison</li>
<li><a href="/problem/LightOJ-1314">LightOJ 1314</a> Names for Babies</li>
<li><a href="/problem/LightOJ-1347">LightOJ 1347</a> Aladdin and the Magical Lamp</li>
</ol>
<h2 id="27-SHU-训练四——计算几何"><a href="#27-SHU-训练四——计算几何" class="headerlink" title="27 SHU 训练四——计算几何"></a>27 <a href="https://cn.vjudge.net/contest/32334">SHU 训练四——计算几何</a></h2><ol>
<li><a href="/problem/LightOJ-1056">LightOJ 1056</a> Olympics</li>
<li><a href="/problem/LightOJ-1062">LightOJ 1062</a> Crossed Ladders</li>
<li><a href="/problem/LightOJ-1130">LightOJ 1130</a> Intersection between Circle and Rectangle</li>
<li><a href="/problem/LightOJ-1137">LightOJ 1137</a> Expanding Rods</li>
<li><a href="/problem/LightOJ-1190">LightOJ 1190</a> Sleepwalking</li>
<li><a href="/problem/LightOJ-1208">LightOJ 1208</a> Dangerous Bull! Who Wants to Pull?</li>
<li><a href="/problem/LightOJ-1260">LightOJ 1260</a> Race Track</li>
<li><a href="/problem/LightOJ-1292">LightOJ 1292</a> Laser Shot</li>
<li><a href="/problem/LightOJ-1320">LightOJ 1320</a> Farmers` Tale</li>
<li><a href="/problem/LightOJ-1346">LightOJ 1346</a> Aladdin and the Rocky Mountains</li>
<li><a href="/problem/LightOJ-1358">LightOJ 1358</a> Fukushima Nuclear Blast</li>
<li><a href="/problem/LightOJ-1432">LightOJ 1432</a> Overlapping Sticks</li>
<li><a href="/problem/LightOJ-1203">LightOJ 1203</a> Guarding Bananas</li>
<li><a href="/problem/LightOJ-1239">LightOJ 1239</a> Convex Fence</li>
<li><a href="/problem/LightOJ-1285">LightOJ 1285</a> Drawing Simple Polygon</li>
<li><a href="/problem/LightOJ-1313">LightOJ 1313</a> Protect the Mines</li>
<li><a href="/problem/LightOJ-1418">LightOJ 1418</a> Trees on My Island</li>
</ol>
<h2 id="28-SHU-训练五——矩阵"><a href="#28-SHU-训练五——矩阵" class="headerlink" title="28 SHU 训练五——矩阵"></a>28 <a href="https://cn.vjudge.net/contest/32335">SHU 训练五——矩阵</a></h2><ol>
<li><a href="/problem/LightOJ-1151">LightOJ 1151</a> Snakes and Ladders</li>
<li><a href="/problem/LightOJ-1272">LightOJ 1272</a> Maximum Subset Sum</li>
<li><a href="/problem/LightOJ-1279">LightOJ 1279</a> Graph Coloring</li>
<li><a href="/problem/LightOJ-1288">LightOJ 1288</a> Subsets Forming Perfect Squares</li>
<li><a href="/problem/LightOJ-1052">LightOJ 1052</a> String Growth</li>
<li><a href="/problem/LightOJ-1065">LightOJ 1065</a> Number Sequence</li>
<li><a href="/problem/LightOJ-1070">LightOJ 1070</a> Algebraic Problem</li>
<li><a href="/problem/LightOJ-1131">LightOJ 1131</a> Just Two Functions</li>
<li><a href="/problem/LightOJ-1132">LightOJ 1132</a> Summing up Powers</li>
<li><a href="/problem/LightOJ-1142">LightOJ 1142</a> Summing up Powers (II)</li>
<li><a href="/problem/LightOJ-1160">LightOJ 1160</a> Discovering Paths in Grid</li>
<li><a href="/problem/LightOJ-1172">LightOJ 1172</a> Krypton Number System</li>
<li><a href="/problem/LightOJ-1244">LightOJ 1244</a> Tiles</li>
<li><a href="/problem/LightOJ-1268">LightOJ 1268</a> Unlucky Strings</li>
<li><a href="/problem/LightOJ-1332">LightOJ 1332</a> Kings in Chessboard</li>
<li><a href="/problem/LightOJ-1376">LightOJ 1376</a> Tetromino</li>
</ol>
<h2 id="29-SHU-训练六——博弈"><a href="#29-SHU-训练六——博弈" class="headerlink" title="29 SHU 训练六——博弈"></a>29 <a href="https://cn.vjudge.net/contest/32337">SHU 训练六——博弈</a></h2><ol>
<li><a href="/problem/LightOJ-1355">LightOJ 1355</a> Game of CS</li>
<li><a href="/problem/LightOJ-1186">LightOJ 1186</a> Incredible Chess</li>
<li><a href="/problem/LightOJ-1192">LightOJ 1192</a> Left Right</li>
<li><a href="/problem/LightOJ-1247">LightOJ 1247</a> Matrix Game</li>
<li><a href="/problem/LightOJ-1253">LightOJ 1253</a> Misere Nim</li>
<li><a href="/problem/LightOJ-1393">LightOJ 1393</a> Crazy Calendar</li>
<li><a href="/problem/LightOJ-1199">LightOJ 1199</a> Partitioning Game</li>
<li><a href="/problem/LightOJ-1229">LightOJ 1229</a> Treblecross</li>
<li><a href="/problem/LightOJ-1296">LightOJ 1296</a> Again Stone Game</li>
<li><a href="/problem/LightOJ-1315">LightOJ 1315</a> Game of Hyper Knights</li>
<li><a href="/problem/LightOJ-1344">LightOJ 1344</a> Aladdin and the Game of Bracelets</li>
<li><a href="/problem/LightOJ-1401">LightOJ 1401</a> No More Tic-tac-toe</li>
</ol>
<h2 id="30-SHU-训练七——数论"><a href="#30-SHU-训练七——数论" class="headerlink" title="30 SHU 训练七——数论"></a>30 <a href="https://cn.vjudge.net/contest/32338">SHU 训练七——数论</a></h2><ol>
<li><a href="/problem/LightOJ-1007">LightOJ 1007</a> Mathematically Hard</li>
<li><a href="/problem/LightOJ-1024">LightOJ 1024</a> Eid</li>
<li><a href="/problem/LightOJ-1028">LightOJ 1028</a> Trailing Zeroes (I)</li>
<li><a href="/problem/LightOJ-1035">LightOJ 1035</a> Intelligent Factorial Factorization</li>
<li><a href="/problem/LightOJ-1045">LightOJ 1045</a> Digits of Factorial</li>
<li><a href="/problem/LightOJ-1067">LightOJ 1067</a> Combinations</li>
<li><a href="/problem/LightOJ-1077">LightOJ 1077</a> How Many Points?</li>
<li><a href="/problem/LightOJ-1090">LightOJ 1090</a> Trailing Zeroes (II)</li>
<li><a href="/problem/LightOJ-1098">LightOJ 1098</a> A New Function</li>
<li><a href="/problem/LightOJ-1109">LightOJ 1109</a> False Ordering</li>
<li><a href="/problem/LightOJ-1138">LightOJ 1138</a> Trailing Zeroes (III)</li>
<li><a href="/problem/LightOJ-1163">LightOJ 1163</a> Bank Robbery</li>
<li><a href="/problem/LightOJ-1197">LightOJ 1197</a> Help Hanzo</li>
<li><a href="/problem/LightOJ-1213">LightOJ 1213</a> Fantasy of a Summation</li>
<li><a href="/problem/LightOJ-1214">LightOJ 1214</a> Large Division</li>
<li><a href="/problem/LightOJ-1215">LightOJ 1215</a> Finding LCM</li>
<li><a href="/problem/LightOJ-1220">LightOJ 1220</a> Mysterious Bacteria</li>
<li><a href="/problem/LightOJ-1234">LightOJ 1234</a> Harmonic Number</li>
<li><a href="/problem/LightOJ-1236">LightOJ 1236</a> Pairs Forming LCM</li>
<li><a href="/problem/LightOJ-1245">LightOJ 1245</a> Harmonic Number (II)</li>
<li><a href="/problem/LightOJ-1259">LightOJ 1259</a> Goldbach`s Conjecture</li>
<li><a href="/problem/LightOJ-1278">LightOJ 1278</a> Sum of Consecutive Integers</li>
</ol>
<h2 id="31-2014-国庆训练第一场"><a href="#31-2014-国庆训练第一场" class="headerlink" title="31 2014 国庆训练第一场"></a>31 <a href="https://cn.vjudge.net/contest/57645">2014 国庆训练第一场</a></h2><ol>
<li><a href="/problem/UVALive-4983">UVALive 4983</a> Alignment of Code</li>
<li><a href="/problem/UVALive-4984">UVALive 4984</a> Binary Operation</li>
<li><a href="/problem/UVALive-4985">UVALive 4985</a> Cactus Revolution</li>
<li><a href="/problem/UVALive-4986">UVALive 4986</a> Dome of Circus</li>
<li><a href="/problem/UVALive-4987">UVALive 4987</a> Evacuation Plan</li>
<li><a href="/problem/UVALive-4988">UVALive 4988</a> Factorial Simplification</li>
<li><a href="/problem/UVALive-4989">UVALive 4989</a> Game of 10</li>
<li><a href="/problem/UVALive-4990">UVALive 4990</a> Hands of Poker</li>
<li><a href="/problem/UVALive-4991">UVALive 4991</a> Ideal Path</li>
<li><a href="/problem/UVALive-4992">UVALive 4992</a> Jungle Outpost</li>
<li><a href="/problem/UVALive-4993">UVALive 4993</a> K-Graph Oddity</li>
</ol>
<h2 id="32-2014-国庆训练第二场"><a href="#32-2014-国庆训练第二场" class="headerlink" title="32 2014 国庆训练第二场"></a>32 <a href="https://cn.vjudge.net/contest/57648">2014 国庆训练第二场</a></h2><ol>
<li><a href="/problem/UVALive-5879">UVALive 5879</a> Boring Card Game</li>
<li><a href="/problem/UVALive-5880">UVALive 5880</a> Vigenère Cipher Encryption</li>
<li><a href="/problem/UVALive-5881">UVALive 5881</a> Unique Encryption Keys</li>
<li><a href="/problem/UVALive-5882">UVALive 5882</a> Racing Car Trail</li>
<li><a href="/problem/UVALive-5883">UVALive 5883</a> Stack Machine Programmer</li>
<li><a href="/problem/UVALive-5884">UVALive 5884</a> Strange Regulations</li>
<li><a href="/problem/UVALive-5885">UVALive 5885</a> Vigenère Cipher Analysis</li>
<li><a href="/problem/UVALive-5886">UVALive 5886</a> The Grille</li>
<li><a href="/problem/UVALive-5887">UVALive 5887</a> Unchanged Picture</li>
<li><a href="/problem/UVALive-5888">UVALive 5888</a> Stack Machine Executor</li>
</ol>
<h2 id="33-2014-国庆训练第三场"><a href="#33-2014-国庆训练第三场" class="headerlink" title="33 2014 国庆训练第三场"></a>33 <a href="https://cn.vjudge.net/contest/57650">2014 国庆训练第三场</a></h2><ol>
<li><a href="/problem/URAL-1800">URAL 1800</a> Murphy’s Law</li>
<li><a href="/problem/URAL-1801">URAL 1801</a> The Revolution Cup</li>
<li><a href="/problem/URAL-1802">URAL 1802</a> Cube Puzzle</li>
<li><a href="/problem/URAL-1803">URAL 1803</a> The Czechs’ Rifles</li>
<li><a href="/problem/URAL-1804">URAL 1804</a> The Machinegunners in a Playoff</li>
<li><a href="/problem/URAL-1805">URAL 1805</a> Chapaev and a Cipher Grille</li>
<li><a href="/problem/URAL-1806">URAL 1806</a> Mobile Telegraphs</li>
<li><a href="/problem/URAL-1807">URAL 1807</a> Cartridges for Maxim</li>
<li><a href="/problem/URAL-1808">URAL 1808</a> Chapaev at the Planet Ocean</li>
<li><a href="/problem/URAL-1809">URAL 1809</a> Chapaev and Potatoes</li>
</ol>
<h2 id="34-2014-国庆训练第四场"><a href="#34-2014-国庆训练第四场" class="headerlink" title="34 2014 国庆训练第四场"></a>34 <a href="https://cn.vjudge.net/contest/57657">2014 国庆训练第四场</a></h2><ol>
<li><a href="/problem/UVALive-6743">UVALive 6743</a> Movie</li>
<li><a href="/problem/UVALive-6744">UVALive 6744</a> SMS Poll</li>
<li><a href="/problem/UVALive-6745">UVALive 6745</a> Traitor</li>
<li><a href="/problem/UVALive-6746">UVALive 6746</a> Intelligent Traffic Surveillance</li>
<li><a href="/problem/UVALive-6747">UVALive 6747</a> BitTorrent</li>
<li><a href="/problem/UVALive-6748">UVALive 6748</a> 2D-Solar System</li>
<li><a href="/problem/UVALive-6749">UVALive 6749</a> Bowling Ball</li>
<li><a href="/problem/UVALive-6750">UVALive 6750</a> LED Circuit</li>
<li><a href="/problem/UVALive-6751">UVALive 6751</a> Mixed Flight Plans</li>
<li><a href="/problem/UVALive-6752">UVALive 6752</a> Sweeping Robot</li>
<li><a href="/problem/UVALive-6753">UVALive 6753</a> Wedding Hall</li>
</ol>
<h2 id="35-2014-国庆训练第五场"><a href="#35-2014-国庆训练第五场" class="headerlink" title="35 2014 国庆训练第五场"></a>35 <a href="https://cn.vjudge.net/contest/57658">2014 国庆训练第五场</a></h2><ol>
<li><a href="/problem/UVALive-6671">UVALive 6671</a> ASCII Puzzle</li>
<li><a href="/problem/UVALive-6672">UVALive 6672</a> Bonus Cards</li>
<li><a href="/problem/UVALive-6673">UVALive 6673</a> Cactus Automorphisms</li>
<li><a href="/problem/UVALive-6674">UVALive 6674</a> Dictionary</li>
<li><a href="/problem/UVALive-6675">UVALive 6675</a> Easy Geometry</li>
<li><a href="/problem/UVALive-6676">UVALive 6676</a> Fraud Busters</li>
<li><a href="/problem/UVALive-6677">UVALive 6677</a> Green Energy</li>
<li><a href="/problem/UVALive-6678">UVALive 6678</a> Hack Protection</li>
<li><a href="/problem/UVALive-6679">UVALive 6679</a> Interactive Interception</li>
<li><a href="/problem/UVALive-6680">UVALive 6680</a> Join the Conversation</li>
<li><a href="/problem/UVALive-6681">UVALive 6681</a> Kabaleo Lite</li>
</ol>
<h2 id="36-2014-国庆训练第六场"><a href="#36-2014-国庆训练第六场" class="headerlink" title="36 2014 国庆训练第六场"></a>36 <a href="https://cn.vjudge.net/contest/57675">2014 国庆训练第六场</a></h2><ol>
<li><a href="/problem/UVALive-4843">UVALive 4843</a> Sales</li>
<li><a href="/problem/UVALive-4844">UVALive 4844</a> String Popping</li>
<li><a href="/problem/UVALive-4845">UVALive 4845</a> Password</li>
<li><a href="/problem/UVALive-4846">UVALive 4846</a> Mines</li>
<li><a href="/problem/UVALive-4847">UVALive 4847</a> Binary Search Tree</li>
<li><a href="/problem/UVALive-4848">UVALive 4848</a> Tour Belt</li>
<li><a href="/problem/UVALive-4849">UVALive 4849</a> String Phone</li>
<li><a href="/problem/UVALive-4850">UVALive 4850</a> Installations</li>
<li><a href="/problem/UVALive-4851">UVALive 4851</a> Restaurant</li>
<li><a href="/problem/UVALive-4852">UVALive 4852</a> KTX Train Depot</li>
</ol>
<h2 id="37-2014-国庆训练第七场"><a href="#37-2014-国庆训练第七场" class="headerlink" title="37 2014 国庆训练第七场"></a>37 <a href="https://cn.vjudge.net/contest/57677">2014 国庆训练第七场</a></h2><ol>
<li><a href="/problem/UVALive-6570">UVALive 6570</a> Mixing Colours</li>
<li><a href="/problem/UVALive-6571">UVALive 6571</a> It Can Be Arranged</li>
<li><a href="/problem/UVALive-6572">UVALive 6572</a> Shopping Malls</li>
<li><a href="/problem/UVALive-6573">UVALive 6573</a> Decoding the Hallway</li>
<li><a href="/problem/UVALive-6574">UVALive 6574</a> Joe is learning to speak</li>
<li><a href="/problem/UVALive-6575">UVALive 6575</a> Odd and Even Zeroes</li>
<li><a href="/problem/UVALive-6576">UVALive 6576</a> VivoParc</li>
<li><a href="/problem/UVALive-6577">UVALive 6577</a> Binary Tree</li>
<li><a href="/problem/UVALive-6578">UVALive 6578</a> Trending Topic</li>
<li><a href="/problem/UVALive-6579">UVALive 6579</a> Cleaning the Hallway</li>
</ol>
]]></content>
      <tags>
        <tag>常用工具</tag>
        <tag>学习路线</tag>
        <tag>刷题路线</tag>
      </tags>
  </entry>
  <entry>
    <title>mermaid画图</title>
    <url>/posts/7bb979a9/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/627356428#Mermaid%20%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%BE%E8%A1%A8%EF%BC%9F">Mermaid 使用教程：从入门到精通 - 知乎</a><br>mermaid 画图示例</p>
<ul>
<li>gantt<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">title 工作计划</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">section Section</span><br><span class="line">A task :a1, 2020-01-01, 30d</span><br><span class="line">Another task :after a1 , 20d</span><br><span class="line">section Another</span><br><span class="line">Task in sec :2020-01-12 , 12d</span><br><span class="line">another task : 24d</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title A Gantt Diagram</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section Section</span><br><span class="line">    A task           :a1, 2014-01-01, 30d</span><br><span class="line">    Another task     :after a1  , 20d</span><br><span class="line">    section Another</span><br><span class="line">    Task in sec      :2014-01-12  , 12d</span><br><span class="line">    another task      : 24d</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>graph LR<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[开始] --&gt; B(处理)</span><br><span class="line">B --&gt; C&#123;决策&#125;</span><br><span class="line">C --&gt;|是| D[结束]</span><br><span class="line">C --&gt;|否| B</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>时序图 sequenceDiagram</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Hi Alice, I&#x27;m doing well, thank you!</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>类图 classDiagram</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    Animal &lt;|-- Duck</span><br><span class="line">    Animal &lt;|-- Fish</span><br><span class="line">    Animal &lt;|-- Zebra</span><br><span class="line">    Animal : +int age</span><br><span class="line">    Animal : +String gender</span><br><span class="line">    Animal: +isMammal()</span><br><span class="line">    Animal: +mate()</span><br><span class="line">    class Duck&#123;</span><br><span class="line">      +String beakColor</span><br><span class="line">      +swim()</span><br><span class="line">      +quack()</span><br><span class="line">    &#125;</span><br><span class="line">    class Fish&#123;</span><br><span class="line">      -int sizeInFeet</span><br><span class="line">      -canEat()</span><br><span class="line">    &#125;</span><br><span class="line">    class Zebra&#123;</span><br><span class="line">      +bool is_wild</span><br><span class="line">      +run()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>实体关系图 erDiagram<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">    CUSTOMER ||--o&#123; ORDER : places</span><br><span class="line">    ORDER ||--|&#123; LINE-ITEM : contains</span><br><span class="line">    CUSTOMER &#125;|..|&#123; DELIVERY-ADDRESS : uses</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>pie<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie</span><br><span class="line">  title Example Pie Chart</span><br><span class="line">  &quot;Apples&quot; : 45.0</span><br><span class="line">  &quot;Oranges&quot; : 25.0</span><br><span class="line">  &quot;Bananas&quot; : 15.0</span><br><span class="line">  &quot;Grapes&quot; : 10.0</span><br><span class="line">  &quot;Pears&quot; : 5.0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>[!info]- 更多的<br>Mermaid 支持多种类型的图表，包括:</p>
<ol>
<li>流程图 (Flowchart) : 展示过程、决策和操作流程</li>
<li>序列图 (Sequence Diagram) : 展示对象之间的交互顺序</li>
<li>甘特图(Gantt Chart) : 展示项目计划和进度</li>
<li>词云图 (Class Diagram) : 展示类的结构和关系</li>
<li>饼图 (Pie Chart) : 展示数据占比。</li>
<li>捷径图 (Shortcut) : 简单展示快捷方式</li>
<li>状态图 (State Diagram) : 展示对象状态的转换</li>
<li>用户旅程图 (Journey) : 展示用户如何与应用程序交互</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class Vehicle &#123;</span><br><span class="line">      String vehicleId</span><br><span class="line">      String vehicleType</span><br><span class="line">      double basePrice</span><br><span class="line">      String state</span><br><span class="line">      --</span><br><span class="line">      Vehicle()</span><br><span class="line">      Vehicle(String, String, double)</span><br><span class="line">      Vehicle(String, String)</span><br><span class="line">      Vehicle(String, String, double, String)</span><br><span class="line">      String getVehicleId()</span><br><span class="line">      void setVehicleId(String)</span><br><span class="line">      String getVehicleType()</span><br><span class="line">      void setVehicleType(String)</span><br><span class="line">      double getBasePrice()</span><br><span class="line">      void setBasePrice(double)</span><br><span class="line">      String getState()</span><br><span class="line">      void setState(String)</span><br><span class="line">      String toString()    </span><br><span class="line">    &#125;</span><br><span class="line">    Vehicle &lt;|-- Bus</span><br><span class="line">    Vehicle &lt;|-- Car</span><br><span class="line">    Vehicle &lt;|-- Truck</span><br><span class="line"></span><br><span class="line">    class User &#123;</span><br><span class="line">      String userId</span><br><span class="line">      String userName</span><br><span class="line">      String password</span><br><span class="line">      --</span><br><span class="line">      User(String, String, String)</span><br><span class="line">      User()</span><br><span class="line">      boolean performOperations()</span><br><span class="line">      String getUserName()</span><br><span class="line">      void setUserName(String)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Admin &#123;</span><br><span class="line">      Scanner scanner</span><br><span class="line">      Database database</span><br><span class="line">      --</span><br><span class="line">      Admin(String, String, String)</span><br><span class="line">      Admin()</span><br><span class="line">      void viewVehicle()</span><br><span class="line">      void addVehicle()</span><br><span class="line">      void modifyVehicle()</span><br><span class="line">      void deleteVehicle()</span><br><span class="line">      void viewRevenue()</span><br><span class="line">      boolean performOperations()    </span><br><span class="line">    &#125;</span><br><span class="line">    Admin &quot;uses&quot; --|&gt; User</span><br><span class="line"></span><br><span class="line">    class AdminOperation &#123;</span><br><span class="line">      void viewVehicle()</span><br><span class="line">      void addVehicle()</span><br><span class="line">      void modifyVehicle()</span><br><span class="line">      void deleteVehicle()</span><br><span class="line">      void viewRevenue()</span><br><span class="line">    &#125;</span><br><span class="line">    Admin &lt;|-- AdminOperation</span><br><span class="line"></span><br><span class="line">    class Customer &#123;</span><br><span class="line">      Scanner scanner</span><br><span class="line">      Database database</span><br><span class="line">      --</span><br><span class="line">      Customer(String, String, String)</span><br><span class="line">      Customer()</span><br><span class="line">      void viewVehicle()</span><br><span class="line">      void rentVehicle()</span><br><span class="line">      void changeVehicle()</span><br><span class="line">      boolean performOperations()</span><br><span class="line">    &#125;</span><br><span class="line">    Customer &quot;uses&quot; --|&gt; User</span><br><span class="line"></span><br><span class="line">    class CustomerOperation &#123;</span><br><span class="line">      void viewVehicle()</span><br><span class="line">      void rentVehicle()</span><br><span class="line">      void changeVehicle()</span><br><span class="line">    &#125;</span><br><span class="line">    Customer &lt;|-- CustomerOperation</span><br><span class="line"></span><br><span class="line">    class TransactionRecord &#123;</span><br><span class="line">      String userId</span><br><span class="line">      double amount</span><br><span class="line">      Date transactionTime</span><br><span class="line">      --</span><br><span class="line">      TransactionRecord(String, double)</span><br><span class="line">      String getUserId()</span><br><span class="line">      double getAmount()</span><br><span class="line">      Date getTransactionTime()</span><br><span class="line">      String toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常用的技巧</title>
    <url>/posts/b7e0c80c/</url>
    <content><![CDATA[<blockquote>
<p>[!NOTE] Some Useful Skill</p>
<ul>
<li><code>&lt;u&gt;keyword&lt;/u&gt;</code> 可以将某字符划下划线，例如：<u>keyword</u> .</li>
<li>markdown 的跳转<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">跳转到目标位置</span>](<span class="link">#target</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">## target</span></span><br><span class="line">//在这里是目标位置的内容<span class="code">```</span></span><br><span class="line"><span class="code">利用这个可以写目录</span></span><br><span class="line"><span class="code">```</span>markdown</span><br><span class="line"><span class="section"># 目录</span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">章节一</span>](<span class="link">#章节一</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">章节二</span>](<span class="link">#章节二</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">章节三</span>](<span class="link">#section-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## 章节一</span></span><br><span class="line">内容...</span><br><span class="line"></span><br><span class="line"><span class="section">## 章节二</span></span><br><span class="line">内容...</span><br><span class="line"></span><br><span class="line"><span class="section">## 章节三</span></span><br><span class="line">内容...</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>resorces</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM</title>
    <url>/posts/5d201f0e/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list</span><br><span class="line">from &quot;source/_posts/Demo/ACM&quot;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>All模板</title>
    <url>/posts/a371347f/</url>
    <content><![CDATA[<p>写这个笔记的原因是我记不下来这么多的模板，打比赛时需要打印模板，所以我需要将我常用的模板都放在这里以备不时之需。每个模板的前面都需要先说明这个模板的作用，算法，能达到的效果等，越详细越好。但是不宜在这个事情上花费过多时间.可能写的会很乱，到时候整理就行</p>
<h2 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h2><p><a href="https://www.cnblogs.com/HuXinIO/p/17860679.html">关于CPP算法竞赛中的快读（快写） - 最最最長的電影 - 博客园</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> sym = <span class="literal">false</span>; <span class="type">int</span> res = <span class="number">0</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) sym |= (ch == <span class="string">&#x27;-&#x27;</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> sym ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="type">char</span> *p1, *p2, buf[<span class="number">100000</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> nc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">nc</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="number">48</span> || ch &gt; <span class="number">57</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">nc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="number">48</span> &amp;&amp; ch &lt;= <span class="number">57</span>)</span><br><span class="line">        x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">nc</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是这种似乎在 vscode 会运行的特别慢<br>oi. wiki 给出的快读模板<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #define DEBUG 1  // 调试开关</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IO</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE (1 &lt;&lt; 20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isdigit(x) (x &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line">  <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">  <span class="type">char</span> pbuf[MAXSIZE], *pp;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">IO</span>() : <span class="built_in">p1</span>(buf), <span class="built_in">p2</span>(buf), <span class="built_in">pp</span>(pbuf) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">IO</span>() &#123; <span class="built_in">fwrite</span>(pbuf, <span class="number">1</span>, pp - pbuf, stdout); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function"><span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG  <span class="comment">// 调试，可显示字符</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getchar</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin);</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 ? <span class="string">&#x27; &#x27;</span> : *p1++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">blank</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span> || ch == <span class="string">&#x27;\r&#x27;</span> || ch == <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> sign = <span class="number">0</span>;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>())</span><br><span class="line">      <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>()) x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">      <span class="keyword">for</span> (ch = <span class="built_in">gc</span>(); <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>())</span><br><span class="line">        tmp /= <span class="number">10.0</span>, x += tmp * (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sign) x = -x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">blank</span>(ch); ch = <span class="built_in">gc</span>())</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">for</span> (; !<span class="built_in">blank</span>(ch); ch = <span class="built_in">gc</span>()) *s++ = ch;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="built_in">gc</span>(); <span class="built_in">blank</span>(c); c = <span class="built_in">gc</span>())</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG  <span class="comment">// 调试，可显示字符</span></span></span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (pp - pbuf == MAXSIZE) <span class="built_in">fwrite</span>(pbuf, <span class="number">1</span>, MAXSIZE, stdout), pp = pbuf;</span><br><span class="line">    *pp++ = c;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x, <span class="built_in">push</span>(<span class="string">&#x27;-&#x27;</span>);  <span class="comment">// 负数输出</span></span><br><span class="line">    <span class="type">static</span> T sta[<span class="number">35</span>];</span><br><span class="line">    T top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      sta[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x);</span><br><span class="line">    <span class="keyword">while</span> (top) <span class="built_in">push</span>(sta[--top] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(x), <span class="built_in">push</span>(lastChar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; io;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ACMWeb</title>
    <url>/posts/d12e7db0/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list</span><br><span class="line">from &quot;source/_posts/Demo/ACMWeb&quot;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Resources</title>
    <url>/posts/6d97690d/</url>
    <content><![CDATA[<p>有任何问题打开<a href="https://publish.obsidian.md/help-zh">由此开始 - Obsidian 中文帮助 - Obsidian Publish</a><br><a href="https://publish.obsidian.md/chinesehelp/01+2021%E6%96%B0%E6%95%99%E7%A8%8B/2021%E5%B9%B4%E6%96%B0%E6%95%99%E7%A8%8B">2021年新教程 - Obsidian中文教程 - Obsidian Publish</a></p>
<p><a href="https://csdiy.wiki/">Learn More</a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list</span><br><span class="line">from &quot;source/_posts/Demo/resources&quot;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>The Secret of Pay Attention</title>
    <url>/posts/ebeddfbf/</url>
    <content><![CDATA[<p><mark style="background: #FF5582A6;">The Secret of Pay Attention</mark></p>
<h2 id="1-防止外界干扰："><a href="#1-防止外界干扰：" class="headerlink" title="1 防止外界干扰："></a>1 防止外界干扰：</h2><ol>
<li>控制休息的时机</li>
<li>有意识地去挑战一些麻烦但不艰难的事</li>
<li>不要详细计划</li>
<li>一旦意识到自己走神，就告诉自己，解决完这个问题就休息一下</li>
<li>尽量排除一切外界干扰</li>
<li>手机放兜里<h2 id="2-提升对应领域的算力"><a href="#2-提升对应领域的算力" class="headerlink" title="2 提升对应领域的算力"></a>2 提升对应领域的算力</h2></li>
</ol>
<p>$\text{Patience Is The Key In Life!}$<br>$\text{You Know What I Am Saying}$</p>
]]></content>
      <categories>
        <category>attention</category>
      </categories>
  </entry>
  <entry>
    <title>ActivityHistory</title>
    <url>/posts/0/</url>
    <content><![CDATA[<div width="100%" style="text-align: center"> 
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="543px" viewBox="-0.5 -0.5 543 563" content="&lt;mxfile modified=&quot;2019-06-14T13:27:08.597Z&quot; host=&quot;www.draw.io&quot; agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot; etag=&quot;wAWrvD0696-VqaxQdxfx&quot; version=&quot;10.7.7&quot; type=&quot;device&quot;&gt;&lt;diagram id=&quot;3228e29e-7158-1315-38df-8450db1d8a1d&quot; name=&quot;Page-1&quot;&gt;7ZxLc9sgEMc/ja8dAXoeLVl2Lj3l0LNiYVtTbDyKEjv99EUW8muVmbYDuNFsLpEWoQe/XVj+MJ6wbHtc1MV+812WXEyoVx4nbDahlHjEU/9ay0dnCRLSGdZ1VeqLLobn6hfva2rrW1Xy15sLGylFU+1vjUu52/Flc2Mr6loebi9bSXH71H2x5sDwvCwEtP6oymajrSRMLgVPvFpv9KNjGnUFL8Xy57qWbzv9vAllq9NfV7wt+nvpD33dFKU8XJlYPmFZLWXTHW2PGRdt2/bN1tWbf1J6fu+a75o/qUBJkNCu0nsh3nj/1qd3az769lCVVNOrk/SwqRr+vC+WbclB0Ve2TbMV6oyow+J13/FYVUeunpGe2qI9OhWfP9dTJ6J44SI9N1gmhaxV0U7u2ge9NrX8yQeNPRKmLKtKiP4i1dh0FbxES2Vf10VZqUa4u8FK7pp5sa1E65hPXLzzploWukD7IfH1+dV9p7lPGG0/UFTrnbIt1b25KkylaouqaW/H2o+CADSTd143/Hhl0kAWXG55U3+oS3Spz/xvQVdJhw+LWW85XNyR9dGyufLEs7HQIbA+3//iBupAe8LnXsHQK/5zryDMvVf4I/IK1ZsnJ/sX9oqAAK+I3HtFMCKviFiYTeOv7RUMeAUN3HtFOCKvGENfwXyQV/juvSIakVfMvTjygrF5xSNGkHhEXpHHQejTr+0VMK94RF+RjMgrxpBXBKCvcJ9XhJ4HvOIJuIX6oOaW/yC1a0baBJqxbR5FQkx1wbYqS/GZw12cyvs7p/pX/HQepFFmaChIAF46hNcfoEsNwSUA7gLhGoFL7+H6nmu4UGmcI1w7kRsMJnE24ULBMEe4Rkbd8B5uODjq2oQLdb8ZwjUBNwIplfvIhfJdhnBNwI3BLMr9mAtVuBTh2olc99kyFNOmCNfOmEsG9Q+bcKEm9oR0zaylRsl96BLXdKG2NcWO2QjdEHbMrukSqFFNU0yqzOCNAN7ENV6oUiFdQ1kVGHgZjR3ThTJVmuF01wzex6uQBApVSNdW8PqDOxdt0oVKVY50LeVVgfOBd0CqmqHMbCmvCpynzVCsynGFyMyUN3588EK1aoZ4zeCFelXgeo2IQL0qn+PivZnoDe4FK/d9MxSskK4ZugyMvH7seM5LoWA1X+C2KjPBC1cBXQcvhYIV0rUVvMz1MiCFgtUCl4psjbzO1WYKBatpitFrKW+mrtd5KVSsUtQ0DGkaIHp953gHJSuc9prh64HUKnGdOUPNaobzXlPdM1wucj76QtUqx6mRsY04gK/z/hnKVnPMnq3xZaFrvkMbrTB+DfXP5D6/Yq6X89ngVivkaym/cs8XSldT3I5jbX7kvH9mULxKM5wfGeILpWfXy4JsSL3KcAA2NACH5D6AB38VzCZgqF+1HTROkswxpi73TKrTy+9PnsqufuST5b8B&lt;/diagram&gt;&lt;/mxfile&gt;" style="cursor: pointer; max-width: 100%; max-height: 563px"><defs></defs><g><ellipse cx="277" cy="407" rx="155" ry="155" fill-opacity="0.3" fill="#2f5b7c" stroke="none" pointer-events="none"></ellipse><ellipse cx="277" cy="157" rx="155" ry="155" fill-opacity="0.3" fill="#2f5b7c" stroke="none" pointer-events="none"></ellipse><ellipse cx="357" cy="197" rx="155" ry="155" fill-opacity="0.3" fill="#1699d3" stroke="none" pointer-events="none"></ellipse><ellipse cx="157" cy="277" rx="155" ry="155" fill-opacity="0.3" fill="#736ca8" stroke="none" pointer-events="none"></ellipse><ellipse cx="187" cy="367" rx="155" ry="155" fill-opacity="0.3" fill="#1699d3" stroke="none" pointer-events="none"></ellipse><ellipse cx="187" cy="197" rx="155" ry="155" fill-opacity="0.3" fill="#f08705" stroke="none" pointer-events="none"></ellipse><ellipse cx="357" cy="367" rx="155" ry="155" fill-opacity="0.3" fill="#e85642" stroke="none" pointer-events="none"></ellipse><ellipse cx="387" cy="277" rx="155" ry="155" fill-opacity="0.3" fill="#736ca8" stroke="none" pointer-events="none"></ellipse><g transform="translate(96.5,93.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="10" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 11px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">H</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">H</text></switch></g><g transform="translate(26.5,273.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="10" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 12px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">G</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">G</text></switch></g><g transform="translate(96.5,443.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="9" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 9px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">F</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">F</text></switch></g><g transform="translate(266.5,523.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="10" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 11px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">E</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">E</text></switch></g><g transform="translate(446.5,443.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="10" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 11px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">D</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">D</text></switch></g><g transform="translate(516.5,273.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="10" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 11px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">C</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">C</text></switch></g><g transform="translate(446.5,93.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="10" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 11px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">B</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">B</text></switch></g><g transform="translate(266.5,13.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="10" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 11px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">A</div></div></foreignObject><text x="5" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">A</text></switch></g><g transform="translate(176.5,83.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="20" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 20px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">HA</div></div></foreignObject><text x="10" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">HA</text></switch></g><g transform="translate(342.5,83.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="18" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 20px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">AB</div></div></foreignObject><text x="9" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">AB</text></switch></g><g transform="translate(366.5,163.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="29" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 30px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ABC</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ABC</text></switch></g><g transform="translate(461.5,198.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="20" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 20px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">BC</div></div></foreignObject><text x="10" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">BC</text></switch></g><g transform="translate(416.5,273.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="30" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 31px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">BCD</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">BCD</text></switch></g><g transform="translate(461.5,353.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="20" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 22px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">CD</div></div></foreignObject><text x="10" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">CD</text></switch></g><g transform="translate(341.5,463.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="20" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 20px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ED</div></div></foreignObject><text x="10" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ED</text></switch></g><g transform="translate(366.5,383.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="30" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 31px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">CDE</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">CDE</text></switch></g><g transform="translate(182.5,463.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="18" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 19px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">EF</div></div></foreignObject><text x="9" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">EF</text></switch></g><g transform="translate(257.5,423.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="28" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 29px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">DEF</div></div></foreignObject><text x="14" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">DEF</text></switch></g><g transform="translate(151.5,383.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="29" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 30px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">EFG</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">EFG</text></switch></g><g transform="translate(71.5,358.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="20" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 20px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">FG</div></div></foreignObject><text x="10" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">FG</text></switch></g><g transform="translate(106.5,283.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="30" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 31px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">FGH</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">FGH</text></switch></g><g transform="translate(70.5,193.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="21" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 22px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">GH</div></div></foreignObject><text x="11" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">GH</text></switch></g><g transform="translate(151.5,163.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="30" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 31px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">GHA</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">GHA</text></switch></g><g transform="translate(256.5,113.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="29" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 30px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ABH</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ABH</text></switch></g><g transform="translate(351.5,313.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="29" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 30px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">BDE</div></div></foreignObject><text x="15" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">BDE</text></switch></g><g transform="translate(292.5,368.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="38" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 39px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">CDEF</div></div></foreignObject><text x="19" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">CDEF</text></switch></g><g transform="translate(212.5,363.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="38" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 40px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">DEFG</div></div></foreignObject><text x="19" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">DEFG</text></switch></g><g transform="translate(162.5,313.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="38" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 40px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">EFGH</div></div></foreignObject><text x="19" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">EFGH</text></switch></g><g transform="translate(162.5,233.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="38" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 40px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">FGHA</div></div></foreignObject><text x="19" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">FGHA</text></switch></g><g transform="translate(206.5,173.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="39" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 41px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ABGH</div></div></foreignObject><text x="20" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ABGH</text></switch></g><g transform="translate(292.5,173.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="38" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 40px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ABCH</div></div></foreignObject><text x="19" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ABCH</text></switch></g><g transform="translate(347.5,233.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="38" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 40px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ABCD</div></div></foreignObject><text x="19" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ABCD</text></switch></g><g transform="translate(302.5,323.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="38" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 39px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">BCEF</div></div></foreignObject><text x="19" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">BCEF</text></switch></g><g transform="translate(243.5,203.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="50" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 51px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ABCGH</div></div></foreignObject><text x="25" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ABCGH</text></switch></g><g transform="translate(230.5,273.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="78" height="15" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 14px; font-family: Helvetica; color: rgba(47, 91, 124, 1); line-height: 1.2; vertical-align: top; width: 79px; white-space: nowrap; overflow-wrap: normal; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">ABCDEFGH</div></div></foreignObject><text x="39" y="15" fill="#2F5B7C" text-anchor="middle" font-size="14px" font-family="Helvetica">ABCDEFGH</text></switch></g></g></svg>
</div>

<div width="100%" style="text-align: center"> 
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="527px" viewBox="-0.5 -0.5 527 400" content="&lt;mxfile modified=&quot;2019-06-14T13:09:31.015Z&quot; host=&quot;www.draw.io&quot; agent=&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot; etag=&quot;A6tbMXmsF3seewIKj4iF&quot; version=&quot;10.7.7&quot; type=&quot;device&quot;&gt;&lt;diagram name=&quot;Page-1&quot; id=&quot;16e2658f-23c8-b752-8be9-c03fbebb8bbe&quot;&gt;7VvbcuMoEP0aP8alu+3HSSaZSdVsVWpnL7NPKSxhmR0kVIATe75+wUIyAtuRE8WXjfwS0TQI0acP3S1l4N9kyy8UFPPfSALxwHOS5cD/PPA813Ed8UdKVqUknLilIKUoUUobwXf0C1YjlXSBEsgaipwQzFHRFMYkz2HMGzJAKXluqs0Ibt61ACm0BN9jgG3p3yjhcyV1HWfT8RWidK5uPQ5VxxTEP1NKFrm638DzZ+tf2Z2Bai6lz+YgIc+ayL8d+DeUEF5eZcsbiOXeVttWjrvb0Vuvm8KctxkQJV7oJJNgnETAHY3GVyO1Lr6q9gImYmtUk1A+JynJAb7dSK/XzwvljI5ozXmGxaUrLuES8R/a9T9SZRiq1gOkKIMcUjVQLJmuanXZ0PRl0xyAwRTi63rHbwgmsisnuVwV44DyTxIMhuwOYaxmWLcV/MrbJMYIIdH0RUvT/hdyvlJtsOBEiDYb9I2QQj0L45T8hNXyBCSc9a/uqSAmdWck53cgQ1h6zl+QJiAHSqzu5HqqvW1C2/4KEowsaAx3GL1yMUBTyHfoeKWORIM2sULVF0iEYehKKFCIAUdPTUcCyh/TWk8NFbsNVppCQVDOmTbzgxQIBUUt4lHLGRWxuCa+Df3A2asvLsoVVC3tUTaitc+09J9x7z+9/2zT8S/Sf6LgyP6jHvgJ4AWsjlDDoZ4g5Uic1d8kfB8IQxyRXHRNCeckk6ioDlVp0QSwee1bAKNUqsbCvNINrmcCm7uBta1Hc89qIZ/UrFwidgsmxXoKufZsmcpwaQixiFmoHDnMEIvFjoAckgUbZiQnsvk4BVysb9XgBjlTTDIUt/LeN/oBJRyobb2a7HUMuQlwuRfSVe+4iSVvotrPWohV8fVci64iZ7cXaEg8EGiuBawOmNo5jKnrRs/Ux2FqrwVTR10z9esxapPf8THaRxNniNHgbDDqnfTAVsl118cyhQwxTiirrx7d/9dh7IfGYey0PIy99ziMJz3PfTye81vwXHg2POf3PHeJPBdOzonnXP8MiK5POo5MdEELonO7JrpXlYfMcmkw2l8eMstJhn735aGgZ+FLZGEz2vRHJ2XhoGfhj8fC4cWwsFl0PzsWDnsWvkQWNmPhE7OwY4HmaK9Ke1LtiFQ7r5W3Y0TfNxBZsroaZYDyjWQX9WR3RLLriOqqI/Dgd43vQ3U2hn63Xz+KR+NNQ0vb/ALTtYLcGBU4CO3wehB+lvAR5MHUDmtownDGdwOlADHK0z/WLCMyqqadov3mPIg6DkgQIq9pry1lmuBo5hrZ5rKdvjfX/kjieOYa2+YKe3PpgZ9R1qm/qDiJuSa2ueyy6Ec2V9Ti3dzRzFVNqpvLrp/05joTMqyXvzHXvWUtLVmJMWBMRnm67V5KjzpNSqLXWOfFhEPZ5soZuoE3MdzJMk+4xTyV7I2pi/XFpWOYvcyvrNTFmsg3P2U2J9qRA20mqhTJbMZg53lSlRdpyPuzR94Jkeea5R7zO8q2yDMn8sZnhjz73fy9HQD20Dse9AL3BcS0hV5gfjN8btCzX0jeMzu131UgylCSrOuae6o7tc7LBR4MQf6YgaIQIdKwmK+YnOexWMjnMWo7jYrUAYWeHd/LvxHydhUMo+Kr7pjaptVKHcRunomvLbHbeIufmDDsJnaz36vcs/bVxh5MJwaTSVZueEow2TXHe2bn2T2YLgRM/vuBSTQ3/3Fcnoqbf+v2b/8D&lt;/diagram&gt;&lt;/mxfile&gt;" style="cursor: pointer; max-width: 100%; max-height: 400px"><defs></defs><g><path d="M 66 198 L 66 48 L 236 48 L 236 88" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><path d="M 66 198 L 66 48 L 476 48 L 476 88" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><path d="M 16 248 L 61 248 M 71 218 L 71 278 M 71 248 L 116 248" fill="none" stroke="#000000" stroke-miterlimit="10" transform="rotate(-90,66,248)" pointer-events="none"></path><rect x="57" y="233" width="4" height="30" fill="#000000" stroke="#000000" transform="rotate(-90,66,248)" pointer-events="none"></rect><path d="M 236 188 L 236 228 L 306 228" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><path d="M 236 188 L 236 258" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><rect x="204" y="128" width="64" height="20" fill="#ffffff" stroke="#000000" transform="rotate(-90,236,138)" pointer-events="none"></rect><path d="M 186 138 L 204 138 M 268 138 L 286 138" fill="none" stroke="#000000" stroke-miterlimit="10" transform="rotate(-90,236,138)" pointer-events="none"></path><path d="M 476 188 L 476 258" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><rect x="444" y="128" width="64" height="20" fill="#ffffff" stroke="#000000" transform="rotate(-90,476,138)" pointer-events="none"></rect><path d="M 426 138 L 444 138 M 508 138 L 526 138" fill="none" stroke="#000000" stroke-miterlimit="10" transform="rotate(-90,476,138)" pointer-events="none"></path><path d="M 236 358 L 236 398 L 66 398 L 66 298" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><rect x="204" y="298" width="64" height="20" fill="#ffffff" stroke="#000000" transform="rotate(-90,236,308)" pointer-events="none"></rect><path d="M 186 308 L 204 308 M 268 308 L 286 308" fill="none" stroke="#000000" stroke-miterlimit="10" transform="rotate(-90,236,308)" pointer-events="none"></path><path d="M 476 358 L 476 398 L 66 398 L 66 298" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><rect x="444" y="298" width="64" height="20" fill="#ffffff" stroke="#000000" transform="rotate(-90,476,308)" pointer-events="none"></rect><path d="M 426 308 L 444 308 M 508 308 L 526 308" fill="none" stroke="#000000" stroke-miterlimit="10" transform="rotate(-90,476,308)" pointer-events="none"></path><path d="M 406 228 L 476 228 L 476 258" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><rect x="324" y="218" width="64" height="20" fill="#ffffff" stroke="#000000" pointer-events="none"></rect><path d="M 306 228 L 324 228 M 388 228 L 406 228" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><g transform="translate(199.5,130.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="22" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">R 1</div></div></foreignObject><text x="11" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">R 1</text></switch></g><g transform="translate(199.5,300.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="22" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">R 2</div></div></foreignObject><text x="11" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">R 2</text></switch></g><g transform="translate(337.5,190.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="22" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">R 5</div></div></foreignObject><text x="11" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">R 5</text></switch></g><g transform="translate(487.5,130.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="22" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">R 3</div></div></foreignObject><text x="11" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">R 3</text></switch></g><g transform="translate(487.5,300.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="22" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">R 4</div></div></foreignObject><text x="11" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">R 4</text></switch></g><path d="M 66 28 L 129.63 28" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><path d="M 134.88 28 L 127.88 31.5 L 129.63 28 L 127.88 24.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><g transform="translate(92.5,-0.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="6" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">I</div></div></foreignObject><text x="3" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">I</text></switch></g><path d="M 26 288 L 26 214.37" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><path d="M 26 209.12 L 29.5 216.12 L 26 214.37 L 22.5 216.12 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><g transform="translate(-0.5,245.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="12" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">U</div></div></foreignObject><text x="6" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">U</text></switch></g><path d="M 246 208 L 309.63 208" fill="none" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><path d="M 314.88 208 L 307.88 211.5 L 309.63 208 L 307.88 204.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" pointer-events="none"></path><g transform="translate(267.5,179.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="17" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">I 5</div></div></foreignObject><text x="9" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">I 5</text></switch></g><path d="M 174.56 203.89 C 160.22 195.19 142.07 196.91 129.53 208.17 C 116.99 219.42 112.88 237.66 119.33 253.43 C 125.78 269.2 141.35 278.94 157.95 277.6 C 174.55 276.26 188.45 264.14 192.42 247.53" fill="none" stroke="#000000" stroke-miterlimit="10" transform="translate(156,0)scale(-1,1)translate(-156,0)" pointer-events="none"></path><path d="M 188.57 247.53 L 194.35 237.61 L 196 249.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" transform="translate(156,0)scale(-1,1)translate(-156,0)" pointer-events="none"></path><g transform="translate(142.5,229.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="26" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">Is 1</div></div></foreignObject><text x="13" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">Is 1</text></switch></g><path d="M 374.56 83.89 C 360.22 75.19 342.07 76.91 329.53 88.17 C 316.99 99.42 312.88 117.66 319.33 133.43 C 325.78 149.2 341.35 158.94 357.95 157.6 C 374.55 156.26 388.45 144.14 392.42 127.53" fill="none" stroke="#000000" stroke-miterlimit="10" transform="translate(356,0)scale(-1,1)translate(-356,0)" pointer-events="none"></path><path d="M 388.57 127.53 L 394.35 117.61 L 396 129.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" transform="translate(356,0)scale(-1,1)translate(-356,0)" pointer-events="none"></path><g transform="translate(342.5,109.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="26" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">Is 2</div></div></foreignObject><text x="13" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">Is 2</text></switch></g><path d="M 374.56 283.89 C 360.22 275.19 342.07 276.91 329.53 288.17 C 316.99 299.42 312.88 317.66 319.33 333.43 C 325.78 349.2 341.35 358.94 357.95 357.6 C 374.55 356.26 388.45 344.14 392.42 327.53" fill="none" stroke="#000000" stroke-miterlimit="10" transform="translate(356,0)scale(-1,1)translate(-356,0)" pointer-events="none"></path><path d="M 388.57 327.53 L 394.35 317.61 L 396 329.5 Z" fill="#000000" stroke="#000000" stroke-miterlimit="10" transform="translate(356,0)scale(-1,1)translate(-356,0)" pointer-events="none"></path><g transform="translate(342.5,309.5)"><switch><foreignObject style="overflow: visible" pointer-events="all" width="26" height="17" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 16px; font-family: Verdana; color: rgba(0, 0, 0, 1); line-height: 1.2; vertical-align: top; white-space: nowrap; text-align: center"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; text-align: inherit; text-decoration: inherit">Is 3</div></div></foreignObject><text x="13" y="17" fill="#000000" text-anchor="middle" font-size="16px" font-family="Verdana">Is 3</text></switch></g></g></svg>
</div>

]]></content>
  </entry>
  <entry>
    <title>安排</title>
    <url>/posts/be63186b/</url>
    <content><![CDATA[<h2 id="做题-关于-Tarjan-算法求强连通分量"><a href="#做题-关于-Tarjan-算法求强连通分量" class="headerlink" title="做题 (关于 [[Tarjan 算法求强连通分量]] )"></a>做题 (关于 [[Tarjan 算法求强连通分量]] )</h2><ul>
<li><a href="https://loj.ac/p/10091">Libre</a>  <a href="/posts/209a6e85/">受欢迎的牛</a>   <a href="https://www.luogu.com.cn/problem/P2341">P2341受欢迎的牛 G - 洛谷</a>(一样的题)</li>
<li><a href="https://poj.org/problem?id=1236">Site Unreachable</a> [[Network of Schools]]    or <a href="https://www.luogu.com.cn/problem/P2746">P2746 校园网 Network of Schools</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2863">P2863 The Cow Prom S - 洛谷</a>(模板)         [[P2863 The Cow Prom S - 洛谷]]</li>
<li>[[Proving Equivalences]] </li>
<li>[[The Largest Clique]] </li>
</ul>
<hr>
<h2 id="做题-关于-lca-的题"><a href="#做题-关于-lca-的题" class="headerlink" title="做题 (关于  [[lca]]  的题)"></a>做题 (关于  [[lca]]  的题)</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA） - 洛谷 | 计算机科学教育新生态</a></li>
<li><a href="http://swpuacm.cn/problem/W1032">W1032</a> [[W1032LCA]]</li>
<li><a href="http://swpuacm.cn/problem/W1024">W1024 理论的推演</a> [[W1024理论的推演]] (TODO)(不会)</li>
</ul>
<hr>
<h2 id="做题-关于-基环树-TODO-常常配合树形-dp-使用-树形-dp-还没有学"><a href="#做题-关于-基环树-TODO-常常配合树形-dp-使用-树形-dp-还没有学" class="headerlink" title="做题 (关于[[基环树]])(TODO)常常配合树形 dp 使用(树形 dp 还没有学)"></a>做题 (关于[[基环树]])(TODO)常常配合树形 dp 使用(树形 dp 还没有学)</h2><ul>
<li>[[P2607 骑士 - 洛谷]]</li>
<li>[[P1453 城市环路 - 洛谷]]</li>
<li>[[P1352 没有上司的舞会 - 洛谷]]</li>
<li><a href="https://www.luogu.com.cn/problem/P5022">P5022 [NOIP2018 提高组] 旅行 - 洛谷</a></li>
<li><a href="https://codeforces.com/contest/1907/problem/G#">Problem - G - Codeforces</a> [[../ACMExercises/CodeForces/1907(913div3)#G Lights]]</li>
</ul>
<hr>
<p>其实还有非常多的题没补，时间关系，之后再说了。</p>
<p>之后需要补的题目全部放在这，以防忘记。</p>
<hr>
<p>之后要训练的东西：二分，图论，思维(多训练)，dp，搜索，</p>
<ul>
<li><span style="color:#ffc000">树形 dp 等各种 dp，主要是动脑筋</span></li>
<li><span style="color:#ffc000">dfs，bfs 需要熟练</span></li>
<li>数学相关</li>
<li><span style="color:#ffc000">根号分治</span></li>
<li><span style="color:#00b0f0"> 学习数据结构，图论相关知识，要么忘了，要么不会！</span></li>
<li><span style="color:#00b0f0">二分，二分，二分，狂练二分！</span></li>
<li>将基础一点的算法全部学一遍！</li>
</ul>
<hr>
<p><a href="https://www.luogu.com.cn/training/9391">能力全面提升综合题单 - 题单 - 洛谷</a> 训练新的算法可以从这里学习。</p>
<hr>
<center><mark style="background: #FF5582A6;"> 补题区 </mark></center>

<hr>
<p>[[W1054 永无止境的反转]] <a href="http://swpuacm.cn/problem/W1054">oj | 永无止境的反转</a><br><a href="http://swpuacm.cn/problem/W1039">W1039</a><br><a href="http://swpuacm.cn/problem/W1030">W1030</a> ([[三分法]])<br><a href="http://swpuacm.cn/problem/W1008">W1008</a><br><a href="http://swpuacm.cn/problem/W1013">W1013</a><br><a href="http://swpuacm.cn/problem/W1021">oj | 怒风腾天·欲速则不达</a></p>
<hr>
<center>比赛区：将我要补的或者参加的比赛加进去</center>

<hr>
<p><a href="../ACMExercises/Contest/重庆市赛.md">重庆市赛</a><br><a href="../ACMExercises/Contest/HDU新生赛.md">HDU新生赛</a><br><a href="../ACMExercises/CodeForces/1878(900div3">1878(900div3)</a>.md)<br><a href="../ACMExercises/CodeForces/1921(920div3">1921(920div3)</a>.md)<br><a href="../ACMExercises/CodeForces/1922(Edu161div2">1922(Edu161div2)</a>.md)<br><a href="../ACMExercises/AtCoder/ABC/337.md">337</a></p>
]]></content>
      <tags>
        <tag>arrange</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/posts/3deeff88/</url>
    <content><![CDATA[<p>什么是正则表达式？ </p>
<p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>
<p>一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语 “regex” 或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p>
<p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。 我们使用以下正则表达式来验证一个用户名：</p>
<p><a href="/ziishaned/learn-regex/blob/master/img/regexp-cn.png"><img data-src="https://github.com/ziishaned/learn-regex/raw/master/img/regexp-cn.png" alt=""></a></p>
<p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。 但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p>
<p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p>
<h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1 基本匹配"></a>1 基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;the&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p>
<p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;The&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2 元字符"></a>2 元字符</h2><p>正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>
<table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td align="center">[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td align="center">[^]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td align="center">*</td><td>匹配 &gt;=0 个重复的在 * 号之前的字符。</td></tr><tr><td align="center">+</td><td>匹配 &gt;=1 个重复的 + 号前的字符。</td></tr><tr><td align="center">?</td><td>标记? 之前的字符为可选.</td></tr><tr><td align="center">{n,m}</td><td>匹配 num 个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr><td align="center">(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td align="center">|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td align="center">\</td><td>转义字符, 用于匹配一些保留的字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ |</code></td></tr><tr><td align="center">^</td><td>从开始行开始匹配.</td></tr><tr><td align="center">$</td><td>从末端开始匹配.</td></tr></tbody></table>

<h3 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符"></a>2.1 点运算符</h3><p><code>.</code>是元字符中最简单的例子。 <code>.</code>匹配任意单个字符，但不匹配换行符。 例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;.ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/xc9GkU/1"> </a></p>
<h3 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h3><p>字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[Tt]he&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/2ITLQ4/1"> </a></p>
<p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;ar[.]&quot; =&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/wL3xtE/1"> </a></p>
<h4 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h4><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[^c]ar&quot; =&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/nNNlq3/1"> </a></p>
<h3 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a>2.3 重复次数</h3><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p>
<h4 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a>2.3.1 <code>*</code> 号</h4><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式 <code>a*</code> 匹配 0 或更多个以 a 开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[a-z]*&quot; =&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/7m8me5/1"> </a></p>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配 0 或更多个空格开头和 0 或更多个空格结尾的 cat 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; =&gt; The fat cat sat on the concatenation.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/gGrwuz/1"> </a></p>
<h4 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a>2.3.2 <code>+</code> 号</h4><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。 例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;c.+t&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Dzf9Aa/1"> </a></p>
<h4 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a>2.3.3 <code>?</code> 号</h4><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[T]he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/cIg9zm/1"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[T]?he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/kPpO2x/1"> </a></p>
<h3 id="2-4-号"><a href="#2-4-号" class="headerlink" title="2.4 {} 号"></a>2.4 <code>&#123;&#125;</code> 号</h3><p>在正则表达式中 <code>&#123;&#125;</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 <code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/juM86s/1"> </a></p>
<p>我们可以省略第二个参数。 例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位 0~9 的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Gdy4w5/1"> </a></p>
<p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]&#123;3&#125;</code> 匹配 3 位数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;[0-9]&#123;3&#125;&quot; =&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Sivu30/1"> </a></p>
<h3 id="2-5-特征标群"><a href="#2-5-特征标群" class="headerlink" title="2.5 (...) 特征标群"></a>2.5 <code>(...)</code> 特征标群</h3><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>&#123;&#125;</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/tUxrBG/1"> </a></p>
<h3 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a>2.6 <code>|</code> 或运算符</h3><p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/fBXyX0/1"> </a></p>
<h3 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a>2.7 转码特殊字符</h3><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/DOc5Nu/1"> </a></p>
<h3 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a>2.8 锚点</h3><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h4 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a>2.8.1 <code>^</code> 号</h4><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/5ljjgB/1"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;^(T|t)he&quot; =&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/jXrKne/1"> </a></p>
<h4 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a>2.8.2 <code>$</code> 号</h4><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(at\.)&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/y4Au4D/1"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(at\.)$&quot; =&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/t0AkOd/1"> </a></p>
<h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3 简写字符集"></a>3 简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p>
<table><thead><tr><th align="center">简写</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>除换行符外的所有字符</td></tr><tr><td align="center">\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td align="center">\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td align="center">\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td align="center">\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td align="center">\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td align="center">\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td align="center">\f</td><td>匹配一个换页符</td></tr><tr><td align="center">\n</td><td>匹配一个换行符</td></tr><tr><td align="center">\r</td><td>匹配一个回车符</td></tr><tr><td align="center">\t</td><td>匹配一个制表符</td></tr><tr><td align="center">\v</td><td>匹配一个垂直制表符</td></tr><tr><td align="center">\p</td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table>

<h2 id="4-零宽度断言（前后预查）"><a href="#4-零宽度断言（前后预查）" class="headerlink" title="4 零宽度断言（前后预查）"></a>4 零宽度断言（前后预查）</h2><p>先行断言和后发断言（合称 lookaround）都属于<strong>非捕获组</strong>（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p>
<p>例如，我们希望从下面的输入字符串 <script type="math/tex">4.44` 和 `$10.88` 中获得所有以 `</script> 字符开头的数字，我们将使用以下的正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>。意思是：获取所有包含 <code>.</code> 并且前面是 <code>$</code> 的数字。</p>
<p>零宽度断言如下：</p>
<table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">?=</td><td>正先行断言 - 存在</td></tr><tr><td align="center">?!</td><td>负先行断言 - 排除</td></tr><tr><td align="center">?&lt;=</td><td>正后发断言 - 存在</td></tr><tr><td align="center">?&lt;!</td><td>负后发断言 - 排除</td></tr></tbody></table>

<h3 id="4-1-正先行断言"><a href="#4-1-正先行断言" class="headerlink" title="4.1 ?=... 正先行断言"></a>4.1 <code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。 例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?=\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/IDDARt/1"> </a></p>
<h3 id="4-2-负先行断言"><a href="#4-2-负先行断言" class="headerlink" title="4.2 ?!... 负先行断言"></a>4.2 <code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/V32Npg/1"> </a></p>
<h3 id="4-3-lt-正后发断言"><a href="#4-3-lt-正后发断言" class="headerlink" title="4.3 ?&lt;= ... 正后发断言"></a>4.3 <code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;=(T|t)he\s)(fat|mat)&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/avH165/1"> </a></p>
<h3 id="4-4-lt-负后发断言"><a href="#4-4-lt-负后发断言" class="headerlink" title="4.4 ?&lt;!... 负后发断言"></a>4.4 <code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; =&gt; The cat sat on cat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/8Efx5G/1"> </a></p>
<h2 id="5-标志"><a href="#5-标志" class="headerlink" title="5 标志"></a>5 标志</h2><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>
<table><thead><tr><th align="center">标志</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>忽略大小写。</td></tr><tr><td align="center">g</td><td>全局搜索。</td></tr><tr><td align="center">m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table>

<h3 id="5-1-忽略大小写-Case-Insensitive"><a href="#5-1-忽略大小写-Case-Insensitive" class="headerlink" title="5.1 忽略大小写 (Case Insensitive)"></a>5.1 忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写。 例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;The&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dpQyf9/1"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/The/gi&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<h3 id="5-2-全局搜索-Global-search"><a href="#5-2-全局搜索-Global-search" class="headerlink" title="5.2 全局搜索 (Global search)"></a>5.2 全局搜索 (Global search)</h3><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.(at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/jnk6gM/1"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.(at)/g&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dO1nef/1"> </a></p>
<h3 id="5-3-多行修饰符-Multiline"><a href="#5-3-多行修饰符-Multiline" class="headerlink" title="5.3 多行修饰符 (Multiline)"></a>5.3 多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.at(.)?$/&quot; =&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/hoGMkP/1"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/.at(.)?$/gm&quot; =&gt; The fat</span><br><span class="line">                  cat sat</span><br><span class="line">                  on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/E88WE2/1"> </a></p>
<h2 id="6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#6-贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="6 贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>6 贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/(.*at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/AyAdgJ/1"> </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/(.*?at)/&quot; =&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/AyAdgJ/2"> </a></p>
]]></content>
      <categories>
        <category>resorces</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记（目录）</title>
    <url>/posts/bf19f5be/</url>
    <content><![CDATA[<p>设立本专栏的初衷在于，我意识到我学习过的很多算法，一段时间不使用就会被我遗忘，于是决定把学习这些算法的过程记录下来，也同时分享给其他有需要的人。</p>
<p>本专栏默认读者会使用基本的<strong>C++语言</strong>且掌握基本的<strong>贪心、搜索、动态规划</strong>思想。</p>
<hr>
<p>方括号里的编号表示笔记中用到的前置算法（并不意味着该算法必须用到）。分类仅作参考，不一定准确。需要说明的是，因为作者的主攻题型具有偏向性，所以各种类型的笔记数量很可能不平衡。</p>
<p>本系列笔记写作时间跨度长，很多文章我写的时候并没有对相关算法有很深的了解，而且很多文章经过多次缝缝补补可能显得混乱，如果您阅读不畅请见谅。</p>
<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1 动态规划"></a>1 动态规划</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/121032448">算法学习笔记(27): 最长上升子序列</a> 【20】 </li>
<li><a href="https://zhuanlan.zhihu.com/p/311598413">算法学习笔记(58): 最长公共子序列</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/348851463">算法学习笔记(68): 数位DP</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/363772434">算法学习笔记(77): 凸壳优化DP</a>【65，66】</li>
<li><a href="https://zhuanlan.zhihu.com/p/398419302">算法学习笔记(79): 四边形不等式优化DP</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/402195848">算法学习笔记(80): 悬线法</a></li>
</ul>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93795692">算法学习笔记(2) : 树状数组</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/97813717">算法学习笔记(7)：种类并查集</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/105439034">算法学习笔记(12): ST表</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/106118909">算法学习笔记(14): 线段树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/106353082">算法学习笔记(15): 珂朵莉树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/114268236">算法学习笔记(23): 分块</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/115243708">算法学习笔记(24): 莫队</a>【23】</li>
<li><a href="https://zhuanlan.zhihu.com/p/174830050">算法学习笔记(44): 01字典树</a>【43】</li>
<li><a href="https://zhuanlan.zhihu.com/p/177063180">算法学习笔记(45): 二叉搜索树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/180545164">算法学习笔记(46): 替罪羊树</a>【45】</li>
<li><a href="https://zhuanlan.zhihu.com/p/187618450">算法学习笔记(47): 二叉堆</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/246255556">算法学习笔记(49): 线段树的拓展</a>【14】</li>
<li><a href="https://zhuanlan.zhihu.com/p/250565583">算法学习笔记(50): 可持久化线段树</a>【19，49】</li>
<li><a href="https://zhuanlan.zhihu.com/p/346354943">算法学习笔记(66): 单调队列</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346536592">算法学习笔记(67): 单调栈</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/361935620">算法学习笔记(76): zkw线段树</a>【14】</li>
<li><a href="https://zhuanlan.zhihu.com/p/402878030">算法学习笔记(81): 划分树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/575513452">算法学习笔记(88): 线段树合并</a>【49】</li>
</ul>
<h2 id="3-图论"><a href="#3-图论" class="headerlink" title="3 图论"></a>3 图论</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/94890350">算法学习笔记(3) : 存图</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/96229700">算法学习笔记(5)：匈牙利算法</a> 【3】</li>
<li><a href="https://zhuanlan.zhihu.com/p/96621396">算法学习笔记(6)：最短路问题</a> 【3】</li>
<li><a href="https://zhuanlan.zhihu.com/p/104764488">算法学习笔记(11): 差分约束</a> 【6】</li>
<li><a href="https://zhuanlan.zhihu.com/p/260112913">算法学习笔记(53): 拓扑排序</a>【3】</li>
<li><a href="https://zhuanlan.zhihu.com/p/266356742">算法学习笔记(57): 传递闭包</a>【6】</li>
<li><a href="https://zhuanlan.zhihu.com/p/349530425">算法学习笔记(69): 强连通分量</a>【53】</li>
<li><a href="https://zhuanlan.zhihu.com/p/350856939">算法学习笔记(70): 割点和桥</a>【69】</li>
<li><a href="https://zhuanlan.zhihu.com/p/583236322">算法学习笔记(93): 同余最短路</a>【6】</li>
</ul>
<h2 id="4-树上问题"><a href="#4-树上问题" class="headerlink" title="4 树上问题"></a>4 树上问题</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/113042043">算法学习笔记(21): 最近公共祖先</a>【3】</li>
<li><a href="https://zhuanlan.zhihu.com/p/319713720">算法学习笔记(59): 重链剖分</a>【14，21】</li>
<li><a href="https://zhuanlan.zhihu.com/p/357938161">算法学习笔记(72): 树的重心</a>【3】</li>
<li><a href="https://zhuanlan.zhihu.com/p/359209926">算法学习笔记(73): 点分治</a>【72】</li>
<li><a href="https://zhuanlan.zhihu.com/p/565967113">算法学习笔记(86): 树上启发式合并</a>【59】</li>
<li><a href="https://zhuanlan.zhihu.com/p/567864219">算法学习笔记(87): 长链剖分</a>【59】</li>
</ul>
<h2 id="5-网络流"><a href="#5-网络流" class="headerlink" title="5 网络流"></a>5 网络流</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/122375531">算法学习笔记(28): 网络流</a>【3】</li>
<li><a href="https://zhuanlan.zhihu.com/p/123308502">算法学习笔记(29): 二者取一式问题</a>【28】</li>
<li><a href="https://zhuanlan.zhihu.com/p/125759333">算法学习笔记(30): 路径覆盖问题</a>【28】</li>
<li><a href="https://zhuanlan.zhihu.com/p/127046673">算法学习笔记(31): 最小费用最大流</a>【6，28】</li>
<li><a href="https://zhuanlan.zhihu.com/p/324507636">算法学习笔记(60): 上下界网络流</a>【28，31】</li>
</ul>
<h2 id="6-数论"><a href="#6-数论" class="headerlink" title="6 数论"></a>6 数论</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100587745">算法学习笔记(9)：逆元</a> 【4, 8】</li>
<li><a href="https://zhuanlan.zhihu.com/p/103394468">算法学习笔记(10): 中国剩余定理</a> 【9】</li>
<li><a href="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17): 素数筛</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/108422764">算法学习笔记(18): 欧拉函数</a>【17】</li>
<li><a href="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25): 卢卡斯定理</a>【9】</li>
<li><a href="https://zhuanlan.zhihu.com/p/131536831">算法学习笔记(33): 拓展欧拉定理</a>【4，18】</li>
<li><a href="https://zhuanlan.zhihu.com/p/132603308">算法学习笔记(34): 大步小步算法</a>【4，8，33】</li>
<li><a href="https://zhuanlan.zhihu.com/p/137619492">算法学习笔记(35): 狄利克雷卷积</a>【18】</li>
<li><a href="https://zhuanlan.zhihu.com/p/138038817">算法学习笔记(36): 莫比乌斯反演</a>【35】</li>
<li><a href="https://zhuanlan.zhihu.com/p/166043237">算法学习笔记(40): 原根</a>【4，18】</li>
<li><a href="https://zhuanlan.zhihu.com/p/166123245">算法学习笔记(41): 二次剩余</a>【4】</li>
<li><a href="https://zhuanlan.zhihu.com/p/220203643">算法学习笔记(48): 米勒-拉宾素性检验</a>【41】</li>
<li><a href="https://zhuanlan.zhihu.com/p/258336043">算法学习笔记(52): 杜教筛</a>【36】</li>
<li><a href="https://zhuanlan.zhihu.com/p/267884783">算法学习笔记(55): Pollard-Rho算法</a>【48】</li>
</ul>
<h2 id="7-计算几何"><a href="#7-计算几何" class="headerlink" title="7 计算几何"></a>7 计算几何</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/338057154">算法学习笔记(63): 计算几何基础</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338272449">算法学习笔记(64): 极角排序</a>【63】</li>
<li><a href="https://zhuanlan.zhihu.com/p/340442313">算法学习笔记(65): 凸包</a>【64】</li>
</ul>
<h2 id="8-组合数学"><a href="#8-组合数学" class="headerlink" title="8 组合数学"></a>8 组合数学</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/106522599">算法学习笔记(16): 生成函数</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/265991683">算法学习笔记(54): Pólya定理</a>【36】</li>
<li><a href="https://zhuanlan.zhihu.com/p/272721663">算法学习笔记(56): 康托展开</a>【2，45】</li>
<li><a href="https://zhuanlan.zhihu.com/p/360512296">算法学习笔记(75): Gosper’s Hack</a>【2】</li>
</ul>
<h2 id="9-字符串"><a href="#9-字符串" class="headerlink" title="9 字符串"></a>9 字符串</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/105629613">算法学习笔记(13): KMP算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/173981140">算法学习笔记(43): 字典树</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/403256847">算法学习笔记(82): Z算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/404216115">算法学习笔记(83): Manacher算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/408261126">算法学习笔记(84): 后缀数组</a>【22】</li>
<li><a href="https://zhuanlan.zhihu.com/p/410131141">算法学习笔记(85): 后缀自动机</a>【43】</li>
<li><a href="https://zhuanlan.zhihu.com/p/569429689">算法学习笔记(89): AC自动机</a>【13，43】</li>
<li><a href="https://zhuanlan.zhihu.com/p/579310640">算法学习笔记(90): 序列自动机</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/579893448">算法学习笔记(91): 广义后缀自动机</a>【43，85】</li>
<li><a href="https://zhuanlan.zhihu.com/p/581946378">算法学习笔记(92): 回文自动机</a>【85】</li>
</ul>
<h2 id="10-线性代数"><a href="#10-线性代数" class="headerlink" title="10 线性代数"></a>10 线性代数</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/139074556">算法学习笔记(37): 线性基</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/139891282">算法学习笔记(38): 高斯消元</a></li>
</ul>
<h2 id="11-多项式"><a href="#11-多项式" class="headerlink" title="11 多项式"></a>11 多项式</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/128661674">算法学习笔记(32): 快速傅里叶变换</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/166197713">算法学习笔记(42): 快速数论变换</a>【9，32，40】</li>
</ul>
<h2 id="12-博弈论"><a href="#12-博弈论" class="headerlink" title="12 博弈论"></a>12 博弈论</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/257013159">算法学习笔记(51): SG函数</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/359334008">算法学习笔记(74): 二分图博弈</a>【5，28】</li>
</ul>
<h2 id="13-其他"><a href="#13-其他" class="headerlink" title="13 其他"></a>13 其他</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/112497527">算法学习笔记(19): 离散化</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/112504092">算法学习笔记(20): 二维偏序</a> 【2，19】</li>
<li><a href="https://zhuanlan.zhihu.com/p/113900235">算法学习笔记(22): 基数排序</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/119349440">算法学习笔记(26): 双向搜索</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/147623236">算法学习笔记(39): 调度场算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/332996578">算法学习笔记(61): cdq分治</a>【20，27】</li>
<li><a href="https://zhuanlan.zhihu.com/p/337752413">算法学习笔记(62): 三分法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/351638078">算法学习笔记(71): 2-SAT</a>【69】</li>
<li><a href="https://zhuanlan.zhihu.com/p/387744743">算法学习笔记(78): 摩尔投票</a>【14】</li>
</ul>
]]></content>
      <categories>
        <category>resorces</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>学习路线</tag>
        <tag>刷题路线</tag>
      </tags>
  </entry>
  <entry>
    <title>高质量的图标</title>
    <url>/posts/e81adab3/</url>
    <content><![CDATA[<p><a href="https://www.flaticon.com/icon-fonts-most-downloaded?weight=regular&amp;type=uicon">Fetching Title#le3z</a></p>
<p><a href="https://www.flaticon.com/free-icon-font/add_3914248">Add icon font - Free ui icon fonts</a></p>
<p>![[../../../images/Z-attachment/instagram.png]]</p>
]]></content>
      <categories>
        <category>resorces</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>1822D</title>
    <url>/posts/d4d25663/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1906/M">Problem - 1906M - Codeforces</a><br><a href="https://codeforces.com/problemset/problem/1831/A">Problem - 1831A - Codeforces</a><br><a href="https://codeforces.com/problemset/problem/1684/B">Problem - 1684B - Codeforces</a><br><a href="https://codeforces.com/problemset/problem/1861/B">Problem - 1861B - Codeforces</a></p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>1878(900div3)</title>
    <url>/posts/10aba81b/</url>
    <content><![CDATA[<h2 id="A-How-Much-Does-Daytona-Cost"><a href="#A-How-Much-Does-Daytona-Cost" class="headerlink" title="A . How Much Does Daytona Cost?"></a>A . How Much Does Daytona Cost?</h2><p>我们将一个整数定义为子段中最常见的整数，如果它在该子段中出现的次数大于该子段中任何其他整数出现的次数。数组的子数段是数组 $a$ 中元素的连续数段。</p>
<p>给定一个大小为 $n$ 的数组 $a$ 和一个整数 $k$ ，判断 $a$ 中是否存在一个非空子段，其中 $k$ 是最常见的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">110</span>], num[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], num[a[i]]++;</span><br><span class="line">    <span class="keyword">if</span> (num[m])</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Aleksa-and-Stack"><a href="#B-Aleksa-and-Stack" class="headerlink" title="B. Aleksa and Stack"></a>B. Aleksa and Stack</h2><p>给出 $a$ 数组，构造一个数组满足：$3\cdot a<em>{i+2}$ 不能被 $a</em>{i}+a_{i+1}$ 整除。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>方法很多。</p>
<p>$\text{Solution 1:}$ 假设 $a<em>{i},a</em>{i+1}，a_{i+2}$ 都相差 $1$.</p>
<script type="math/tex; mode=display">k=\frac{3\times a_{i+2}}{a_{i}+a_{i+1}}=\frac{3\times a_{i}+6}{2\times a_{i}+1}=1+\frac{a_{i}+5}{2\times a_{i}+1}</script><p>当 $a<em>{i}+5&lt;2\times a</em>{i}+1$ 时，可以保证后面的 $k$ 都不可能为整数</p>
<p>$\text{ Solution 2:}$ 序列全为奇数即可。</p>
<script type="math/tex; mode=display">3\times a_{i+2}(odd),a_{i}+a_{i+1}(even) \cap\frac{odd}{even}\neq \text{integer}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        cout &lt;&lt; i++ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Vasilije-in-Cacak"><a href="#C-Vasilije-in-Cacak" class="headerlink" title="C. Vasilije in Cacak"></a>C. Vasilije in Cacak</h2><p>给出 $n,k,x$,判断能否在 $1-n$ 之间选择 $k$ 个不同的数，使得他们的和为 $x$</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>只需算出 $1-n$ 中选择 $k$ 个能构成的最大和最小值，看 $x$ 是否在这个范围内即可。注意开 <code>long long</code></p>
<ul>
<li>最小：$1,2,3\dots k$</li>
<li>最大：$(n-k+1),(n-k+2)\dots n-1, n$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> n, k, x, cnt1, cnt2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;</span><br><span class="line">    cnt1 = (k * (k + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    cnt2 = (k * (<span class="number">2</span> * n - k + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= cnt1 &amp;&amp; x &lt;= cnt2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	    cout &lt;&lt; <span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Reverse-Madness"><a href="#D-Reverse-Madness" class="headerlink" title="D. Reverse Madness"></a>D. Reverse Madness</h2><p>给你一个长度为 $n$ 的字符串 $s$ (小写字母),接下来会给你一个正整数 $k$ 和两个长度为 $k$ 的数组 $l$ 和 $r$ 。</p>
<p>保证这两个数组满足以下条件：</p>
<ul>
<li>$l_1 = 1$ </li>
<li>$r_k = n$ </li>
<li>$l_i \le r_i$ </li>
<li>$l<em>i = r</em>{i-1}+1$ </li>
</ul>
<p>现在给你一个正整数 $q$ ，表示你需要对 $s$ 进行修改的次数。</p>
<p>每个修改都用一个正整数 $x$ 来定义：</p>
<ul>
<li>$\text{find}$ $i$ ，$let$ $l_i \le x \le r_i$ ( $\text{In This Case:i is Unique}$）。</li>
<li>$\text{let}$ $a=\min(x, r_i+l_i-x)$ $\text{and}$ $b=\max(x, r_i+l_i-x)$ 。</li>
<li>$\text{reverse(s)[a,b]}$</li>
</ul>
<p>完成最后一次修改后，输出 $s$ 。<br>对于每个用例：<br>$\boxed{\begin{array}&amp;n&amp;k\s&amp;(string)\l<em>{1}&amp;l</em>{2}&amp;\dots&amp;l<em>{k}\r</em>{1}&amp;r<em>{2}&amp;\dots&amp;r</em>{k}\q\x<em>{1}&amp;x</em>{2}&amp;\dots&amp;x_{q}\end{array}}$</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>做法有：线段树，珂朵莉树, 平衡树，等等很多做法 $\dots$ (我还没学 $\dots$)</p>
<p>暴力做法肯定 $TLE\dots$<br><figure class="highlight cpp"><figcaption><span>暴力</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= l[j] &amp;&amp; x &lt;= r[j])&#123;</span><br><span class="line">            <span class="type">int</span> aa = <span class="built_in">min</span>(x, r[j] + l[j] - x), bb = <span class="built_in">max</span>(x,r[j] + l[j] - x);</span><br><span class="line">            <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>() + aa - <span class="number">1</span>, a.<span class="built_in">begin</span>() + bb);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:#92d050">Jiangly 做法：</span></p>
<p>$f$ 数组可以来判断查询某个数的奇偶，为偶数的话就置为 <code>0</code> (因为偶数的话，就相当于在某个相同区间翻转了偶数次，即相当于没有翻转)，奇数置为 <code>1</code> (相当于在该区间翻转了 <code>1</code> 次)</p>
<p>然后再遍历每一次的 $(l,r)$，<code>for (int j = l[i]; j &lt;= l[i] + r[i] - j;j++)</code> 相当于是每次只遍历前面一半即<br><code>for (int j = l[i]; j &lt;= (l[i] + r[i])/2; j++)</code><br><img data-src="../../../../images/Pasted%20image%2020240118165216.png" alt=""></p>
<p>在以 <code>(l+r)/2</code> 为对称轴两侧，如果 $f[i]$ 与 $f[$ <span style="color:#00b0f0">对称的相应的位置</span> $]$ 相同(都为 $0|1$),则抵消，不交换.反之则交换.</p>
<p><span style="color:#00b0f0">Question:</span>  如何证明 <code>swap</code> 的正确性？${\text{迷迷糊糊}\dots}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt;k;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(k)</span>, <span class="title">r</span><span class="params">(k)</span>, <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k;i++)</span><br><span class="line">        cin &gt;&gt; l[i], l[i]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k;i++)</span><br><span class="line">        cin &gt;&gt; r[i], r[i]--;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        f[x - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l[i]; j &lt;= l[i] + r[i] - j;j++)<span class="comment">//for (int j = l[i]; j &lt;= (l[i] + r[i])/2; j++)</span></span><br><span class="line">        &#123;</span><br><span class="line">			rev ^= f[j] ^ f[l[i] + r[i] - j];</span><br><span class="line">            <span class="keyword">if</span>(rev)</span><br><span class="line">                <span class="built_in">swap</span>(s[j], s[l[i] + r[i] - j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-Iva-amp-Pav"><a href="#E-Iva-amp-Pav" class="headerlink" title="E . Iva &amp; Pav"></a>E . Iva &amp; Pav</h2><p>定义 $f(l,r)=a<em>{l}\&amp;a</em>{l+1}\&amp;\dots\&amp;a_{r}(l\leq r)$.</p>
<p>给出 $q$ 组查询：每组查询由 $k,l$ 组成，求最大的索引 $r(l\leq r\leq n)\to f(l,r)\geq k$</p>
<p>输出这样的 $r$，若不存在，输出 <code>-1</code></p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>关键在于如何处理 <code>&amp;</code>，没有看懂题解…</p>
<p>官方题解：(前缀和加二分)</p>
<p> <code>pref(i, j) 代表整数 i 的二进制表示中在位置 j 的比特位的前缀和</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">200010</span>], pre[<span class="number">200010</span>][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line">                pre[i + <span class="number">1</span>][j] = pre[i][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre[i + <span class="number">1</span>][j] = pre[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, k;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (a[l - <span class="number">1</span>] &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> low = l, high = n, ans = l;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high) / <span class="number">2</span>, num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (pre[mid][j] - pre[l - <span class="number">1</span>][j] == mid - l + <span class="number">1</span>)</span><br><span class="line">                    num += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= k)</span><br><span class="line">                low = mid + <span class="number">1</span>, ans = <span class="built_in">max</span>(ans, mid);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><span style="color:#00b0f0">Jiangly</span>:(没看懂 $\dots$)</p>
<p> <code>nxt[i][j]</code> 表示从位置 $i$ 开始，第一个使得 $a<em>i \ \&amp; \ a</em>{i+1} \ \&amp; \dots \&amp; \ a_r$ 的结果为 $0$ 的索引 $r$。</p>
<p>然后，对于每个查询用例，我们找到最大的索引 $r$，使得 $a<em>l \ \&amp; \ a</em>{l+1} \ \&amp; \dots \&amp; \ a<em>r \ge k$。我们可以从最高位开始，逐位地检查 $k$，如果某一位是 $1$，那么我们只需要找到满足 $a_l \ \&amp; \ a</em>{l+1} \ \&amp; \dots \&amp; \ a<em>r \ge k$ 的最小的 $r$，然后更新答案为这个最小的 $r$。如果某一位是 $0$，那么我们只需要找到满足 $a_l \ \&amp; \ a</em>{l+1} \ \&amp; \dots \&amp; \ a_r \ge k$ 的最大的 $r$，然后更新答案为这个最大的 $r$。</p>
<p>最后，如果答案的索引 $r$ 小于等于 $l$，那么将答案更新为 $-1$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector <span class="title">nxt</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;<span class="type">int</span>&gt;(<span class="number">30</span>, n))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nxt[i] = nxt[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (~a[i] &gt;&gt; j &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                nxt[i][j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> l, k;</span><br><span class="line">        std::cin &gt;&gt; l &gt;&gt; k;</span><br><span class="line">        l--;</span><br><span class="line">        <span class="type">int</span> ans = l,res = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                res = std::<span class="built_in">min</span>(res, nxt[l][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = std::<span class="built_in">max</span>(ans, std::<span class="built_in">min</span>(res, nxt[l][i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, res);</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= l) &#123;</span><br><span class="line">            ans = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="F-Vasilije-Loves-Number-Theory"><a href="#F-Vasilije-Loves-Number-Theory" class="headerlink" title="F. Vasilije Loves Number Theory"></a>F. Vasilije Loves Number Theory</h2><p>(待更…)</p>
<h2 id="G-wxhtzdy-ORO-Tree"><a href="#G-wxhtzdy-ORO-Tree" class="headerlink" title="G. wxhtzdy ORO Tree"></a>G. wxhtzdy ORO Tree</h2><p>(待更…)</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>cf</tag>
        <tag>补题</tag>
      </tags>
  </entry>
  <entry>
    <title>1907(913div3)</title>
    <url>/posts/25920d3b/</url>
    <content><![CDATA[<p>需要多加训练<br> <mark style="background: #FF5582A6;">Codeforces Round 913 (Div. 3)</mark> #div3</p>
<h2 id="A-Rook"><a href="#A-Rook" class="headerlink" title="A Rook"></a>A Rook</h2><p>比较简单 #cf800<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">string a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==a[<span class="number">1</span>]<span class="number">-48</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;h&#x27;</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==a[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            cout &lt;&lt; (<span class="type">char</span>)i &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-YetnotherrokenKeoard"><a href="#B-YetnotherrokenKeoard" class="headerlink" title="B YetnotherrokenKeoard"></a>B YetnotherrokenKeoard</h2><ul>
<li>遇到 <code>b</code> 时，就将最后一个小写字母删除 #栈 #cf1000 </li>
<li>遇到 <code>B</code> 时，就将最后一个大写字母删除</li>
<li>如果已经没有满足要求的了，则忽略。<br>给定一个序列，在处理完所有按键后输出键入的字符串。<br>($1 \le t \le 1000$), $\sum\limits<em>{i=1}^t|a</em>{i}|$ $\leq10^6$. $\text{a is not null}$.<br>例如：ARaBbbitBaby-&gt;ity</li>
</ul>
<p>我写的超时了，时间复杂度：$O(n^2)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t;string a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">islower</span>(b[i]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        b.<span class="built_in">erase</span>(b.<span class="built_in">begin</span>() + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isupper</span>(b[i]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        b.<span class="built_in">erase</span>(b.<span class="built_in">begin</span>() + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : b)</span><br><span class="line">            cout &lt;&lt; c;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了解决这个问题，有必要快速支持删除。为此，可以保持<strong>两个堆栈</strong>：</p>
<ul>
<li>一个具有大写字母的位置，</li>
<li>一个具有小写字母的位置。</li>
<li>在删除时，需要以某种方式标记该位置的字符不应该被输出。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jiangly的代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; u, l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!u.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                u.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!l.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                l.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">isupper</span>(s[i])) &#123;</span><br><span class="line">            u.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; u.<span class="built_in">size</span>() || j &lt; l.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; u.<span class="built_in">size</span>() &amp;&amp; (j == l.<span class="built_in">size</span>() || u[i] &lt; l[j])) &#123;</span><br><span class="line">            std::cout &lt;&lt; s[u[i++]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; s[l[j++]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="C-Removal-of-Unattractive-Pairs"><a href="#C-Removal-of-Unattractive-Pairs" class="headerlink" title="C Removal of Unattractive Pairs"></a>C Removal of Unattractive Pairs</h2><p>弗拉德找到了一个由 $n$ 个小写字母组成的字符串 $s$ ，他想让这个字符串越短越好。 #cf1100</p>
<ul>
<li>只要它们不同，就可以从 $s$ 中任意删除对<strong>相邻</strong>的字符。<br>通过任意数量的删除可以得到的最小长度是多少？<br>($1 \le t \le 10^4$)，($1 \le n \le 2 \cdot 10^5$) ，$\sum\limits{i=1}^t\mid s_{i}\mid\leq 2\cdot 10^5$</li>
</ul>
<p>例如：$\text{aabc}\to \text{ac}\to \text{“”}$.</p>
<p>考虑一个有限字符串: 只有两种情况</p>
<ul>
<li>字符串中的所有字符都是相同的，</li>
<li>可以删除某些字符对。<br>如果某个字符在字符串中出现的次数超过 $\lfloor \frac{n}{2} \rfloor$ ，那么最终的字符串将始终只包含这个字符，<br>否则，无论删除顺序如何，我们都可以删除所有可能的字符对。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表述为：</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="number">2</span>*maxs&gt;size)</span><br><span class="line">	 cout &lt;&lt; <span class="number">2</span> * maxs - size &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">	 cout &lt;&lt; size % <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
则 <code>ans = max(size % 2, 2 * (*max_element(num.begin(), num.end())) - size)</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a; <span class="type">int</span> t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        cin &gt;&gt; size &gt;&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : a)</span><br><span class="line">            num[v - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(size % <span class="number">2</span>, <span class="number">2</span> * (*<span class="built_in">max_element</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>())) - size) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="D-Jumping-Through-Segments"><a href="#D-Jumping-Through-Segments" class="headerlink" title="D Jumping Through Segments"></a>D Jumping Through Segments</h2><p>求一个最小的移动距离 $k$ 使得能满足每次移动后都能在目标的 $[l, r]$ 区间内。 #cf1400 #二分<br> $\text{example 1 }\boxed{\begin{align}&amp;5\&amp;1 &amp;5\&amp;3 &amp;4\&amp;5 &amp;6\&amp;8 &amp;10\&amp;0 &amp;1\end{align}}\to \min(k) \text{ is }8-1=7.$</p>
<p>$\text{example 2 }\boxed{\begin{align}&amp;3\&amp;3 &amp;8\&amp;10 &amp;18\&amp;6 &amp;11\end{align}}\min(k)\text{ is } \frac{10}{2}=5$ </p>
<p>在 $\text{example 2}$ 中玩家可以采取以下行动：</p>
<ul>
<li>从点 $0$ 移动到点 $5$（$3 \le 5 \le 8$）;</li>
<li>从点 $5$ 移动到点 $10$（$10 \le 10 \le 18$）;</li>
<li>从点 $10$ 移动到点 $7$（$6 \le 7 \le 11$）。<br>请注意，对于最后一步，玩家可以选择不移动，仍然完成关卡。</li>
</ul>
<p>在 $[1，10^{9}]$ 之间进行二分查找，直到找到最佳的 $k$.<br><code>check</code> 函数：<br>用于检查在给定长度为 $k$ 的情况下，是否存在一种方式将所有的线段覆盖。</p>
<ul>
<li>初始化 <code>ll</code> 和 <code>rr</code> 为 0，表示当前覆盖的区间的左右边界为0。</li>
<li>对于每个线段 $[a, b]$：<br> a. 计算当前覆盖的区间的左边界为 <code>max (ll - k, a)</code>，表示在保证覆盖的情况下，尽可能向左移动。<br> b. 计算当前覆盖的区间的右边界为 <code>min (rr + k, b)</code>，表示在保证覆盖的情况下，尽可能向右移动。<br> c. 如果当前覆盖的区间的左边界大于右边界，则返回 <code>false</code>，表示无法覆盖所有线段。 </li>
<li>如果成功遍历了所有线段并且都能够被覆盖，则返回 <code>true</code>，表示存在一种方式将所有线段覆盖在长度为 $k$ 的情况下。<br><code>check</code> 函数的作用很重要，但是如何证明其正确性还是我的一个问题。</li>
</ul>
<p>二分搜索：$\text{我仍然没有想出来}$<br><img data-src="../../../../images/Z-attachment/Pasted%20image%2020231213195628.png" alt=""><br>将二维的 <code>vector&lt;vector&lt;int&gt;&gt;</code> 变为 <code>vector&lt;array&lt;int, 2&gt;&gt;</code> 节省了不少空间<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k, vector&lt;array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&gt; &amp;seg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ll = <span class="number">0</span>, rr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [a,b] : seg)</span><br><span class="line">    &#123;</span><br><span class="line">        ll = <span class="built_in">max</span>(ll - k, a),rr = <span class="built_in">min</span>(rr + k, b);</span><br><span class="line">        <span class="keyword">if</span> (ll &gt; rr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,2&gt;&gt; <span class="built_in">seg</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        seg[i] = &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>, r = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid, seg))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="E-Good-Triples"><a href="#E-Good-Triples" class="headerlink" title="E Good Triples"></a>E Good Triples</h2><p>给出 $n$, 找出满足 $a+b+c=n \cap f(a)+f(b)+f(c)=f(n)$ 的个数。$f(x)$ 代表 $x$ 各位数字之和。  #cf1600 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>ans</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>10</td>
<td>15</td>
<td>21</td>
<td>28</td>
<td>36</td>
<td>45</td>
<td>55</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>$n\geq 10,ans(n)=\prod ans(n\text{的各位数字})$ </p>
<p><code>int x=n%10,ans *= (x + 1) * (x + 2) / 2,n/=10;</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t, a[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">55</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">            ans *= a[n % <span class="number">10</span>], n /= <span class="number">10</span>;<span class="comment">//ans *= (x + 1) * (x + 2) / 2,n/=10;//jiangly写的</span></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="F-Shift-and-Reverse"><a href="#F-Shift-and-Reverse" class="headerlink" title="F Shift and Reverse"></a>F Shift and Reverse</h2><p>给定一个整数数组 $a_1，a_2，\ldots，a_n$。你可以用这个数组进行两种类型的操作： #cf1800</p>
<ul>
<li>shift：将数组的最后一个元素移到第一个位置，并将所有其他元素向右移动，因此您将获得数组 $a<em>n，a_1，a_2，\ldots，a</em>{n-1}$。</li>
<li>Reverse：反转整个数组，所以你得到数组 $a<em>n，a</em>{n-1}，\ldots，a_1$。<br>你的任务是使用最少的操作数对数组进行非降序排序. 不可能则输出 <code>-1</code>.</li>
</ul>
<p>让我们<strong>把数组写出来两次</strong>，然后计算数组增加和减少的部分。这样，我们就能找到能对数组进行排序的所有可能的移动。</p>
<blockquote>
<p>down: 非递增</p>
<ul>
<li>如果从位置 <code>st</code> 开始，数组 <code>a[st]</code> 到 <code>a[st + n - 1]</code> 是非递增的，那么我们只需要将这部分序列移至数组的前部，然后<strong>反转</strong>整个数组即可。移位的次数就是 <code>st + 1</code>，反转的次数为 <code>1</code>，因为每次移位都会将最后一个元素放到第一个，所以这部分的最小操作次数就是 <code>min(st + 1, n - st + 1)</code>，代表了向左或者向右移位的次数。再反转一次，所以操作次数总合为 <code>st + 1</code> 或是 <code>n - st + 1</code>。<br>up: 非递减</li>
<li>如果从位置 <code>st</code> 开始，数组 <code>a[st]</code> 到 <code>a[st + n - 1]</code> 是非递减的，我们只需要将这部分序列移至数组的前部即可。移位次数为 <code>st + 1</code>。然而，由于每次移位都会将最后一个元素放到第一个，所以需要再反转一次。这样总的操作次数就为 <code>st + 2</code>。另外一种情况就是，我们仍然可以选择向另一个方向移位，也就是从尾部的 <code>n - st</code> 个元素向后累推，然后反转一次，操作次数就是 <code>n - st + 1</code>。但是考虑到 <code>st</code> 的位置肯定是非降序的，因此可以直接将其移位至队首，然后反转整个数组，操作次数为 <code>n - st</code>。所以这部分的最小操作次数就是 <code>min(st + 2, n - st)</code>。<br>所以我们就得到了从各个位置开始，可以使得整个数组非降序的最小操作次数。再各种情况中取最小值，就是答案。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//core：</span></span><br><span class="line">when down:</span><br><span class="line">ans = <span class="built_in">min</span>(&#123;ans,st + <span class="number">1</span>, n - st + <span class="number">1</span>&#125;);</span><br><span class="line">when up:</span><br><span class="line">ans = <span class="built_in">min</span>(&#123;ans, st + <span class="number">2</span>, n - st&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">2</span> * n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">copy</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + n, a.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_sorted</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + n))<span class="comment">// spj</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;0&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// down</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> st = i, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">2</span> * n - <span class="number">1</span> &amp;&amp; a[i] &gt;= a[i + <span class="number">1</span>])</span><br><span class="line">                i++, cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= n)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans,<span class="built_in">min</span>(st + <span class="number">1</span>, n - st + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// up</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> st = i, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">2</span> * n - <span class="number">1</span> &amp;&amp; a[i] &lt;= a[i + <span class="number">1</span>])</span><br><span class="line">                i++, cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= n)</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">min</span>(st + <span class="number">2</span>, n - st));<span class="comment">//(if(!st)ans=0;)&lt;-&gt;(spj)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == INT_MAX)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Lights"><a href="#G-Lights" class="headerlink" title="G  Lights"></a>G  Lights</h2><p>[[浅谈基环树（环套树）]] (基环树：$n$ 点 $n$ 边的连通图) [[基环树]] #cf2200<br><a href="#疑惑">抽象为不懂的部分</a><br>输入的第一行包含一个整数 $t$（$1≤t≤10^4$）-测试用例的数量。</p>
<p>对于每个测试用例</p>
<ul>
<li>第一行包含整数 $n$（$2 \le n \le 10^5$）-灯的数量。</li>
<li>第二行包含 $n$ 个字符的字符串，灯的初始状态。字符“0”表示相应的灯关闭，“1”表示灯打开。</li>
<li>第三行包含 $n$ 个整数 $a_i$（$1 \le a_i \le n$，$a_i \neq i$）-开关 $i$ 改变灯 $i$ 和灯 $a_i$ 的状态。</li>
</ul>
<p>保证所有测试用例的 $n$ 之和不超过 $2 \cdot 10^5$<br>关闭所有的灯使用最少数量的开关，或者说这是不可能的。<br>对于每个测试用例</p>
<ul>
<li>输出整数 $k$，即要使用的最小开关数，然后在单独的行中输出 $k$ 开关列表。</li>
<li>无法关闭所有的灯，则输出 $-1$。</li>
</ul>
<p>例如 $n=5$, 字符串为 $11101$ , $a[5]={4, 3 ,4 ,2, 2}$ </p>
<p>则： $\text{k=3}$ ,开关顺序为 $1,5,3$.</p>
<ul>
<li>当选择 1 时，字符串变为 $01111$</li>
<li>当选择 5 时，字符串变为 $00110$</li>
<li>当选择 3 时，字符串变为 $00000$</li>
</ul>
<p><mark style="background: #FFB8EBA6;">官方题解</mark>：</p>
<p>让我们构建一个有向图，其中一条边从顶点 $i$ 到顶点 $a_i$ 。在这样的图中，每个顶点正好有一条边，每个相连的部分正好有一个循环。</p>
<p>首先，我们将关闭所有不属于循环的灯光；这种关闭顺序是唯一的：我们将移除所有没有边进入的已关闭顶点，然后关闭并移除已打开的顶点。</p>
<p>之后，只剩下循环的组成部分，其中一些可能还亮着灯。考虑从 $i$ 到 $a_i$ 循环中的任何一条边，我们要么按下开关 $i$ ，要么不按。为了计算这些情况下的操作次数，我们将使用与之前相同的算法。</p>
<h3 id="jiangly-的代码"><a href="#jiangly-的代码" class="headerlink" title="jiangly 的代码"></a>jiangly 的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, _;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// jiangly的代码</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">deg</span><span class="params">(n)</span>,ans</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i]--, deg[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//topsort</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!deg[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[x] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[x] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[a[x]] ^= <span class="number">1</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--deg[a[x]] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(a[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//end topsort</span></span><br><span class="line">    <span class="comment">//core</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deg[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> j = i, t = <span class="number">0</span>, len = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (deg[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                t ^= <span class="number">1</span>;</span><br><span class="line">            res += t;</span><br><span class="line">            deg[j] = <span class="number">0</span>;</span><br><span class="line">            j = a[j];</span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                t ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == (res &lt; len - res))</span><br><span class="line">                ans.<span class="built_in">push_back</span>(j);</span><br><span class="line">            j = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//end core</span></span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans)</span><br><span class="line">        cout &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span> (_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="官方的代码"><a href="#官方的代码" class="headerlink" title="官方的代码"></a>官方的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">        string ss;</span><br><span class="line">        cin &gt;&gt; ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            s[i] = ss[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], a[i]--;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        d[a[i]]++;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">0</span>)</span><br><span class="line">            z.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; z.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = z[i];</span><br><span class="line">        <span class="type">int</span> y = a[x];</span><br><span class="line">        <span class="keyword">if</span> (s[x])</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            s[x] = !s[x];</span><br><span class="line">            s[y] = !s[y];</span><br><span class="line">        &#125;</span><br><span class="line">        d[y]--;</span><br><span class="line">        <span class="keyword">if</span> (d[y] == <span class="number">0</span>)</span><br><span class="line">            z.<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">u</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &amp;&amp; !u[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = i;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; ps;</span><br><span class="line">            <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!u[x])</span><br><span class="line">            &#123;</span><br><span class="line">                p.<span class="built_in">push_back</span>(x);</span><br><span class="line">                ps.<span class="built_in">push_back</span>(s[x]);</span><br><span class="line">                c += s[x];</span><br><span class="line">                u[x] = <span class="literal">true</span>;</span><br><span class="line">                x = a[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> k = p.<span class="built_in">size</span>();</span><br><span class="line">            p.<span class="built_in">push_back</span>(x);</span><br><span class="line">            ps.<span class="built_in">push_back</span>(s[x]);</span><br><span class="line">            <span class="keyword">if</span> (c % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; ps1 = ps;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span> || ps1[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    v1.<span class="built_in">push_back</span>(p[j]);</span><br><span class="line">                    ps1[j] = !ps1[j];</span><br><span class="line">                    ps1[j + <span class="number">1</span>] = !ps1[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; ps2 = ps;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; ps2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    v2.<span class="built_in">push_back</span>(p[j]);</span><br><span class="line">                    ps2[j] = !ps2[j];</span><br><span class="line">                    ps2[j + <span class="number">1</span>] = !ps2[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v1.<span class="built_in">size</span>() &lt; v2.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x : v1)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x : v2)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : res)</span><br><span class="line">        cout &lt;&lt; x + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><blockquote>
<p>我到拓扑排序都是理解的，现在我把这个题目抽象一下，抽象为只有我不懂的部分。</p>
<p>抽象后的题目</p>
</blockquote>
<h5 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h5><p>现给你一个图，这个图只含有环 (数量不唯一)，每个点都有它自己的状态 ${0,1}$，每次选定一个点之后，同时这个点绑定的点的状态也会随着改变。题目保证有解。</p>
<h5 id="INput"><a href="#INput" class="headerlink" title="INput"></a>INput</h5><p>输入第一行包含一个整数，代表点的个数。<br>输入第二行包含一个字符串，代表这个点的状态<br>输入第三行包含一个数组，代表改变这个点的状态后同时会被改变状态的节点，即绑定的节点。</p>
<h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>第一行输出使得每个节点的状态都变为 <code>0</code> 时，选定节点数目的最小值。<br> 第二行输出方案情况</p>
<h5 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h5> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">011</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure>
<h5 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h5> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h5 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h5><p>由于 2 节点绑定的是 3 节点，所以只需要选择 2 节点就可以使每个节点的状态都为 <code>0</code> 。</p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*...*/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>数组操作</title>
    <url>/posts/1ce8e225/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/72951/E">数组操作</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>小红拿到了一个数组，她每次可以进行如下操作：<br>选择一个数，使其减去 $x$。<br>小红希望 $k$ 次操作之后，该数组的最大值尽可能小。请你求出这个尽可能小的最大值。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p> $\boxed{\begin{array}&amp;n&amp;k&amp;x\a<em>{1}&amp;a</em>{2}&amp;\dots&amp;a<em>{n}\end{array}}$<br> 数据范围：<br> $1\leq n\leq 10^5$<br> $1\leq a</em>{i},k,x\leq 10^9$ </p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一个整数，代表 $k$ 次操作后，数组尽可能小的最大值。 </p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3 5</span><br><span class="line">4 3 11 2 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>第一个数操作 $1$ 次，第三个数操作 $2$ 次，数组变成 $[-1,3,1,2,1]$，最大值为 $3$。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>![[../../../../images/Z-attachment/Pasted image 20231228143934.png]]</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n,k,x,a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mid)cnt+=(a[i]-mid+x<span class="number">-1</span>)/x;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">-1e18</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r<span class="number">-1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nowcoder</category>
      </categories>
      <tags>
        <tag>常用工具</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>1921(920div3)</title>
    <url>/posts/3464ed42/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="A-Square"><a href="#A-Square" class="headerlink" title="A. Square"></a>A. Square</h2><p>给出四个坐标，算出正方形的面积<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _,x[<span class="number">5</span>],y[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>;i++)</span><br><span class="line">        cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">sort</span>(y + <span class="number">1</span>, y + <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; (x[<span class="number">4</span>] - x[<span class="number">1</span>]) * (y[<span class="number">4</span>] - y[<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-Arranging-Cats"><a href="#B-Arranging-Cats" class="headerlink" title="B . Arranging Cats"></a>B . Arranging Cats</h2><p>科学家们有 $n$ 个箱子，猫可以坐在里面，也可以不坐在里面。<br>盒子的当前状态用序列 $b_1, \dots, b_n$ 表示：如果 $i$ 号盒子里有猫，则为 $b_i = 1$ ，否则为 $b_i = 0$ 。</p>
<p>幸运的是，猫可以无限量生产，因此科学家们可以在一天内完成以下操作之一：</p>
<ul>
<li>取一只新猫并将其放入盒子中（对于 $i$ 中的 $b_i = 0$ ，指定 $b_i = 1$ ）。</li>
<li>从盒子中取出一只猫，让它退休（对于 $i$ 中的 $b_i = 1$ ，指定 $b_i = 0$ ）。</li>
<li>将一只猫从一个盒子移到另一个盒子（对于 $i, j$ 中的 $b_i = 1, b_j = 0$ ，指定 $b_i = 0, b_j = 1$ ）。</li>
</ul>
<p>我们还发现，有些盒子里马上就装满了猫。因此，科学家们知道猫在盒子中的初始位置 $s_1, \dots, s_n$ 和期望位置 $f_1, \dots, f_n$ 。</p>
<p>指出检验假设所需的最少天数。</p>
<p>对于每组数据:<br>$\boxed{\begin{array}&amp;n\s(string)\f(string)\end{array}}$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>实际上，一对 $(0,1)(1,0)$ 可以相互抵消掉，则答案就是 <code>可以抵消掉的对数</code> 加上 <code>不能抵消掉的对数</code><br>可以抵消的个数为 $cnt=\min(cnt<em>{1},cnt</em>{2})$,没有抵消掉的个数为 $max(cnt<em>{1},cnt</em>{2})-cnt$<br>总数即为 $max(cnt<em>{1},cnt</em>{2})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s, f;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; f;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;f[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            cnt1++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;f[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">min</span>(cnt1, cnt2);</span><br><span class="line">    cout &lt;&lt; cnt + (<span class="built_in">max</span>(cnt1, cnt2) - cnt) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//cout&lt;&lt;max(cnt1,cnt2)&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line">    <span class="comment">//ans = the pair of &lt;1,0&gt;and &lt;0,1&gt;+the differences numbers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Sending-Messages"><a href="#C-Sending-Messages" class="headerlink" title="C . Sending Messages"></a>C . Sending Messages</h2><p>需要在 $m<em>1, m_2, \dots m_n$ ( $m</em>{i}&lt;m_{i+1}$ ) 时刻发送 $n$ 条信息。<br>在 $0$ 时刻，他的手机只剩下 $f$ 单位的电量。在 $0$ 时刻，手机处于开机状态。</p>
<p>每开机一个单位，手机就会损失 $a$ 个单位的电量。<br>此外，斯捷潘可以随时关闭手机，稍后再打开。这一操作每次消耗 $b$ 个单位的能量。<br>考虑到开机和关机是瞬时的，因此您可以在 $x$ 时刻开机，并在同一时刻发送信息，反之亦然，在 $x$ 时刻发送信息，并在同一时刻关闭手机。</p>
<p>如果在任何时刻电量降至 $0$ （变为 $\le 0$ ），则无法在该时刻发送信息。</p>
<p>由于所有信息对斯捷潘都非常重要，他想知道是否可以在不给手机充电的情况下发送所有信息。</p>
<p>给出 <code>需要发送的信息数量</code>、<code>手机初始电量</code>、<code>单位时间电量消耗</code> 以及 <code>依次关机和开机时的电量消耗</code>。<br>判断是否能够发送所有信息。<br>对于每组数据:<br>$\boxed{\begin{array}&amp;n&amp;f&amp;a&amp;b\m<em>{1}&amp;m</em>{2}&amp;m<em>{3}&amp;\dots&amp;m</em>{n}\end{array}}$</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long<span class="comment">//注意要开ll</span></span></span><br><span class="line"><span class="type">int</span> m[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, f, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; f &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        cin &gt;&gt; m[i];</span><br><span class="line">    <span class="built_in">sort</span>(m + <span class="number">1</span>, m + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a*(m[i]-m[i<span class="number">-1</span>])&gt;b)</span><br><span class="line">            f -= b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f -= a*(m[i]-m[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f&gt;<span class="number">0</span>)<span class="comment">//在这里f&gt;=0?题目似乎没给清楚</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="D-Very-Different-Array"><a href="#D-Very-Different-Array" class="headerlink" title="D . Very Different Array"></a>D . Very Different Array</h2><p>给出 $a,b$ 数组，分别有 $n,m个整数(m\geq n)$，在 $b$ 数组中选出 $n$ 个数组成一个长度为 $n$ 的新数组使得:<br>$D=\sum\limits<em>{i=1}^n\mid a</em>{i}-c_{i}\mid$ 最大并输出 $\max(D)$</p>
<p>对于每组数据:</p>
<script type="math/tex; mode=display">\boxed{\begin{array}&n&m\\a_{1}&a_{2}&\dots&a_{n}\\b_{1}&b_{2}&\dots &b_{m}\end{array}}</script><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>我的想法是最大减去对应的最小的，但是是错误的</p>
<p>Hack 数据<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 6</span><br><span class="line">7 9</span><br><span class="line">8 1 10 6 3 9</span><br></pre></td></tr></table></figure><br>按照我的思路：</p>
<ul>
<li>$a:7,9$</li>
<li>$b: 10,9,8,6,3,1$</li>
<li>大的减去对应小的: $D=(10-7)+(9-1)=11\neq 12$ $\Huge{WA}$</li>
</ul>
<p><code>expect</code> <span style="color:#92d050">12</span> <code>BUT found</code> <span style="color:#c00000">11</span> </p>
<p>一个正确的思路和我的很像却也不同：</p>
<ul>
<li>当选定 $n$ 个数的时候，只需要大的减去对应小的依次相加即可</li>
<li>一般中间的不取，只取前面 $i$ 个和后面 $n-i$ 个即可，(我做的时候是按照前面和后面均分来的，但是是错误的)</li>
</ul>
<p><span style="color:#92d050">因此做法是：</span></p>
<p>确定一个界限 $i$，先按照对应（大对应小）来计算 <code>ans</code>，后面只需要计算变化量即可。</p>
<p>可以枚举每一种情况<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">200010</span>], b[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + m + <span class="number">1</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        tmp += <span class="built_in">abs</span>(a[i] - b[i]);</span><br><span class="line">    ans = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        tmp += <span class="built_in">abs</span>(a[n - i] - b[m - i]) - <span class="built_in">abs</span>(a[n - i] - b[n - i]),ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="E-Eat-the-Chip"><a href="#E-Eat-the-Chip" class="headerlink" title="E. Eat the Chip"></a>E. Eat the Chip</h2><p><img data-src="https://espresso.codeforces.com/dbc362298c0158c22f271eca8a6d5611b3ae09a5.png" alt="示例1"></p>
<p>Alice(白) 和 Bob(黑)能走的方向如图。双方都以最佳状态下棋，结果是？</p>
<p>对于每个样例：</p>
<script type="math/tex; mode=display">\boxed{\begin{array}&h&w&x_{a}&x_{b}&y_{a}&y_{b}\end{array}}</script><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>如果有一方发现自己会输，就会想办法平局，分类讨论，较为麻烦</p>
<p>先算出两人见面之前 $y$ 的范围，进攻方 $[l<em>{1},r</em>{1}]$,防守方 $[l<em>{2},r</em>{2}]$,满足：$l<em>{1}\leq l</em>{2}+1,r<em>{1}\geq r</em>{2}-1$,满足则可以 <code>win</code>，否则 <code>Draw</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xs, ys, xa, ya, xb, yb;</span><br><span class="line">    cin &gt;&gt; xs &gt;&gt; ys &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb;</span><br><span class="line">    <span class="keyword">if</span> (xa &gt;= xb)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Draw\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = xb - xa; <span class="comment">//可达范围</span></span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> la = <span class="built_in">max</span>(<span class="number">1</span>, ya - x / <span class="number">2</span>), ra = <span class="built_in">min</span>(ys, ya + x / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> lb = <span class="built_in">max</span>(<span class="number">1</span>, yb - x / <span class="number">2</span>), rb = <span class="built_in">min</span>(ys, yb + x / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (la &lt;= lb + <span class="number">1</span> &amp;&amp; ra &gt;= rb - <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Alice\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Draw\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> la = <span class="built_in">max</span>(<span class="number">1</span>, ya - x / <span class="number">2</span>), ra = <span class="built_in">min</span>(ys, ya + x / <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> lb = <span class="built_in">max</span>(<span class="number">1</span>, yb - (x - <span class="number">1</span>) / <span class="number">2</span>), rb = <span class="built_in">min</span>(ys, yb + (x - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (lb &lt;= la + <span class="number">1</span> &amp;&amp; rb &gt;= ra - <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Bob\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Draw\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Sum-of-Progression"><a href="#F-Sum-of-Progression" class="headerlink" title="F. Sum of Progression"></a>F. Sum of Progression</h2><p>给你一个由 $n$ 个数字组成的数组 $a$ 。还有 $q$ 个形式为 $s, d, k$ 的查询。</p>
<p>对于每个查询 $q$ ，求 $a<em>s + a</em>{s+d} \cdot 2 + \dots + a_{s + d \cdot (k - 1)} \cdot k$ 即：</p>
<script type="math/tex; mode=display">\large{\sum\limits_{i=1}^ka_{s+d(i-1)}\times i}</script><p>对于每个测试用例：$\boxed{\begin{array}&amp;n&amp;q\a<em>{1}&amp;a</em>{2}&amp;\dots&amp;a<em>{n}\s</em>{1}&amp;d<em>{1}&amp;k</em>{1}\s<em>{2}&amp;d</em>{2}&amp;k<em>{2}\\vdots&amp;(q\ \text{query})\s</em>{q}&amp;d<em>{q}&amp;k</em>{q}\end{array}}$</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p><span style="color:#c00000">根号分治</span><br>设置一个阈值: <script type="math/tex">w=\sqrt{ n }</script></p>
<p>当 $d&gt;w$,直接暴力做(因为这时的运算次数很少了)</p>
<p>当 $d\leq w$，开数组算前缀和. ($s,d\text{分别代表}i,j$)</p>
<ul>
<li>$f$ 数组来记录 $\lfloor{\frac{s}{d}}\rfloor\times a<em>{s+\lambda \times d}$ 前缀和，记录的是 $a</em>{s}\times \lfloor{\frac{s}{d}}\rfloor+s_{s+d}\times\lfloor{\frac{s+d}{d}}\rfloor+\dots$</li>
<li>$g$ 数组记录的是 $a<em>{s+\lambda \times d}$ 的前缀和，记录的是 $a</em>{s}+s_{s+d}+\dots$</li>
<li>差距 $\left( \frac{s}{d}-1 \right)g=a<em>{s}\times\left( \frac{s}{d}-1 \right)+a</em>{s+d}\times\left( \frac{s}{d}-2 \right)+\dots$</li>
<li>$\leftrightarrow$  $\text{ans}=f-\left( \frac{s}{d}-1 \right)g=a<em>{s}\times1+a</em>{s+d}\times 2+\dots+a_{s+(k-1)d}\times k=\text{target}$</li>
<li>$\leftrightarrow\text{ans=}\textcolor{green}{f[s+d\times(k-1)][d]-f[s-d][d]}-(\textcolor{grey}{g[s+d\times(k-1)][d]-g[s-d][d]})\times\left( \frac{s}{d}-1 \right)$</li>
</ul>
<p>处理方式可能不止一种…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,q,a[<span class="number">100010</span>];</span><br><span class="line">ll f[<span class="number">100010</span>][<span class="number">350</span>],g[<span class="number">100010</span>][<span class="number">350</span>];<span class="comment">//序号 步长d </span></span><br><span class="line">(ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);)<span class="comment">//必须关闭同步流，不然会超时</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="type">int</span> value = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= value; d++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i][d] = ((i - d &gt; <span class="number">0</span>) ? f[i - d][d] : <span class="number">0ll</span>) + <span class="number">1ll</span> * a[i] *(i / d); <span class="comment">//((i - 1) / d + 1);灰色的另一种也可以</span></span><br><span class="line">            g[i][d] = ((i - d &gt; <span class="number">0</span>) ? g[i - d][d] : <span class="number">0ll</span>) + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; d &gt;&gt; k;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; value)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">                ans += <span class="number">1ll</span> * a[s + i * d] * (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans = f[s + d * (k - <span class="number">1</span>)][d] - ((s - d &gt; <span class="number">0</span>) ? f[s - d][d] : <span class="number">0</span>);</span><br><span class="line">            ans -= (g[s + d * (k - <span class="number">1</span>)][d] - ((s - d &gt; <span class="number">0</span>) ? g[s - d][d] : <span class="number">0</span>)) * (s / d - <span class="number">1</span>); <span class="comment">//((s - 1) / d);</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="G-Mischievous-Shooter"><a href="#G-Mischievous-Shooter" class="headerlink" title="G. Mischievous Shooter"></a>G. Mischievous Shooter</h2><p>谢尔只带了一把幸运猎枪，他可以朝四个方向之一射击：右下、左下、左上或右上。射击时，霰弹枪会击中所选方向上的所有目标，这些目标的曼哈顿距离不会超过一个固定常数 $k$.<br><img data-src="https://espresso.codeforces.com/5be3be0c3da7ceb1e2c5179fd6e050bb67595890.png" alt="k=3"> </p>
<p>每个测试用例：</p>
<p>$\boxed{\begin{array}&amp;n&amp;m&amp;k\str(m<em>{1})\str(m</em>{2})\\vdots\str(m_{n})\end{array}}$<br>其中字符”. “表示单元格为空，字符 “#”表示存在目标.</p>
<p>输出一个整数，该整数等于一次射击击中目标的最大可能数目。</p>
<p>输入样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 3 1</span><br><span class="line">.#.</span><br><span class="line">###</span><br><span class="line">.#.</span><br><span class="line"></span><br><span class="line">2 5 3</span><br><span class="line">###..</span><br><span class="line">...##</span><br><span class="line"></span><br><span class="line">4 4 2</span><br><span class="line">..##</span><br><span class="line">###.</span><br><span class="line">#..#</span><br><span class="line">####</span><br><span class="line"></span><br><span class="line">2 1 3</span><br><span class="line">#</span><br><span class="line">#</span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>Notes：</p>
<p><img data-src="https://espresso.codeforces.com/68524d36e5aa0806407afb4453f80106e8c01f4f.png" alt=""></p>
<h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p><span style="color:#ffc000">(待更…)</span></p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>510C</title>
    <url>/posts/f38b7ef1/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>狐狸 Ciel 即将发表一篇关于 FOCS (狐狸操作计算机系统，读作 “狐狸”)的论文。她听到一个传言：论文的作者列表总是按照 <u>lexicographical</u> 顺序排列。<br>在查看了一些例子后，她发现有时并非如此。在一些论文中，作者姓名并不是按照正常意义上的 <u>lexicographical</u> 顺序排列的。但是，在对字母表中的字母顺序进行某些修改后，作者姓名的顺序就会变成<u>lexicographical</u>顺序，这是事实！<br>她想知道，是否存在一种字母顺序，可以使她提交的论文中的姓名按照 <u>lexicographical</u> 顺序排列。如果有，你应该找出这样的顺序。 </p>
</blockquote>
<p><u>lexicographical</u> 顺序的定义如下。当我们比较 $s$ 和 $t$ 时，首先要找到最左侧位置上的不同字符（$s<em>{i} ≠ t</em>{i}$） .如果没有这样的位置 (即 $s$ 是 $t$ 的前缀，反之亦然)，则最短字符串较少。否则，我们将根据字母表中的顺序比较字符 $s_i$ 和 $t_i$ 。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行包含一个整数 $n ( 1 ≤ n ≤ 100 )$：名称数量。</p>
<p>接下来的每 $n$ 行包含一个字符串 $name_i ( 1 ≤ |name_i| ≤ 100 )$，即第 $i$ 个名称。每个名称只包含小写字母。所有名称均不同。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>如果存在这样的字母顺序，即所给名称按词典排序，则输出任何这样的顺序，作为字符’a’-‘z’的排列 (即首先输出修改后字母表的第一个字母，然后是第二个字母，依此类推)。否则输出单词 <code>Impossible</code></p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>首先让我们想一想 S &lt; T 可以告诉我们什么：</p>
<p>假设 S = abcxyz<br>        T = abcuv。</p>
<p>根据定义，当且仅当 x &lt; u 时，S &lt; T。</p>
<p>因此，我们可以将条件 name 1 &lt; name 2，name 2 &lt; name 3… 转化为字母的顺序。</p>
<p>那么问题就变成了：我们是否有一个排列满足这些条件。实际上这是一个经典的拓扑排序问题。</p>
<p>这个任务的一个技巧是，如果我们有像 xy &lt; x 这样的情况，那么就没有解决办法。这在预测试中并没有涉及。 :)</p>
<h2 id="洛谷题解"><a href="#洛谷题解" class="headerlink" title="洛谷题解"></a>洛谷题解</h2><p>一道拓扑排序裸题。<br>对于字典序前后相邻的两个字符串 $a$ 和 $b ， b$ 肯定不能是 $a$ 的前缀，不然的话这个字典序就是错的，要输出 <code>Impossible</code>。  </p>
<p>如果 $a$ 不是 $b$ 的前缀的话，那么 $a$ 和 $b$ 第一个不相同的字符我们分别称之为 $c$ 和 $d ， c$ 的优先级肯定是要比 $d$ 高的，也就是 $c$ 在答案中出现的位置一定是要比 $d$ 靠前的。  </p>
<p>看到这里你想到了什么? 拓扑排序! 没错，我们要在图中连一条从 $d$ 到 $c$ 的有向边，最后输出这张图的拓扑排序就好了，如果图有环就输出 <code>Impossible</code>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, in[<span class="number">1145</span>], cnt, ans[<span class="number">1145</span>];</span><br><span class="line">string s1, s2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[<span class="number">1145</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s2;</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">min</span>(s1.<span class="built_in">size</span>(), s2.<span class="built_in">size</span>()), j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[j] != s2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = s1[j] - <span class="string">&#x27;a&#x27;</span>, y = s2[j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">                in[y]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= m &amp;&amp; s2.<span class="built_in">size</span>() &lt; s1.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (!in[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        ans[++cnt] = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            in[a]--;</span><br><span class="line">            <span class="keyword">if</span> (!in[a])</span><br><span class="line">                q.<span class="built_in">push</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; <span class="number">26</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++)</span><br><span class="line">            cout&lt;&lt;(<span class="type">char</span>)(ans[i] + <span class="string">&#x27;a&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛119</title>
    <url>/posts/6d89594e/</url>
    <content><![CDATA[<h1 id="1-C-夜色亵渎者"><a href="#1-C-夜色亵渎者" class="headerlink" title="1 C 夜色亵渎者"></a>1 C 夜色亵渎者</h1><blockquote>
<p>这夜将亵渎灯的色。<br>亵渎美与好，<br>亵渎安眠，亵渎长息，<br>亵渎她心中所知的每一首摇篮曲。<br>从此之后，之后的之后，<br>漫漫长夜，再无安宁。  </p>
</blockquote>
<p>Alice 参加了一场考试。这场考试共有 $n ^ 2$ 道题，题目在答题卡上排列成了一个 $n×n$  的矩阵。</p>
<p>Alice 聪明地找到了题目答案的规律。具体地，$(i, j)$ 位置上的答案为 $ai​⊕bj​$。其中，$⊕$ 代表按位异或。</p>
<p>然而，Alice 把答题卡的行列涂反了。即第 $i$ 行第 $j$ 列的答案填涂到了第 $j$ 行第 $i$ 列。</p>
<p>请问 Alice 能答对多少道题。</p>
<h2 id="1-输入描述"><a href="#1-输入描述" class="headerlink" title="1 输入描述:"></a>1 输入描述:</h2><blockquote>
<p>第一行一个整数 𝑛。</p>
<p>第二行 𝑛 个整数 $a_1​,a_2​,…,a_n$ ​。</p>
<p>第三行 𝑛 个整数 $b_1​,b_2​,…,b_n$​。</p>
<h2 id="2-输出描述"><a href="#2-输出描述" class="headerlink" title="2 输出描述:"></a>2 输出描述:</h2><p>输出为一个数，即 $Alice$ 答对的题目数量。</p>
</blockquote>
<h2 id="3-示例-1"><a href="#3-示例-1" class="headerlink" title="3 示例 1"></a>3 示例 1</h2><h3 id="3-1-输入"><a href="#3-1-输入" class="headerlink" title="3.1 输入"></a>3.1 输入</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-输出"><a href="#3-2-4-输出" class="headerlink" title="3.2 4 输出"></a>3.2 4 输出</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="4-说明"><a href="#4-说明" class="headerlink" title="4 说明"></a>4 说明</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目的答案依次为：</span><br><span class="line"><span class="number">3525</span></span><br><span class="line"><span class="number">0616</span></span><br><span class="line"><span class="number">1707</span></span><br><span class="line"><span class="number">6070</span></span><br><span class="line">Alice 的填涂为：</span><br><span class="line"><span class="number">3016</span></span><br><span class="line"><span class="number">5670</span></span><br><span class="line"><span class="number">2107</span></span><br><span class="line"><span class="number">5670</span></span><br><span class="line">正确的位置一共有 <span class="number">6</span> 个。</span><br></pre></td></tr></table></figure>
<h2 id="5-备注"><a href="#5-备注" class="headerlink" title="5 备注"></a>5 备注</h2><p>对于所有数据，$1≤n≤3×10^5,0≤a_i​,b_i​≤10^9$。</p>
<p>考察异或的性质<br>           异或：\bigoplus  —-   $\bigoplus$       \oplus —- $\oplus$<br>我们直接对答案进行移动会发现 $a_i  \oplus b_j=a_j  \oplus a_i$ 我们移动一下就是 $(a_i  \oplus b_i) \oplus(a_j  \oplus b_j)=0$ 异或的性质</p>
<p>接着就用 map 来处理即可</p>
<h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6 代码"></a>6 代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">300010</span>], b[<span class="number">300010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++) mp[a[i] ^ b[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:mp) ans += v.second * v.second;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-D-在仙境之外"><a href="#2-D-在仙境之外" class="headerlink" title="2 D 在仙境之外"></a>2 D 在仙境之外</h1><blockquote>
<p>兔子，兔子，拿饼干。<br>帽匠，帽匠，倒茶水。<br>柴郡猫将长桌铺整齐，<br>爱丽丝端来小茶杯；<br>旧访客啊，别哭泣，<br>茶会的准备已就绪。</p>
</blockquote>
<p>给定一个长度为 $n+1$ 的序列 $a$ 的前 $n$ 项和一个数 $S$。$A<em>{n+1}$ ​ 初始为 $0$。将一次操作定义为 $a_i​=a_j​⊕a_k$ ​，其中 $⊕$ 为加减乘除（下取整）的一种。问是否能通过若干次操作使得 $a</em>{n+1}​=S$。输出方案。</p>
<p><strong>注意</strong>不要求 $i$, $j$, $k$ 互不相同。  </p>
<h2 id="1-输入描述-1"><a href="#1-输入描述-1" class="headerlink" title="1 输入描述:"></a>1 输入描述:</h2><blockquote>
<p>第一行两个整数 $𝑛$, $𝑆$.</p>
<p>第二行 $𝑛$个整数，表示序列 $𝑎$.</p>
</blockquote>
<h2 id="2-输出描述-1"><a href="#2-输出描述-1" class="headerlink" title="2 输出描述:"></a>2 输出描述:</h2><blockquote>
<p>第 1 行一个整数 𝑥,表示操作次数。</p>
<p>接下来 𝑥行，每行先输出三个整数 $i,j,k(1≤i,j,k≤n+1)$，含义同题目描述。再输出操作的符号 $+,−,\times,/$ 其中之一，以一个空格分隔。</p>
<p>请保证运算过程中 $a<em>1​,…,a</em>{n+1}​$ 时刻处于 $[0,2e18]$ 之间，操作次数不超过 $200$。</p>
</blockquote>
<h2 id="3-示例-1-1"><a href="#3-示例-1-1" class="headerlink" title="3 示例 1"></a>3 示例 1</h2><h3 id="3-1-输入-1"><a href="#3-1-输入-1" class="headerlink" title="3.1 输入"></a>3.1 输入</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">17</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-输出"><a href="#3-2-输出" class="headerlink" title="3.2 输出"></a>3.2 输出</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">4</span> *</span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">1</span> +</span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">2</span> +</span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">3</span> +</span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">5</span> +</span><br></pre></td></tr></table></figure>
<h2 id="4-说明-1"><a href="#4-说明-1" class="headerlink" title="4 说明"></a>4 说明</h2><p>$a_2​=a_2​\times ​a_4​=2\times 4=8$<br>$a_6​=a_6​+a_1​=0+1=1$<br>$a_6​=a_6​+a_2​=1+8=9$<br>$a_6​=a_6​+a_3​=9+3=12$<br>$a_6​=a_6​+a_5​=12+5=17$</p>
<h2 id="5-备注-1"><a href="#5-备注-1" class="headerlink" title="5 备注:"></a>5 备注:</h2><p>对于所有数据，$1≤n≤10^5，1≤a_i​,S≤10^{18}$。</p>
<p>首先通过自身与自身相除可以构造出 $1$,然后用类似于快速幂的方式即可构造出任意的 $S$。操作次数 $≤2 logV&lt;200$。</p>
<h2 id="6-代码-1"><a href="#6-代码-1" class="headerlink" title="6 代码"></a>6 代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 4&gt;&gt; ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    ans.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;/&#x27;</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;n + <span class="number">1</span>, <span class="number">1</span>, n + <span class="number">1</span>, <span class="string">&#x27;+&#x27;</span>&#125;);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;+&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [a, b, c, d] : ans)<span class="comment">//c++17</span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">char</span>(d) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for (auto&amp; arr : ans)//c++11</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int a, b, c, d;</span></span><br><span class="line"><span class="comment">//     tie(a, b, c, d) = make_tuple(get&lt;0&gt;(arr), get&lt;1&gt;(arr), get&lt;2&gt;(arr), get&lt;3&gt;(arr));</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; c &lt;&lt; &#x27; &#x27; &lt;&lt; char(d) &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nowcoder</category>
      </categories>
      <tags>
        <tag>#补题</tag>
      </tags>
  </entry>
  <entry>
    <title>510D</title>
    <url>/posts/6defeb52/</url>
    <content><![CDATA[<h2 id="1-用到了-裴蜀定理-："><a href="#1-用到了-裴蜀定理-：" class="headerlink" title="1 用到了 [[裴蜀定理]]："></a>1 用到了 [[裴蜀定理]]：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="type">int</span> n, l[<span class="number">310</span>], c[<span class="number">310</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (it = dp.<span class="built_in">begin</span>(); it != dp.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">gcd</span>(l[i], it-&gt;first);</span><br><span class="line">            <span class="keyword">if</span> (dp.<span class="built_in">find</span>(temp) != dp.<span class="built_in">end</span>())</span><br><span class="line">                dp[temp] = <span class="built_in">min</span>(dp[temp], c[i] + it-&gt;second);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[temp] = c[i] + it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; l[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">if</span> (dp.<span class="built_in">find</span>(<span class="number">1</span>) == dp.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>1922(Edu161div2)</title>
    <url>/posts/67496da7/</url>
    <content><![CDATA[<p>被打爆的一场，之后更加要多打 cf 了！</p>
<h2 id="A-Tricky-Template"><a href="#A-Tricky-Template" class="headerlink" title="A. Tricky Template"></a>A. Tricky Template</h2><p>给出字符串长度 $n$，和字符串 $a,b,c(小写)$.</p>
<p>假设一个模板是由 $n$ 个小写和/或大写拉丁字母组成的字符串 $t$ 。如果从 $1$ 到 $n$ 的所有 $i$ 都满足以下条件，则字符串 $s$ 与模板 $t$ 匹配：</p>
<ul>
<li>如果模板中第 $i$ 个字母是<strong>小写字母</strong>，那么 $s_i$ 必须与 $t_i$ <strong>相同</strong>；</li>
<li>如果模板中的第 $i$ 个字母是<strong>小写字母</strong>，那么 $s_i$ 必须与 $t_i$ 的<strong>小写版本</strong>不同。例如，如果模板中有字母 “A”，则不能在字符串的相应位置使用字母 “a”。</li>
</ul>
<p>因此，如果至少有一个 $i$ 的条件不成立，字符串就与模板不匹配。</p>
<p>判断是否存在模板 $t$ ，使得字符串 $a$ 和 $b$ 与之匹配，而字符串 $c$ 不匹配。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>根本没看懂题目意思 $\dots$</p>
<p>我当时的想法是只要 <code>a,b,c不要都相同且a,b不相同的部分，不能与c相同</code> 我觉得做法很正确，但是一直 wa，服了 $\dots$<br><figure class="highlight cpp"><figcaption><span>错误代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((a[i] == c[i] || b[i] == c[i]) &amp;&amp; a[i] != b[i])</span><br><span class="line">		ok = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (a == c || b == c)</span><br><span class="line">		ok = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>$\text{WOC!!!!!}$,答案那么简单，我都没过 $!!!!\dots..$</p>
<p>Jiangly 的答案. 这么简单的题我做了那么久，我真是废物啊</p>
<p>只要 a 与 c 不同的部分，b 与 c 也不同即可。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (a[i] != c[i] &amp;&amp; b[i] != c[i]) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="B-Forming-Triangles"><a href="#B-Forming-Triangles" class="headerlink" title="B. Forming Triangles"></a>B. Forming Triangles</h2><p>你有 $n$ 根木棒，编号从 $1$ 到 $n$ 。第 $i$ 根木棒的长度是 $2^{a_i}$ 。</p>
<p>你想从给定的 $n$ 根小木棍中选出准确的 $3$ 根小木棍，并用这些小木棍作为三角形的边，组成一个三角形</p>
<p>输出选择 $3$ 根小棒组成三角形的方式的数量。不考虑顺序（即选择 $1,2,4\equiv2,1,4\dots$）</p>
<p>我的答案仍然是错误的，但是至少方向找对了<br><figure class="highlight cpp"><figcaption><span>错误代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], num[a[i]]++;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="number">1</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = ((n - cnt) * (n - cnt - <span class="number">1</span>) * (n - cnt - <span class="number">2</span>)) / <span class="number">6</span> + (cnt ? (n - cnt) : <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>Jiangly</p>
<ul>
<li>有两个一样的，另外一个必须小于等于两个一样的数。</li>
<li>三个数字一样</li>
</ul>
<p>所以答案等于 <code>C(相等的个数，3)+c(相等的个数，2)*比这个数字小的个数</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        std::cin &gt;&gt; a;</span><br><span class="line">        cnt[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans += <span class="number">1LL</span> * cnt[i] * (cnt[i] - <span class="number">1</span>) * (cnt[i] - <span class="number">2</span>) / <span class="number">6</span>;</span><br><span class="line">        ans += <span class="number">1LL</span> * cnt[i] * (cnt[i] - <span class="number">1</span>) / <span class="number">2</span> * tot;</span><br><span class="line">        tot += cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-Closest-Cities"><a href="#C-Closest-Cities" class="headerlink" title="C. Closest Cities"></a>C. Closest Cities</h2><p>给出一个长度 $n$ 的升序数组, 从下标为 $x\to y$ 消费的金币为 $\mid a<em>{x}-a</em>{y}\mid$</p>
<blockquote>
<p>For each city $i$, let’s define the <strong>closest</strong> city $j$ as the city such that the distance between $i$ and $j$ is not greater than the distance between $i$ and each other city $k$. </p>
</blockquote>
<ul>
<li>前往距离为 $x$ 最近的城市，支付 $1$ 金币</li>
<li>前往其他城市，支付 $\mid a<em>{x}-a</em>{y}\mid$ 金币</li>
</ul>
<p>输出最少的花费。</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>比较前后的距离，给予 <code>1,-1,0</code><br>$f_{1}[i]$ 数组记录 $[1-(i+1)]$ 需要消费的金币</p>
<p>$f_{2}[i]$ 表示 $[i-1]$ 消耗的金币</p>
<p>$x&lt;y:$ <code>ans=f1[y - 1] - f1[x - 1]</code></p>
<p>$x&gt;y:$ <code>ans=f2[x] - f2[y]</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i].first;</span><br><span class="line">    a[<span class="number">1</span>].second = <span class="number">1</span>, a[n].second = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].first - a[i - <span class="number">1</span>].first &lt; a[i + <span class="number">1</span>].first - a[i].first)</span><br><span class="line">            a[i].second = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i].first - a[i - <span class="number">1</span>].first &gt; a[i + <span class="number">1</span>].first - a[i].first)</span><br><span class="line">            a[i].second = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[i].second = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f1</span><span class="params">(n)</span>, <span class="title">f2</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        f1[i] = f1[i - <span class="number">1</span>] + (a[i].second &gt;= <span class="number">0</span> ? <span class="number">1</span> : a[i + <span class="number">1</span>].first - a[i].first);</span><br><span class="line">    <span class="comment">// 1---n-1 f[i]表示1--i+1需要消费的金币f[1] 1--2 f[4] 1--5 f[4]-f[2]=3--5</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">        f2[i] = (a[i].second &lt;= <span class="number">0</span> ? <span class="number">1</span> : a[i].first - a[i - <span class="number">1</span>].first);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        f2[i] = f2[i - <span class="number">1</span>] + f2[i];</span><br><span class="line">    <span class="comment">// 2---n  f2[i]表示i--1消耗的金币 f[2] 2--1  f[5] 5--1   f[5]-f[2] 5--2</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">            cout &lt;&lt; f1[y - <span class="number">1</span>] - f1[x - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; f2[x] - f2[y] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-Berserk-Monsters"><a href="#D-Berserk-Monsters" class="headerlink" title="D. Berserk Monsters"></a>D. Berserk Monsters</h2><p>一排有 $n$ 个怪物相互攻击，对于每个怪物：有攻击值: $a<em>{i}$,防御值：$d</em>{i}$</p>
<p>每个怪物都会向左右两个活着的怪物发起攻击，如果某怪物受到了超过自身防御的伤害，则死亡。</p>
<p>输出 $n$ 个整数，第 $i$ 个整数等于在第 $i$ 回合死亡怪物的数量。</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p><span style="color:#92d050">一个模拟大题</span></p>
<p><span style="color:#ffc000">第一轮遍历完之后，之后每一轮只需要检测上一轮死亡的怪物相邻的怪物即可。</span></p>
<p>$l,r$ 数组记录相邻的怪物的索引(不存在则为-1)。</p>
<ul>
<li>若该怪物不在边界，则将 <code>sum</code> 加上相邻的攻击伤害。（边界则特殊考虑即可）</li>
</ul>
<p>$vis$ 数组记录该怪物是否已经遍历过了。</p>
<p>对于该轮死亡的怪物</p>
<ul>
<li>若 <code>x 左边还有活着的怪物</code>，则将 <code>x 左边还活着的怪物</code> 的右索引更新为 x 的右索引。(这相当于将这时 <code>死亡的怪物的左边相邻还活着的怪物的右索引</code> 改为了 <code>这时已经死亡了的怪物的右索引</code>)，如果左边还活着的怪物这轮没有死，则将左边相邻还活着的怪物加入 <code>v</code> 数组(下轮将继续检测该怪物会不会被新来的怪物杀死)，这时将这个怪物设置为已经遍历过。</li>
<li>若 <code>x 左边还有活着的怪物</code>，与上面类似。将 <code>x 右边还活着的怪物</code> 的右索引更新为 x 的右索引。$\dots$</li>
</ul>
<p>Jiangly 代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">d</span><span class="params">(n)</span>, <span class="title">l</span><span class="params">(n)</span>, <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; d[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        l[i] = i - <span class="number">1</span>, r[i] = i + <span class="number">1</span>;</span><br><span class="line">    r[n - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; die;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l[x] != <span class="number">-1</span>)</span><br><span class="line">                sum += a[l[x]];</span><br><span class="line">            <span class="keyword">if</span> (r[x] != <span class="number">-1</span>)</span><br><span class="line">                sum += a[r[x]];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; d[x])</span><br><span class="line">                die.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        cout &lt;&lt; die.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:die)</span><br><span class="line">            vis[x] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:die)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l[x]!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                r[l[x]] = r[x];</span><br><span class="line">                <span class="keyword">if</span>(vis[l[x]]&lt;i)</span><br><span class="line">                    v.<span class="built_in">push_back</span>(l[x]), vis[l[x]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r[x]!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l[r[x]] = l[x];</span><br><span class="line">                <span class="keyword">if</span>(vis[r[x]]&lt;i)</span><br><span class="line">                    v.<span class="built_in">push_back</span>(r[x]), vis[r[x]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="E-Increasing-Subsequences"><a href="#E-Increasing-Subsequences" class="headerlink" title="E. Increasing Subsequences"></a>E. Increasing Subsequences</h2><p><a href="https://www.luogu.com.cn/problem/P8376">P8376 [APIO2022] 排列 - 洛谷</a><br><a href="https://www.luogu.com.cn/problem/AT_s8pc_6_h">Percepts of AtCoder 2 - 洛谷</a><br>找到一个长度不超过 <code>200</code> 的数组使得恰好有 $X$ 个递增的子序列，并输出，若不存在，输出<code>-1</code>(空序列也是递增的)</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>我只能想到答案一定和二进制有关，一个长度为 $n$ 的递增序列，可以构成 $2^n$ 个递增的子序列，长度为 n-1 的递增序列后面加上<span style="color:#92d050">一个递增的且完全小于前面序列的所有数字</span>的序列就可构成 $2^{n-1}+2^{加上的序列的长度}-1$，（每次加上一个序列后，本来空序列也算是递增的，但是不能叠加，所以会少一个）这样递推下去 $\dots$</p>
<p>有 $2^n+2^{n-1}+\dots+2^m-\text{Numbers - 1 }=X$ </p>
<p>即一个 <code>二进制串化为十进制</code> $-$ <code>(该二进制串中 1 的个数-1)</code> = $X$</p>
<p>将该二进制串 $\to$ 递增的子序列 $\to n$ 个最大且最长的子序列 $+\dots+m$ 个最短且最小的子序列(啮合在一起即可)   </p>
<p>大概我的思路就是这样，但是感觉实现就是差一点 $\dots$<br>(待更 $\dots$)</p>
<p><span style="color:#92d050">Jiangly 代码：</span><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cal</span>(x - <span class="number">1</span>);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(--l);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cal</span>(x / <span class="number">2</span>);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(++r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.<span class="built_in">clear</span>();</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cal</span>(x);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : ans)</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>榜一的答案</p>
<p>(未搞懂 <code>if ((x &gt;&gt; i) &amp; 1)</code> 如何保证的正确性 $\dots$)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> t = __lg(x); <span class="comment">//如果用log2(x)会wa</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = t - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>__lg(x)</code> 函数返回的是整数，为 $\lfloor{\log_{2}(x)}\rfloor$ 的准确值</li>
<li><code>log2(x)</code> 函数返回的是浮点数，因此可能会有浮点数误差的存在 $\dots$</li>
</ul>
<h2 id="F-Replace-on-Segment"><a href="#F-Replace-on-Segment" class="headerlink" title="F. Replace on Segment"></a>F. Replace on Segment</h2><p>(待更 $\dots$)</p>
]]></content>
      <categories>
        <category>cf</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>cf</tag>
      </tags>
  </entry>
  <entry>
    <title>B3644 拓扑排序 &amp; 家谱树 - 洛谷</title>
    <url>/posts/f358de70/</url>
    <content><![CDATA[<h1 id="【模板】拓扑排序-家谱树"><a href="#【模板】拓扑排序-家谱树" class="headerlink" title="【模板】拓扑排序 / 家谱树"></a>【模板】拓扑排序 / 家谱树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有个人的家族很大，辈分关系很混乱，请你帮整理一下这种关系。给出每个人的后代的信息。输出一个序列，使得每个人的后辈都比那个人后列出。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行一个整数 $N$（$1 \le N \le 100$），表示家族的人数。接下来 $N$ 行，第 $i$ 行描述第 $i$ 个人的后代编号 $a<em>{i,j}$，表示 $a</em>{i,j}$ 是 $i$ 的后代。每行最后是 $0$ 表示描述完毕。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个序列，使得每个人的后辈都比那个人后列出。如果有多种不同的序列，输出任意一种即可。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0</span><br><span class="line">4 5 1 0</span><br><span class="line">1 0</span><br><span class="line">5 3 0</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4 5 3 1</span><br></pre></td></tr></table></figure>
<p><del>很久之前可能是 Gpt 写的代码</del><br>邻接表的写法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topsort</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = G.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">du</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            du[G[i][j]]++;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!du[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> person = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(person);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[person].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> son = G[person][i];</span><br><span class="line">            du[son]--;</span><br><span class="line">            <span class="keyword">if</span> (!du[son])</span><br><span class="line">                q.<span class="built_in">push</span>(son);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">G</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> son;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; son &amp;&amp; son != <span class="number">0</span>)</span><br><span class="line">            G[i].<span class="built_in">push_back</span>(son - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">topsort</span>(G);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; result[i] + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>[[链式前向星存图]] </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, next;</span><br><span class="line">&#125; edge[<span class="number">2</span>*N];</span><br><span class="line"><span class="type">int</span> head[N], du[N];</span><br><span class="line"><span class="type">int</span> cnt, n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt] = &#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!du[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> person = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(person);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[person]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> son = edge[i].to;</span><br><span class="line">            du[son]--;</span><br><span class="line">            <span class="keyword">if</span> (!du[son])</span><br><span class="line">                q.<span class="built_in">push</span>(son);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);<span class="comment">// memset(du, 0, sizeof du);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; x &amp;&amp; x != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">addEdge</span>(i, x), du[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>B3645 数列前缀和 2 - 洛谷</title>
    <url>/posts/ca92b638/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/B3645">B3645 数列前缀和 2 - 洛谷</a><br><a href="https://www.luogu.com.cn/blog/lrqlrq250/b-3645-shuo-lie-qian-zhui-hu-2-ti-xie">B 3645 数列前缀和2 题解 - lrqlrq250 的博客 - 洛谷博客</a></p>
<p>常用的 $\LaTeX$ 公式<br>![[../../../../images/Z-attachment/Pasted image 20231127160008.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231127154615.png]]</p>
<p> $\prod \limits<em>{i=l}^r a_i \pmod p$ 发现等价于 $\Huge{\frac{\prod\limits</em>{i=1}^{r}a<em>i}{\prod\limits</em>{i=1}^{l-1} a_i}}$ </p>
<p> 则答案为 $\prod\limits<em>{i=1}^{r}a_i \times inv[\prod\limits</em>{i=1}^{l-1}a_i]$ , $inv[i]$ 为 $i$ 在 $\mod p$ 意义下的乘法逆元</p>
<p>即为 $s[r]\times inv[s[l-1]]$ ,<br>$\therefore$ $ans\ \oplus={s[r]\times inv[s[l-1]]}$ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll p = <span class="number">1145141</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">ll a[<span class="number">1000010</span>],inv[<span class="number">1200010</span>],s[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    s[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++) s[i] = s[i - <span class="number">1</span>] * a[i] % p;<span class="comment">//前缀积s[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= p; i++)<span class="comment">//到p，不是到n!!！</span></span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        ans ^= s[r] * inv[s[l<span class="number">-1</span>]] % p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>逆元</tag>
        <tag>学习路线</tag>
        <tag>前缀积</tag>
      </tags>
  </entry>
  <entry>
    <title>P1102 A-B 数对 - 洛谷</title>
    <url>/posts/65c06670/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对 - 洛谷 </a></p>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>出题是一件痛苦的事情！</p>
<p>相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共两行。</p>
<p>第一行，两个正整数 $N,C$。</p>
<p>第二行，$N$ 个正整数，作为要求处理的那串数。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 1 2 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $75\%$ 的数据，$1 \leq N \leq 2000$。</p>
<p>对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i &lt;2^{30}$，$1 \leq C &lt; 2^{30}$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, c, a[<span class="number">200010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        ans += <span class="built_in">upper_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, a[i] + c) - <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, a[i] + c);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>B3646 数列前缀和 3 - 洛谷</title>
    <url>/posts/278eda21/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/B3646">Fetching Title#moor</a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//先放着，实力还不够，看不懂🤣</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>矩阵运算</tag>
        <tag>逆元</tag>
        <tag>学习路线</tag>
        <tag>前缀积</tag>
      </tags>
  </entry>
  <entry>
    <title>P1352 没有上司的舞会 - 洛谷</title>
    <url>/posts/754aae50/</url>
    <content><![CDATA[<p> <a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会 - 洛谷</a><br>与 [[P2607 骑士 - 洛谷]]很像<br>树形 dp 模板题</p>
<h1 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某大学有 $n$ 个职员，编号为 $1\ldots n$。</p>
<p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p>
<p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p>
<p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><script type="math/tex; mode=display">\boxed{\begin{align}&n\\&r_{1}\\&r_{2}\\&\vdots&\text{(n lines)}\\&r_{n}\\&l_{1}&k_{1}\\&l_{2}&k_{2}\\&\vdots&\text{(n-1 lines)}&\vdots\\&l_{n-1}&k_{n-1}\end{align}}</script><p>输入的第一行是一个整数 $n$。<br>第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。<br>第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。</p>
<p>保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表最大的快乐指数。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>样例解释：<br><img data-src="D:\\python_code\\A_Dance_without_Bosses.png" alt="500"><br>选择 ${1,2,6,7,5}$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dp</tag>
        <tag>图的存储</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P1453 城市环路 - 洛谷</title>
    <url>/posts/688fe984/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1453">P1453 城市环路 - 洛谷</a><br>与 [[P2607 骑士 - 洛谷]]也是有关联。</p>
<h1 id="城市环路"><a href="#城市环路" class="headerlink" title="城市环路"></a>城市环路</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一座城市，往往会被人们划分为几个区域，例如住宅区、商业区、工业区等等。</p>
<p>B 市就被分为了以下的两个区域——城市中心和城市郊区。在这两个区域的中间是一条围绕 B 市的环路，环路之内便是 B 市中心。</p>
<p>整个城市可以看做一个 $n$ 个点，$n$ 条边的单圈图（保证图连通），唯一的环便是绕城的环路。保证环上任意两点有且只有 $2$ 条简单路径互通。图中的其它部分皆隶属城市郊区。</p>
<p>现在，有一位名叫 Jim 的同学想在 B 市开店，但是任意一条边的 $2$ 个点不能同时开店，每个点都有一定的人流量，第 $i$ 个点的人流量是 $p_i$，在该点开店的利润就等于 $p_i×k$，其中 $k$ 是一个常数。</p>
<p>Jim 想尽量多的赚取利润，请问他应该在哪些地方开店？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>$\boxed{\begin{align}&amp;n\&amp;a<em>{1}&amp;a</em>{2}&amp;&amp;\dots&amp;&amp;a<em>{n}\&amp;u</em>{1}&amp;v<em>{1}\&amp;u</em>{2}&amp;v<em>{2}\&amp;\vdots\&amp;u</em>{n}&amp;v_{n}\&amp;k\end{align}}$<br>第一行一个整数 $n$，代表城市中点的个数。城市中的 $n$ 个点由 $0 \sim n-1$ 编号。<br>第二行有 $n$ 个整数，第 $(i + 1)$ 个整数表示第 $i$ 个点的人流量 $p_i$。<br>接下来 $n$ 行，每行有两个整数 $u, v$，代表存在一条连接 $u$ 和 $v$ 的道路。<br>最后一行有一个实数，代表常数 $k$。<br>(点从 0 开始)<br>数据范围：<br>$1 \leq n \leq 10^5$，$1 \leq p_i \leq 10^4$，$0 \leq u, v &lt; n$，$0 \leq k \leq 10^4$，$\max{precision()\ is\ 6}$.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个实数代表答案，结果保留一位小数。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 1 5</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12.0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基环树</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU新生赛</title>
    <url>/posts/67dae086/</url>
    <content><![CDATA[<h1 id="1004-智能车"><a href="#1004-智能车" class="headerlink" title="1004 智能车"></a><a href="https://acm.hdu.edu.cn/contest/problem?cid=1116&amp;pid=1004">1004 智能车</a></h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>看是否存在若干中方案使得 $p<em>{x</em>{1}}+p<em>{x</em>{2}}+p<em>{x</em>{3}}+\dots=c$ </p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>一共 $T$ 组数据，对于每一组数据：<br>$\boxed{\begin{array}&amp;n&amp;c\p<em>{1}&amp;p</em>{2}&amp;p<em>{3}&amp;\dots&amp;p</em>{n}\end{array}}$<br>数据范围：</p>
<ul>
<li>$1\leq T\leq 10$</li>
<li>$1\leq n\leq 5\times 10^4$</li>
<li>$1\leq c\leq 500$</li>
<li>$1\leq p_{i}\leq c$<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2>找出一个方案满足最大值和最小值相差最小，求出最小的差值。如果不存在满足条件的方案，输出−1。<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4 10</span><br><span class="line">3 7 2 5</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2>样例中，一种可行的方案是 $[3,2,5]$，差值为 $3$。可以证明不存在差值更小的方案。<h1 id="1008-大雪球"><a href="#1008-大雪球" class="headerlink" title="1008 大雪球"></a><a href="https://acm.hdu.edu.cn/contest/problem?cid=1116&amp;pid=1008">1008 大雪球</a></h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2>把两个不同的数合成一个更大的数扔出去<br>例如两个数的大小分别为 $x,y$ 可以合成一个 $x+y$ 的大数。<br>求出在所有的合成方案中，第 $k$ 小的大数的大小。<br>两个合成方案不同当且仅当至少一个数的序号不同。<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2>有 $T$ 组数据，对于每组数据;<br>$\boxed{\begin{array}&amp;n\v<em>{1}&amp;v</em>{2}&amp;v<em>{3}&amp;\dots&amp;v</em>{n}\k\end{array}}$<br>数据范围： </li>
<li>$1\leq T\leq 10,2\leq n\leq 1\times10^5,1\leq v_{i}\leq 10^9,1\leq k\leq \frac{n\times(n-1)}{2}$<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2>输出第 $k$ 小的大数的大小。 </li>
</ul>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">2 3 4 5</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>样例中，可以合成 $6$ 种不同的大雪球，按体积排序后为 $[5,6,7,7,8,9]$，因此体积第 $3$ 小的大雪球的体积为 7。</p>
<h1 id="1009-序列"><a href="#1009-序列" class="headerlink" title="1009 序列"></a><a href="https://acm.hdu.edu.cn/contest/problem?cid=1116&amp;pid=1009">1009 序列</a></h1><p>求 $\sum\limits<em>{l=1}^n\sum\limits</em>{r=l}^n(a<em>{l}\oplus a</em>{l+1}\oplus\dots \oplus a<em>{r})\times \min</em>{l\leq i\leq r}a<em>{i}$ 对 $998244353$ 取模的值。<br>输入<br>$\boxed{\begin{array}&amp;T\n\a</em>{1}&amp;a<em>{2}&amp;a</em>{3}&amp;\dots&amp;a_{n}\end{array}}$<br>输出答案<br>输入样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">2 3 4</span><br><span class="line">5</span><br><span class="line">5 12 18 8 17</span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">62</span><br><span class="line">2219</span><br></pre></td></tr></table></figure><br>代码(不确定正确性)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; n; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> prefixXOR = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minVal = a[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt; n; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            prefixXOR ^= a[r];</span><br><span class="line">            minVal = <span class="built_in">min</span>(minVal, a[r]);</span><br><span class="line">            ans = (ans + (prefixXOR * minVal) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h1><p>![[../../../../images/Z-attachment/Pasted image 20231230174217.png]]<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="type">int</span>&gt; &amp;evilValue, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[node][k] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[node][k];</span><br><span class="line">    <span class="type">int</span> result = (evilValue[node] &lt;= k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node])</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= evilValue[node])</span><br><span class="line">            result = (result + <span class="built_in">dfs</span>(neighbor, k / evilValue[node], graph, evilValue, dp)) % MOD;</span><br><span class="line">    dp[node][k] = result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, m, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">evilValue</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; evilValue[i];</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            graph[u - <span class="number">1</span>].<span class="built_in">push_back</span>(v - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> totalPaths = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            totalPaths = (totalPaths + <span class="built_in">dfs</span>(i, k, graph, evilValue, dp)) % MOD;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; totalPaths &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h1><p>![[../../../../images/Z-attachment/Pasted image 20231230174200.png]]<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> grid[MAXK][MAXN][MAXN];</span><br><span class="line"><span class="type">bool</span> visited[MAXK][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in">sizeof</span>(visited));</span><br><span class="line">        <span class="type">int</span> n, m, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; m; l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cin &gt;&gt; grid[i][j][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> h, ex, ey;</span><br><span class="line">        cin &gt;&gt; h &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line"></span><br><span class="line">        queue&lt;State&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;n, m, <span class="number">0</span>&#125;);</span><br><span class="line">        visited[<span class="number">0</span>][n][m] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            State cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.x == ex &amp;&amp; cur.y == ey)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; cur.t &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nx = cur.x + dx[i];</span><br><span class="line">                <span class="type">int</span> ny = cur.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; m)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[(cur.t + <span class="number">1</span>) % k][nx][ny] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= h; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tx = nx - j;</span><br><span class="line">                    <span class="keyword">if</span> (tx &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[(cur.t + <span class="number">1</span>) % k][tx][ny] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (visited[(cur.t + <span class="number">1</span>) % k][tx][ny])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    visited[(cur.t + <span class="number">1</span>) % k][tx][ny] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;tx, ny, cur.t + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1005"><a href="#1005" class="headerlink" title="1005"></a>1005</h1><p>![[../../../../images/Z-attachment/Pasted image 20231230174109.png]]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tree;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; depth;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; xorValues;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; weight;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent, <span class="type">int</span> xorVal, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    depth[node] = d;</span><br><span class="line">    xorValues[node] = xorVal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> child : tree[node])</span><br><span class="line">        <span class="keyword">if</span> (child != parent)</span><br><span class="line">            <span class="built_in">dfs</span>(child, node, xorVal ^ weight[node][child], d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        tree.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        depth.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        xorValues.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        weight.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u, v, w;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            tree[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            tree[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">            weight[u][v] = w;</span><br><span class="line">            weight[v][u] = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, x;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt;= r; j++)</span><br><span class="line">                result += xorValues[j] ^ xorValues[x];</span><br><span class="line">            cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        tree.<span class="built_in">clear</span>();</span><br><span class="line">        depth.<span class="built_in">clear</span>();</span><br><span class="line">        xorValues.<span class="built_in">clear</span>();</span><br><span class="line">        weight.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h1><p>![[../../../../images/Z-attachment/Pasted image 20231230174412.png]]</p>
<h1 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h1><p>![[../../../../images/Z-attachment/Pasted image 20231230174703.png]]</p>
]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>补题</tag>
      </tags>
  </entry>
  <entry>
    <title>P1163 银行贷款 - 洛谷</title>
    <url>/posts/7cd48c46/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1163">P1163 银行贷款 - 洛谷 </a></p>
<h1 id="银行贷款"><a href="#银行贷款" class="headerlink" title="银行贷款"></a>银行贷款</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>三个用空格隔开的正整数。</p>
<p>第一个整数表示贷款的原值 $w_0$，第二个整数表示每月支付的分期付款金额 $w$，第三个整数表示分期付款还清贷款所需的总月数 $m$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个实数，表示该贷款的月利率（用百分数表示），四舍五入精确到 $0.1\%$。</p>
<p>数据保证答案不超过 $300.0\%$。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 100 12</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.9</span><br></pre></td></tr></table></figure>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1 \leq w_0, w\leq 2^{31}-1$，$1 \leq m\leq 3000$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> sumt = w0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        sumt = sumt + sumt * mid - w;</span><br><span class="line">    <span class="keyword">if</span> (sumt &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将 <code>check</code> 省略这样写：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> w, w0, m, l, r, sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; w0 &gt;&gt; w &gt;&gt; m;</span><br><span class="line">    l = <span class="number">0</span>,r = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">while</span> (r-l &gt; <span class="number">1e-5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>,sumt = w0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            sumt = sumt + sumt * mid - w;</span><br><span class="line">        <span class="keyword">if</span> (sumt &gt; <span class="number">0</span>)  ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ok)  r = mid;</span><br><span class="line">        <span class="keyword">else</span>     l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; fixed &lt;&lt; l*<span class="number">100</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P2607 骑士 - 洛谷</title>
    <url>/posts/ab410030/</url>
    <content><![CDATA[<p>与 [[P1352 没有上司的舞会 - 洛谷]]很像<br>[[P1453 城市环路 - 洛谷]]<br>这相关的三道题就当是一类的题型，一起看。</p>
<h1 id="P2607-ZJOI2008-骑士-洛谷"><a href="#P2607-ZJOI2008-骑士-洛谷" class="headerlink" title="P2607 [ZJOI2008] 骑士 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P2607">P2607 [ZJOI2008] 骑士 - 洛谷</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。</p>
<p>最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。</p>
<p>骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。</p>
<p>战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。</p>
<pre><code>为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。
</code></pre><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>$\boxed{\begin{align}&amp;n\&amp;f<em>{1}&amp;h</em>{1}\&amp;f<em>{2}&amp;h</em>{2}\&amp;\vdots&amp;(\text{n lines})\&amp;f<em>{n}&amp;h</em>{n}\end{align}}$<br>第一行包含一个整数 $n$，描述骑士团的人数。<br>接下来 $n$ 行，每行两个整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。<br>$1\le n \le 10^6$，$1\leq f_{i}\leq 10^6$ </p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>应输出一行，包含一个整数，表示所选出的骑士军团的最高战斗力。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10 2</span><br><span class="line">20 3</span><br><span class="line">30 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基环树</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>P2863 The Cow Prom S - 洛谷</title>
    <url>/posts/d3ddad2a/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2863">P2863 [USACO06JAN] The Cow Prom S - 洛谷</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 $n$ 个点，$m$ 条边的有向图，请求出这个图点数大于 $1$ 的强连通分量个数。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为两个整数 $n$ 和 $m$。</p>
<p>第二行至 $m+1$ 行，每一行有两个整数 $a$ 和 $b$，表示有一条从 $a$ 到 $b$ 的有向边。</p>
<p>数据范围： $2\le n \le 10^4$，$2\le m\le 5\times 10^4$，$1 \leq a, b \leq n$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，表示点数大于 $1$ 的强连通分量个数。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>董晓的模板直接用没有问题。oiwiki 的模板是链式前向星的模板，这个题还是邻接表更简单易懂一些。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], tot;</span><br><span class="line"><span class="type">int</span> stk[N], instk[N], top;</span><br><span class="line"><span class="type">int</span> scc[N], siz[N], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tot;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    instk[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y : e[x]) <span class="comment">//邻接表存图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">            <span class="built_in">tarjan</span>(y), low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (instk[y])</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = stk[top--];</span><br><span class="line">            instk[y] = <span class="number">0</span>;</span><br><span class="line">            scc[y] = cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b); <span class="comment">//邻接表存图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instk[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (siz[i] &gt; <span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title>P1890 gcd区间</title>
    <url>/posts/d1aee2f4/</url>
    <content><![CDATA[<h1 id="1-P1890-gcd区间-洛谷"><a href="#1-P1890-gcd区间-洛谷" class="headerlink" title="1 P1890 gcd区间 - 洛谷"></a>1 <a href="https://www.luogu.com.cn/problem/P1890">P1890 gcd区间 - 洛谷</a></h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述</h2><p>给定 $n$ 个正整数 $a_1,a_2,\dots,a_n$。</p>
<p>$m$ 次询问，每次询问给定一个区间 $[l,r]$，输出 $a<em>l,a</em>{l+1},\dots,a_r$ 的最大公因数。</p>
<h2 id="2-输入格式"><a href="#2-输入格式" class="headerlink" title="2 输入格式"></a>2 输入格式</h2><p>第一行两个整数 $n,m$。<br>第二行 $n$ 个整数表示 $a_1,a_2,\dots,a_n$。<br>以下 $m$ 行，每行两个整数 $l, r$ 表示询问区间的左右端点。</p>
<h2 id="3-输出格式"><a href="#3-输出格式" class="headerlink" title="3 输出格式"></a>3 输出格式</h2><p>共 $m$ 行，每行表示一个询问的答案。</p>
<h2 id="4-样例-1"><a href="#4-样例-1" class="headerlink" title="4 样例 #1"></a>4 样例 #1</h2><h3 id="4-1-样例输入-1"><a href="#4-1-样例输入-1" class="headerlink" title="4.1 样例输入 #1"></a>4.1 样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 12 3 6 7</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure>
<h3 id="4-2-样例输出-1"><a href="#4-2-样例输出-1" class="headerlink" title="4.2 样例输出 #1"></a>4.2 样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="5-提示"><a href="#5-提示" class="headerlink" title="5 提示"></a>5 提示</h2><ul>
<li>$1 \leq l \leq r \leq n \leq 1000$，$1\leq m \leq 10^6$，$1 \leq a_i \leq 10^9$。</li>
</ul>
<p>首先，对于 $i=j$ 的情况，显然有 $F[i][j]=a[i]$。</p>
<p>然后，对于 $i&lt;j$ 的情况，我们可以递推得到 $F[i][j]$ 的值。具体地，我们可以根据 $F[i][i]$ 和 $F[i+1][j]$ 的值来计算 $F[i][j]$.</p>
<p>动态转移方程：$f[i,j] = \gcd (f[i,i], f[i + 1,j])$.</p>
<h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6 代码"></a>6 代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, f[<span class="number">1010</span>][<span class="number">1010</span>], l, r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; f[i][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;=<span class="number">1</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            f[i][j] = __gcd(f[i][i], f[i + <span class="number">1</span>][j]);</span><br><span class="line">    <span class="keyword">while</span> (m--) cin &gt;&gt; l &gt;&gt; r,cout &lt;&lt; f[l][r] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>刷题路线</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2973</title>
    <url>/posts/d0fdc3b6/</url>
    <content><![CDATA[<p>[[威尔逊定理]]</p>
<p>给定 $n$, 计算</p>
<p>$\sum_{k=1}^n\left\lfloor\frac{(3k+6)!+1}{3k+7}-\left\lfloor\frac{(3k+6)!}{3k+7}\right\rfloor\right\rfloor$</p>
<p>思路：<br>容易想到<a href="https://www.luogu.com.cn/blog/FXJ-HOME/wei-er-xun-ding-li">威尔逊定理</a></p>
<ol>
<li>若 $3k+7$ 是质数，则<br>$(3k+6)!\equiv-1\pmod{3k+7}$</li>
</ol>
<p>易得 $(3k+6)!+1=m(3k+7)$</p>
<p>则<br>$\left\lfloor\frac{(3 k+6)!+1}{3 k+7}-\left\lfloor\frac{(3 k+6)!}{3 k+7}\right\rfloor\right\rfloor=\left\lfloor m-\left\lfloor m-\frac{1}{3 k+7}\right\rfloor\right\rfloor=1$</p>
<ol>
<li>若 $3k+7$ 不是质数 ,则有 $(3k+7)\mid(3k+6)!$ (由威尔逊定理的推论）</li>
</ol>
<p>设 $(3k+6)!=k(3k+7)$，</p>
<p>$\left\lfloor\frac{(3k+6)!+1}{3k+7}-\left\lfloor\frac{(3k+6)!}{3k+7}\right\rfloor\right\rfloor=\left\lfloor k+\frac{1}{3k+7}-k\right\rfloor=0$</p>
<p>因此</p>
<p>$\sum<em>{k=1}^n\left\lfloor\frac{(3k+6)!+1}{3k+7}-\left\lfloor\frac{(3k+6)!}{3k+7}\right\rfloor\right\rfloor=\sum</em>{k=1}^n[3k+7\text{ is prime}]$</p>
<p>考虑<a href="https://www.luogu.com.cn/blog/FXJ-HOME/eratosthenes-shai-fa">筛法</a>: [[素数筛法]]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>, N = <span class="number">3</span> * M + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line"><span class="type">int</span> sum[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!not_prime[i])</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j * i &lt; N; ++j) </span><br><span class="line">      not_prime[j * i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M; ++i) </span><br><span class="line">  sum[i] = sum[i - <span class="number">1</span>] + !not_prime[<span class="number">3</span> * i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  std::cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; sum[n] &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title>16109</title>
    <url>/posts/2ac9f00a/</url>
    <content><![CDATA[<h2 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h2><p>时间限制为 4 秒。</p>
<p>如果一个序列的乘积可以表示为两个平方数之和，则该序列被称为好序列。例如：</p>
<p>{1, 1, 1} 是好序列，因为 $1<em>1</em>1 = 1 = 0^2 + 1^2$。<br>{6, 164, 15} 是好序列，因为 $6<em>164</em>15 = 14760 = 42^2 + 114^2$。<br>{2, 3} 不是好序列，因为 $2*3 = 6$，而 6 不可能表示为两个平方数的和。</p>
<p>一个序列 X 的子序列是指从 X 中删除零个或多个元素而保持剩余元素顺序不变得到的任何序列。如果两个相同序列的子序列通过删除不同的索引对应到不同序列上，则它们是不同的。</p>
<p>给定大小为 N 的数组 A，A 中的元素是正整数。</p>
<p>还给出了一些查询 Q。对于第 i 个查询，考虑由 A 中下标从 $QL[i]$ 到 $QR[i]$的元素形成的序列 $A_i$。第 $i$ 个查询的答案是序列 $A_i$ 的非空好子序列的数量。</p>
<p>计算所有查询的答案，并返回它们对 $998244353$ 取模的和。</p>
<p>为了保持输入尺寸较小，你只给出了 A，QL 和 QR 的前缀，在 $int[]$ 中使用以下伪代码生成完整的数组：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">state = seed</span><br><span class="line"></span><br><span class="line">A = Aprefix</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">length</span>(A) &lt; N:</span><br><span class="line">    state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) modulo <span class="number">2</span>^<span class="number">31</span></span><br><span class="line">    A.<span class="built_in">append</span>( <span class="number">1</span> + state modulo <span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line">QL = QLprefix</span><br><span class="line">QR = QRprefix</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(L) &lt; Q:</span><br><span class="line">    state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) modulo <span class="number">2</span>^<span class="number">31</span></span><br><span class="line">    x = state modulo N</span><br><span class="line">    state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) modulo <span class="number">2</span>^<span class="number">31</span></span><br><span class="line">    y = state modulo N</span><br><span class="line">    QL.<span class="built_in">append</span>( <span class="built_in">min</span>(x,y) )</span><br><span class="line">    QR.<span class="built_in">append</span>( <span class="built_in">max</span>(x,y) )</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>类：<code>TaleOfTwoSquares</code></li>
<li>方法：<code>count</code></li>
<li>参数：<code>int, int[]，int, int[]，int[]，int</code></li>
<li>返回值：<code>int</code></li>
<li>方法签名：<code>int count (int N, int[] Aprefix, int Q, int[] QLprefix, int[] QRprefix, int seed)</code></li>
</ul>
<h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><ul>
<li>N 将在 $1$ 到 $10^5$ 之间，包括边界。</li>
<li>Aprefix 将有 $0$ 到 $\min (100, N)$个元素。</li>
<li>Aprefix 的每个元素将在 $1$ 到 $10^7$ 之间，包括边界。</li>
<li>Q 将在 $1$ 到 $10^5$ 之间，包括边界。</li>
<li>QLprefix 将有 0 到 $\min (100, Q)$个元素。</li>
<li>QRprefix 将与 QLprefix 具有相同数量的元素。</li>
<li>对于每个 i，$0 \leq QLprefix[i] \leq QRprefix[i] \leq N-1$。</li>
<li>seed 将在 $0$ 到 $2^{31} - 1$ 之间，包括边界。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="0"><a href="#0" class="headerlink" title="0 ."></a>0 .</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">&#123;1, 1, 1, 6, 164, 15, 2, 3&#125;</span><br><span class="line">3</span><br><span class="line">&#123;0, 3, 6&#125;</span><br><span class="line">&#123;2, 5, 7&#125;</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">Returns: 11</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们得到了整个数组 A、QL 和 QR。一共有三个查询。</p>
<ul>
<li>第 0 个查询询问序列{1, 1, 1}。这个序列的 7 个非空子序列都是好序列。</li>
<li>第 1 个查询询问序列{6, 164, 15}。只有子序列{6, 15}，{164}和{6, 164, 15}是好序列。</li>
<li>第 2 个查询询问序列{2, 3}。只有子序列{2}是好序列。<br>所有查询的答案之和为 $7 + 3 + 1 = 11$。<h4 id="1"><a href="#1" class="headerlink" title="1 ."></a>1 .</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40</span><br><span class="line">&#123;2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2&#125;</span><br><span class="line">300</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line">47</span><br><span class="line"></span><br><span class="line">Returns: 800453880</span><br></pre></td></tr></table></figure>
每个序列的所有非空子序列都是好序列。<h4 id="2"><a href="#2" class="headerlink" title="2 ."></a>2 .</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14</span><br><span class="line">&#123;47, 12345&#125;</span><br><span class="line">5</span><br><span class="line">&#123;4, 5&#125;</span><br><span class="line">&#123;6, 7&#125;</span><br><span class="line">47</span><br><span class="line"></span><br><span class="line">Returns: 11</span><br></pre></td></tr></table></figure>
你应该有以下数组：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = &#123;47, 12345, 5621309, 3614406, 1878299, 854092, 6820649, 3962434, 1250151, 3983528, 7736277, 8477438, 9514867, 2640324&#125;</span><br><span class="line">QL = &#123;4, 5, 5, 1, 3&#125;</span><br><span class="line">QR = &#123;6, 7, 8, 6, 6&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一个数字可以被表示为两个平方数的和，当且仅当它所有形式为 $4K+3$ 的质因数出现偶数次。所以，当我们计算几个数字的乘积时，我们只关心它的质因数分解；因此，我们可以为每个 $A_{i}$ 存储一个位向量，表示这些质因数的奇数/偶数出现。</p>
<p>从现在开始，<strong>每当我谈到质数时，假定它们为形式为 $4K+3$（对于某个 $k \in Z$），并且读者熟悉向量空间的基础和高斯消元。如果您对在竞赛编程中如何应用这些概念不熟悉，请阅读这篇文章：<a href="https://codeforces.com/blog/entry/68953">使用线性代数技术解决异或相关问题的入门博客</a></strong></p>
<p>现在，$A<em>{i}≤10^7$，因此质数的数量大约为 $3∗10^5$。普通的高斯消元甚至使用位集合也可能很容易超时。不过，让我们假设从最高位到最低位进行高斯消元并在必要时进行异或操作。注意，当您遍历时，如果存在任何大于 $\sqrt{ A</em>{i} }$ 的质因数（最多可以存在一个），一旦异或了它，就不会再有大于 $\sqrt{ A<em>{i} }$ 的位了（因为之前只有一个位是打开的，现在您已经异或了它）。现在，您可以简单地模拟对低阶质数（即质数 $≤\sqrt{ A</em>{i} }$）进行高斯消元，并单独处理那个最高位（如果存在的话）。这样，结合对低阶质数的位集合处理，就可以解决问题。</p>
<p>对于查询，让我们离线处理它们。让 $queries[l]$ 存储所有左端点为 $l$ 的查询。我们将从右侧将 $A_{i}$ 插入到我们的基向量中，其中 $i$ 从 $N-1$ 到 $0$。在我们插入索引 $i$ 处的元素之后，我们将回答所有在那里开始的查询，即 $queries[i]$ 中的查询。</p>
<p>我们将使用一个关于向量的线性组合的简单事实，但以聪明的方式来回答这些查询。假设我们将要尝试插入 $v$ 到我们的 $Basis$（如果结果是依赖的话，可能不会插入）。如果 $v=b<em>{1}+b</em>{2}+\dots+b<em>{k}$（其中 $b</em>{i}∈Basis$），那么我们可以删除 $b_i$ 中的一个，并将 $v$ 放在它的位置，保持基向量不变。因此，我们在插入时将使用这一事实。我们将尝试保留基向量中左端的索引，以回答尽可能多的查询。我们可以贪婪地实现这一点：在插入 $v$ 时，每当我们要与一些 $b_i$ 进行异或操作时，我们将首先检查哪个索引最小，如果 $v$ 的索引小于 $b_i$，我们将 $swap(b_i, v)$。如果最终进行了交换，那么 $v$ 将成为基向量的一部分（代替 $b_i$），并且我们将使用 $b_i$ 进行高斯消元。否则，我们将像正常情况一样继续进行。更多细节，请参考附加的代码。</p>
<p>现在，当我们回答左端点为 $i$ 的查询时，我们将拥有基向量 $A[i:N]$，其具有可能的最小索引。因此，对于一个查询 $i$ 到 $R$，我们只需要计算基向量中索引 $≤R$ 的数量。这可以很容易地使用一些 BIT 或 set 完成。</p>
<p>让 $K$ 表示 $\leq \sqrt{ A_{i} }$ 的质数的数量（$=225$）。我们为每个质数存储一个大小为 $K$ 的 [[bitset]] 。在进行高斯消元时，我们手动处理大位数，然后按照常规程序处理低阶质数；因此，插入 $A_i$ 花费 $O (\frac{K^2}{64})$ 的时间。之后，在 $O (log (N))$ 的时间内回答 $O (log (N))$ 中的查询。因此，总体复杂度是 $O \left( N⋅ \frac{k^2}{64}+Q⋅log (N) \right)$，由使用 [[bitset]] 的高斯消元支配。</p>
<p>Reference sol in C++</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SQRTMAX = <span class="number">3162</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SMALL_PRIME_COUNT = <span class="number">225</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SMALL_PRIMES[] = &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">127</span>, <span class="number">131</span>, <span class="number">139</span>, <span class="number">151</span>, <span class="number">163</span>, <span class="number">167</span>, <span class="number">179</span>, <span class="number">191</span>, <span class="number">199</span>, <span class="number">211</span>, <span class="number">223</span>, <span class="number">227</span>, <span class="number">239</span>, <span class="number">251</span>, <span class="number">263</span>, <span class="number">271</span>, <span class="number">283</span>, <span class="number">307</span>, <span class="number">311</span>, <span class="number">331</span>, <span class="number">347</span>, <span class="number">359</span>, <span class="number">367</span>, <span class="number">379</span>, <span class="number">383</span>, <span class="number">419</span>, <span class="number">431</span>, <span class="number">439</span>, <span class="number">443</span>, <span class="number">463</span>, <span class="number">467</span>, <span class="number">479</span>, <span class="number">487</span>, <span class="number">491</span>, <span class="number">499</span>, <span class="number">503</span>, <span class="number">523</span>, <span class="number">547</span>, <span class="number">563</span>, <span class="number">571</span>, <span class="number">587</span>, <span class="number">599</span>, <span class="number">607</span>, <span class="number">619</span>, <span class="number">631</span>, <span class="number">643</span>, <span class="number">647</span>, <span class="number">659</span>, <span class="number">683</span>, <span class="number">691</span>, <span class="number">719</span>, <span class="number">727</span>, <span class="number">739</span>, <span class="number">743</span>, <span class="number">751</span>, <span class="number">787</span>, <span class="number">811</span>, <span class="number">823</span>, <span class="number">827</span>, <span class="number">839</span>, <span class="number">859</span>, <span class="number">863</span>, <span class="number">883</span>, <span class="number">887</span>, <span class="number">907</span>, <span class="number">911</span>, <span class="number">919</span>, <span class="number">947</span>, <span class="number">967</span>, <span class="number">971</span>, <span class="number">983</span>, <span class="number">991</span>, <span class="number">1019</span>, <span class="number">1031</span>, <span class="number">1039</span>, <span class="number">1051</span>, <span class="number">1063</span>, <span class="number">1087</span>, <span class="number">1091</span>, <span class="number">1103</span>, <span class="number">1123</span>, <span class="number">1151</span>, <span class="number">1163</span>, <span class="number">1171</span>, <span class="number">1187</span>, <span class="number">1223</span>, <span class="number">1231</span>, <span class="number">1259</span>, <span class="number">1279</span>, <span class="number">1283</span>, <span class="number">1291</span>, <span class="number">1303</span>, <span class="number">1307</span>, <span class="number">1319</span>, <span class="number">1327</span>, <span class="number">1367</span>, <span class="number">1399</span>, <span class="number">1423</span>, <span class="number">1427</span>, <span class="number">1439</span>, <span class="number">1447</span>, <span class="number">1451</span>, <span class="number">1459</span>, <span class="number">1471</span>, <span class="number">1483</span>, <span class="number">1487</span>, <span class="number">1499</span>, <span class="number">1511</span>, <span class="number">1523</span>, <span class="number">1531</span>, <span class="number">1543</span>, <span class="number">1559</span>, <span class="number">1567</span>, <span class="number">1571</span>, <span class="number">1579</span>, <span class="number">1583</span>, <span class="number">1607</span>, <span class="number">1619</span>, <span class="number">1627</span>, <span class="number">1663</span>, <span class="number">1667</span>, <span class="number">1699</span>, <span class="number">1723</span>, <span class="number">1747</span>, <span class="number">1759</span>, <span class="number">1783</span>, <span class="number">1787</span>, <span class="number">1811</span>, <span class="number">1823</span>, <span class="number">1831</span>, <span class="number">1847</span>, <span class="number">1867</span>, <span class="number">1871</span>, <span class="number">1879</span>, <span class="number">1907</span>, <span class="number">1931</span>, <span class="number">1951</span>, <span class="number">1979</span>, <span class="number">1987</span>, <span class="number">1999</span>, <span class="number">2003</span>, <span class="number">2011</span>, <span class="number">2027</span>, <span class="number">2039</span>, <span class="number">2063</span>, <span class="number">2083</span>, <span class="number">2087</span>, <span class="number">2099</span>, <span class="number">2111</span>, <span class="number">2131</span>, <span class="number">2143</span>, <span class="number">2179</span>, <span class="number">2203</span>, <span class="number">2207</span>, <span class="number">2239</span>, <span class="number">2243</span>, <span class="number">2251</span>, <span class="number">2267</span>, <span class="number">2287</span>, <span class="number">2311</span>, <span class="number">2339</span>, <span class="number">2347</span>, <span class="number">2351</span>, <span class="number">2371</span>, <span class="number">2383</span>, <span class="number">2399</span>, <span class="number">2411</span>, <span class="number">2423</span>, <span class="number">2447</span>, <span class="number">2459</span>, <span class="number">2467</span>, <span class="number">2503</span>, <span class="number">2531</span>, <span class="number">2539</span>, <span class="number">2543</span>, <span class="number">2551</span>, <span class="number">2579</span>, <span class="number">2591</span>, <span class="number">2647</span>, <span class="number">2659</span>, <span class="number">2663</span>, <span class="number">2671</span>, <span class="number">2683</span>, <span class="number">2687</span>, <span class="number">2699</span>, <span class="number">2707</span>, <span class="number">2711</span>, <span class="number">2719</span>, <span class="number">2731</span>, <span class="number">2767</span>, <span class="number">2791</span>, <span class="number">2803</span>, <span class="number">2819</span>, <span class="number">2843</span>, <span class="number">2851</span>, <span class="number">2879</span>, <span class="number">2887</span>, <span class="number">2903</span>, <span class="number">2927</span>, <span class="number">2939</span>, <span class="number">2963</span>, <span class="number">2971</span>, <span class="number">2999</span>, <span class="number">3011</span>, <span class="number">3019</span>, <span class="number">3023</span>, <span class="number">3067</span>, <span class="number">3079</span>, <span class="number">3083</span>, <span class="number">3119</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; SMALL_PRIME_ID, pow2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick1D</span> &#123; <span class="comment">// &#123;&#123;&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Fenwick1D</span>(<span class="type">int</span> maxval) &#123;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size &lt; maxval) size &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        T.<span class="built_in">clear</span>();</span><br><span class="line">        T.<span class="built_in">resize</span>(size+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> delta)</span> </span>&#123; <span class="comment">// assumes 1 &lt;= x &lt;= init_maxval</span></span><br><span class="line">        <span class="keyword">while</span> (x &lt;= size) &#123; T[x] += delta; x += x &amp; -x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span> </span>&#123; <span class="comment">// sum in the closed interval [x1,x2]</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        --x1;</span><br><span class="line">        <span class="keyword">while</span> (x2) &#123; res += T[x2]; x2 -= x2 &amp; -x2; &#125;</span><br><span class="line">        <span class="keyword">while</span> (x1) &#123; res -= T[x1]; x1 -= x1 &amp; -x1; &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> sum)</span> </span>&#123; <span class="comment">// largest z such that sum( [1,z] ) &lt;= sum</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>, bitMask = size;</span><br><span class="line">        <span class="keyword">while</span> (bitMask &amp;&amp; (idx &lt; size)) &#123;</span><br><span class="line">            <span class="type">int</span> tIdx = idx + bitMask;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= T[tIdx]) &#123; idx=tIdx; sum -= T[tIdx]; &#125;</span><br><span class="line">            bitMask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// &#125;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SMALL_PRIME_ID.<span class="built_in">clear</span>();</span><br><span class="line">    SMALL_PRIME_ID.<span class="built_in">resize</span>(SQRTMAX+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SMALL_PRIME_COUNT; ++i) SMALL_PRIME_ID[ SMALL_PRIMES[i] ] = i;</span><br><span class="line">    pow2.<span class="built_in">clear</span>();</span><br><span class="line">    pow2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100005</span>; ++i) pow2.<span class="built_in">push_back</span>( (pow2.<span class="built_in">back</span>()*<span class="number">2</span>) % <span class="number">998244353</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">signature</span> &#123;</span><br><span class="line">    bitset&lt; SMALL_PRIME_COUNT &gt; small_bits;</span><br><span class="line">    <span class="type">int</span> large_bit;</span><br><span class="line">    <span class="built_in">signature</span>() : <span class="built_in">large_bit</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">highest_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (large_bit != <span class="number">-1</span>) <span class="keyword">return</span> large_bit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=SMALL_PRIME_COUNT<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) <span class="keyword">if</span> (small_bits.<span class="built_in">test</span>(i)) <span class="keyword">return</span> SMALL_PRIMES[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_xor</span><span class="params">(<span class="type">const</span> signature &amp;other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (other.large_bit != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (large_bit != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">assert</span>( large_bit == other.large_bit );</span><br><span class="line">                large_bit = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                large_bit = other.large_bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small_bits ^= other.small_bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, <span class="type">const</span> signature &amp;S) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int max = SMALL_PRIME_COUNT - 1;</span></span><br><span class="line"><span class="comment">    while (max &gt; 0 &amp;&amp; !S.small_bits.test(max)) --max;</span></span><br><span class="line"><span class="comment">    for (int i=0; i&lt;=max; ++i) out &lt;&lt; int( S.small_bits.test(i) );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (S.large_bit != <span class="number">-1</span>) out &lt;&lt; S.large_bit &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">9</span>; i&gt;=<span class="number">0</span>; --i) out &lt;&lt; <span class="built_in">int</span>(S.small_bits.<span class="built_in">test</span>(i));</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> query &amp;A, <span class="type">const</span> query &amp;B) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.l != B.l) <span class="keyword">return</span> A.l &gt; B.l;</span><br><span class="line">    <span class="keyword">return</span> A.r &lt; B.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">signature <span class="title">get_signature</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    signature answer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d=<span class="number">2</span>; d*d&lt;=N; ++d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N % d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (N % d == <span class="number">0</span>) &#123; ++cnt; N /= d; &#125;</span><br><span class="line">        <span class="keyword">if</span> (d % <span class="number">4</span> != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        answer.small_bits.<span class="built_in">set</span>( SMALL_PRIME_ID[d] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">1</span> &amp;&amp; N % <span class="number">4</span> == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt; SQRTMAX) answer.large_bit = N; <span class="keyword">else</span> answer.small_bits.<span class="built_in">set</span>( SMALL_PRIME_ID[N] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaleOfTwoSquares</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt; Aprefix, <span class="type">int</span> Q, vector&lt;<span class="type">int</span>&gt; Lprefix, vector&lt;<span class="type">int</span>&gt; Rprefix, <span class="type">int</span> seed)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> state = seed;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; A = Aprefix;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">int</span>(A.<span class="built_in">size</span>()) &lt; N) &#123;</span><br><span class="line">            state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) % (<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">            A.<span class="built_in">push_back</span>(<span class="number">1</span> + (state % <span class="number">10000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">20</span>) <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;N; ++n) cout &lt;&lt; A[n] &lt;&lt; <span class="string">&quot;, &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; L = Lprefix, R = Rprefix;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">int</span>(L.<span class="built_in">size</span>()) &lt; Q) &#123;</span><br><span class="line">            state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) % (<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">            <span class="type">int</span> x = state % N;</span><br><span class="line">            state = (state * <span class="number">1103515245</span> + <span class="number">12345</span>) % (<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">            <span class="type">int</span> y = state % N;</span><br><span class="line">            L.<span class="built_in">push_back</span>( <span class="built_in">min</span>(x,y) );</span><br><span class="line">            R.<span class="built_in">push_back</span>( <span class="built_in">max</span>(x,y) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Q &lt;= <span class="number">20</span>) <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;Q; ++n) cout &lt;&lt; L[n] &lt;&lt; <span class="string">&quot;, &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (Q &lt;= <span class="number">20</span>) <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;Q; ++n) cout &lt;&lt; R[n] &lt;&lt; <span class="string">&quot;, &quot;</span>; cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        vector&lt;signature&gt; B;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n=<span class="number">0</span>; n&lt;N; ++n) B.<span class="built_in">push_back</span>( <span class="built_in">get_signature</span>(A[n]) );</span><br><span class="line"></span><br><span class="line">        vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">query_by_L</span>(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q=<span class="number">0</span>; q&lt;Q; ++q) query_by_L[ L[q] ].<span class="built_in">push_back</span>( R[q] );</span><br><span class="line"></span><br><span class="line">        <span class="function">Fenwick1D <span class="title">InBase</span><span class="params">(N+<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; base_by_highest_prime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n=N<span class="number">-1</span>; n&gt;=<span class="number">0</span>; --n) &#123;</span><br><span class="line">            <span class="comment">// two dummy updates</span></span><br><span class="line">            InBase.<span class="built_in">update</span>(N+<span class="number">1</span>,+<span class="number">1</span>);</span><br><span class="line">            InBase.<span class="built_in">update</span>(N+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// add number A[n] to the base</span></span><br><span class="line">            <span class="keyword">if</span> (B[n].<span class="built_in">highest_prime</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">                InBase.<span class="built_in">update</span>(n+<span class="number">1</span>,+<span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> where = n;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> p = B[where].<span class="built_in">highest_prime</span>();</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">                        InBase.<span class="built_in">update</span>(where+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!base_by_highest_prime.<span class="built_in">count</span>(p)) &#123;</span><br><span class="line">                        base_by_highest_prime[p] = where;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> nxt = base_by_highest_prime[p];</span><br><span class="line">                    <span class="keyword">if</span> (nxt &gt; where) &#123;</span><br><span class="line">                        base_by_highest_prime[p] = where;</span><br><span class="line">                        B[nxt].<span class="built_in">do_xor</span>( B[where] );</span><br><span class="line">                        where = nxt;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        B[where].<span class="built_in">do_xor</span>( B[nxt] );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// answer queries that begin here</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r : query_by_L[n]) &#123;</span><br><span class="line">                <span class="type">int</span> length = r-n+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> base_size = InBase.<span class="built_in">sum</span>(n+<span class="number">1</span>,r+<span class="number">1</span>);</span><br><span class="line">                answer += pow2[length-base_size] - <span class="number">1</span>;</span><br><span class="line">                answer %= <span class="number">998244353</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>重庆市赛</title>
    <url>/posts/4769aac5/</url>
    <content><![CDATA[<p>summary: 第十一届重庆市大学生程序设计竟赛西南大学, 2023 年 12 月 17 日</p>
<h2 id="A-Yesterday-Once-More"><a href="#A-Yesterday-Once-More" class="headerlink" title="A Yesterday Once More"></a>A Yesterday Once More</h2><p><a href="https://swu.eduxiji.net/cguserImages?_img=239fc44c23aa3825a20a7a244b8b0fb8.png">原题</a></p>
<p>2 seconds  </p>
<p>256 megabytes  </p>
<p>历经四年, 终于再次迎来重庆市大学生程序设计竟赛。在第十届重庆市大学生程序设计竟赛中, 狂小 P 想解锁快乐 C 的 iPhone, 但是他只知道解锁密码由四位阿拉伯数字’ $0$ ‘ ~’ $9$ ‘组成。  </p>
<p>现在给你一个长度为 10 的数组 $D[0 . .9]$, 保证对于 $i \in[0,9] \cap \mathbb{Z}$, 都有 $D<em>{i} \in{0,1} \circ D</em>{i}=0$ 表示数字 $i$ 没有在解锁密码中出现, $D_{i}=1$ 表示数字 $i$ 在解锁密码中出现至少一次。  </p>
<p>四年前狂小 P 按照可能的密码从小到大逐一进行尝试, 在四年后的今天, 狂小 P 已经尝试到了 $a b c d$, 现在他想知道下一个需要尝试的可能的密码是多少。  </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含 10 个整数, 表示 $D[0 . .9]$<br>第二行包含一个长度为 4 的字符电, 表示 $a b c d$ 。<br>(保证在给出的输入下, $D[a], D[b], D[c], D[d]$ 都是 1 )。  </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个长度为 $4$ 的字符电, 表示下一个需要尝试的可能的密码是多少, 若不存在下一个可能的密码了, 输出 $-1$ 。  </p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>input 1<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 1 1 0 0 0 0 </span><br><span class="line">4445</span><br></pre></td></tr></table></figure><br>ouput 1<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4454</span><br></pre></td></tr></table></figure><br>input 2<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 1 0 0 0 </span><br><span class="line">6666</span><br></pre></td></tr></table></figure><br>ouput 2<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><br>input 3<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 0 0 0 0 0 0 0 0</span><br><span class="line">0001</span><br></pre></td></tr></table></figure><br>output 3<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0010</span><br></pre></td></tr></table></figure></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>比赛时，使用的是进制的做法，但是我需要 dfs 的写法.<br>gpt 4 dfs 写法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>], code[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; code[i] == <span class="number">9</span>)</span><br><span class="line">        code[i] = <span class="number">0</span>,i--;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        code[i]++;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cin &gt;&gt; d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        code[i] = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">inc</span>();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (d[code[i]] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                cout &lt;&lt; code[i];</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这段代码中，首先输入 $d[0… 9]$ 和当前密码 $abcd$。然后通过不断增加 $abcd$ 的值直到找到下一个符合要求的密码。<code>inc ()</code> 函数是用来增加密码的，如果找不到符合要求的密码，那么返回 <code>-1</code>。对于每个增加的密码，检查它的每一位是否都出现在 $d[0… 9]$ 中，如果都出现了，那么输出这个密码并结束程序。</p>
<h2 id="B-典"><a href="#B-典" class="headerlink" title="B 典"></a>B 典</h2><p><a href="../2ac9f00a">16109</a> 和 B 题很像。</p>
<p>Time limit:  2 seconds  </p>
<p>Memory limit:  256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=7c7a083d853bb9bbefa396ef642bb06d.png">原题</a></p>
<p>cxvdzxhb 喜欢平方数, 比如 $0,1,4,9,16, \ldots$ 。但是发现有些数可以表示成两个平方数的和, 他觉得这样的数<strong>典</strong>。比如 $1=0^{2}+1^{2}, 2=1^{2}+1^{2}, 10=1^{2}+3^{2}, 25=3^{2}+4^{2}$.<br>cxvdzxhbx 现在得到了一个长度为 $n$ 的序列 $a_{i}$ 和 $q$ 次询问。<br>每次问 $(l, r)$ 表示问区间 $[l, r]$ 中的数所构成的集合, 有多少个非空子集, 满足子集中的所有元素的乘积所表示的数<strong>典</strong>。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行 2 个整数 $n, q\left(1 \leqslant n, q \leqslant 10^{5}\right)$ 表示序列的元素数和询问个数。<br>第二行有 $n$ 个整数 $a<em>{i}\left(1 \leqslant a</em>{i} \leqslant 10^{7}\right)$ 。<br>接下来 $q$ 行, 其中第 $i$ 行有两个整数 $l<em>{i}, r</em>{i}\left(1 \leqslant l<em>{i} \leqslant r</em>{i} \leqslant n\right)$ 表示询问的区间。  </p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>对于每个询问, 输出一行一个整数, 表示答案, 由于答案可能非常大, 你需要对 $998244353$ 取模  </p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 2</span><br><span class="line">3 3</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h2 id="C-电路"><a href="#C-电路" class="headerlink" title="C 电路"></a>C 电路</h2><p>2 seconds  </p>
<p>256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=a361715568f17c737e72cbdbd3da3c55.png">原题</a></p>
<p>有一个电路, 由 $n$ 个元件和 $m$ 个导线构成。对于 $i$ 号元器件, 我们需要为该元件选择一个 $1 \sim L<em>{i}$ 的正整数电压, 记为 $a</em>{i}$, 为了让该元器件在该电压下正常工作, 我们需要 $c<em>{i, a i}$ 的成本。（并不是选择的电压越高成本越大)。对于导线 $i$, 它连接了两个元器件 $u, v$, 其电压分别为 $a</em>{u}, a<em>{v}$, 则这个导线需要维护成本 $b</em>{i} \times\left|a<em>{u}-a</em>{v}\right|$, 请你为每个元器件选择合适的电压, 让整个电路的成本最小。 </p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数 $n(1 \leq n \leq 30)$ 和 $m(1 \leq m \leq 100)$ 。<br>接下来 $n$ 行,其中第 $i$ 行开头有一个整数 $L<em>{i}\left(1 \leq L</em>{i} \leq 10\right)$, 接下来 $L<em>{i}$ 个整数 $c</em>{i, 1}, c<em>{i, 1}, \ldots, c</em>{i, L<em>{i}}$ $\left(1 \leq c</em>{i, j} \leq 10^{9}\right)$ 表示对于第 $i$ 个器件, 其电压为 $j$ 时的维护成本为 $c_{i, j}$ 。  </p>
<p>接下来 $m$ 行, 其中第 $i$ 行包含三个整数 $u, v(1 \leq u, v \leq n)$ 表示第 $i$ 根导线连接了 $u$ 和 $v$ 两个元件, $b<em>{i}$ $\left(1 \leq b</em>{i} \leq 10^{9}\right)$ 表示这两个元件的电压的单位差值下需要花费的成本。  </p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>输出仅一个整数, 表示最小成本。  </p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">4 1 100 100 100</span><br><span class="line">2 100 1</span><br><span class="line">3 100 100 1</span><br><span class="line">5 100 100 100 1 1</span><br><span class="line">2 100 1</span><br><span class="line">1 2 5</span><br><span class="line">1 3 5</span><br><span class="line">1 4 10</span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure></p>
<h2 id="D-搬空商店"><a href="#D-搬空商店" class="headerlink" title="D 搬空商店"></a>D 搬空商店</h2><p>Time limit:  2 seconds  </p>
<p>Memory limit:  256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=1d3a641656b65bb6a67367087c624694.png">原题</a></p>
<p>某手游有 $\mathrm{ABCD}$ 四个副本, 为了完美毕业, 你需要铜材料 $a$ 个, 银材料 $b$ 个, 金材料 $c$ 个, 特殊材料 $d$ 个。  </p>
<ul>
<li>刷一次 $\mathrm{A}$ 副本, 你可以得到 $A a$ 个铜材料, $A d$ 个特殊材料。  </li>
<li>刷一次 B 副本, 你可以得到 $B b$ 个银材料, $B d$ 个特殊材料。  </li>
<li>刷一次 $\mathrm{C}$ 副本, 你可以得到 $C c$ 个金材料, $C d$ 个特殊材料。  </li>
<li>刷一次 D 副本, 你可以得到 $D a$ 个铜材料, $D b$ 个银材料, $D c$ 个金材料, $D d$ 个特殊材料。  </li>
</ul>
<p>另外 5 个铜材料可以转换为 1 个银材料, 5 个银材料可以转换为 1 个金材料。<br>问最少刷多少次副本, 才能完美商店毕业, 同时你还想知道 ABCD 副本分别要刷多少次。如果有多个答案满足条件, 你想尽可能的少刷 $\mathrm{A}$ 副本。如果这时候还有多个答案满足条件, 就尽可能的少刷 $\mathrm{B}$ 副本。如果还有, 就尽可能的少刷 C 副本。  </p>
<h3 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h3><p>第一行 4 个整数 $a, b, c, d(1000 \leqslant a, b, c, d \leqslant 2000) 。$<br>第二行 2 个整数 $A a, A d(10 \leqslant A a, A d \leqslant 100)$ 。<br>第三行 2 个整数 $B b, B d(10 \leqslant B b, B d \leqslant 100)$ 。<br>第四行 2 个整数 $C c, C d(10 \leqslant C c, C d \leqslant 100)$ 。<br>第五行 4 个整数 $D a, D b, D c, D d(10 \leqslant D a, D b, D c, D d \leqslant 100) 。$  </p>
<h3 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h3><p>输出一行, 包含五个整数, 第一个整数表示总刷本次数, 后面四个整数分别表示 $\mathrm{ABCD}$ 本的刷本次数  </p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 200 300 400</span><br><span class="line">100 10</span><br><span class="line">90 10</span><br><span class="line">80 10</span><br><span class="line">10 11 12 70</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 1 2 3 5</span><br></pre></td></tr></table></figure></p>
<h2 id="E-Misreading"><a href="#E-Misreading" class="headerlink" title="E Misreading"></a>E Misreading</h2><p>Time limit:  2 seconds  </p>
<p>Memory limit:  256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=9c7a27ef4ce89ce024615ca895f393d5.png">原题</a></p>
<blockquote>
<p>[!NOTE] 原题</p>
<p>Given is a positive integer $n$. Consider repeatedly applying the operation below on $n$ : First, choose a positive integer $z$ satisfying all of the conditions below:  </p>
<ol>
<li>$z$ can be represented as $z=p^{e}$, where $p$ is a prime number and $e$ is a positive integer;  </li>
<li>$z$ divides $n$;  </li>
<li>$z$ is different from all integers chosen in previous operations.  </li>
</ol>
<p>Then, replace $n$ with $\frac{n}{z}$.<br>Find the maximum number of times the operation can be applied.<br>The above problem is from <a href="https://atcoder.jp/contests/abc169/tasks/abc169_d">D - Div Game</a></p>
<p>When lajiniunai first faced this problem, he read it wrong, changed the third condition to “ $e$ is different from all integers chosen in previous operations”. Then the three condition is changed to the following  </p>
<ol>
<li>$z$ can be represented as $z=p^{e}$, where $p$ is a prime number and $e$ is a positive integer;  </li>
<li>$z$ divides $n$;  </li>
<li>$e$ is different from all integers chosen in previous operations.  </li>
</ol>
<p>Now with others unchanging, find the maximum number of times the operation can be applied.  </p>
<h3 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h3><p>The first line contains a positive integer $T(1 \leqslant T \leqslant 1000)$ showing the number of test cases. Then $T$ cases follow, for each of the $T$ lines containing a positive integer $z\left(1 \leqslant z \leqslant 10^{18}\right)$.  </p>
<h3 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h3><p>For each test case, print one line containing a number showing the answer.</p>
</blockquote>
<h3 id="翻译版"><a href="#翻译版" class="headerlink" title="翻译版"></a>翻译版</h3><p>对于给定的正整数 $n$，考虑反复对 $n$ 应用以下操作：首先，选择一个满足以下所有条件的正整数 $z$：</p>
<ol>
<li>$z$ 可表示为 $z=p^{e}$，其中 $p$ 是一个质数，$e$ 是一个正整数；</li>
<li>$z$ 整除 $n$；</li>
<li>$e$ 与先前操作中选择的所有整数不同。</li>
</ol>
<p>然后，用 $\frac{n}{z}$ 替换 $n$。</p>
<p>找出可以执行此操作的最大次数。</p>
<p>当 lajiniunai 第一次面对这个问题时，他读错了题目，将第三个条件改成了“$e$ 与先前操作中选择的所有整数不同”。</p>
<p>现在在其他条件不变的情况下，找出可以执行此操作的最大次数。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含一个正整数 $T(1 \leqslant T \leqslant 1000)$，表示测试用例的数量。然后是 $T$ 个测试用例，每个测试用例包含一个正整数 $z(1 \leqslant z \leqslant 10^{18})$。</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每个测试用例，打印一行包含一个数字，表示答案。</p>
<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h2 id="F-交换"><a href="#F-交换" class="headerlink" title="F 交换"></a>F 交换</h2><p>Time limit:  1 seconds  </p>
<p>Memory limit:  256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=41bf2a1ce70244d12906dbd06b9ed318.png">原题</a></p>
<p>endereye 得到了一个只包含数字 $0-9$ 字符串 $s$, 他发现有时候<strong>交换相邻两个位置</strong>的字符，可以得到一<br>个全新的字符串 $t$。然后他不断重复这样的交换操作，得到了所有可能得到的字符串。他注意到，这其<br>中有些字符串只用至少 $1$ 次交换操作就可以得到，有些需要至少 $2$ 次交换操作，$\dots$ 有些至少需要 $k$ 次<br>交换操作。他想知道这个 $k$ 最大能是多少。<br>他不知道怎么计算这个答案，所以把问题交给了你。</p>
<h3 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数 $T (1≤T≤10)$。<br>接下来 $T$ 组数据：<br>每组数据第一行，包含一个整数 $n (1≤n≤10^5)$，表示字符串的长度。<br>第二行包含一个由数字 $0-9$ 构成的长度为 $n$ 字符串 $s$。</p>
<h3 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h3><p>每组数据输出仅包含一行，输出答案</p>
<h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h3><p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">121</span><br><span class="line">3</span><br><span class="line">123 </span><br><span class="line">3</span><br><span class="line">111</span><br><span class="line">3</span><br><span class="line">221</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="G-word-文档"><a href="#G-word-文档" class="headerlink" title="G word 文档"></a>G word 文档</h2><p>Time limit:  1 seconds  </p>
<p>Memory limit:  256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=6ceb495c1cfc024be6df901b71423073.png">原题</a></p>
<p>在 word 文档中, 有一个字符 $a$, 现在你可以进行以下几种操作任意次:  </p>
<ul>
<li>全选: 选中文档中所有字符。  </li>
<li>复制: 复制当前选中的字符到粘贴板。  </li>
<li>粘贴: 将粘贴板的内容粘贴, 如果当前没有选中任意字符, 则内容会追加在原内容的后面。如果当前选中了一些字符, 那么这些字符会被当前粘贴的内容替换, 并且会取消选中状态。  </li>
</ul>
<p>你需要用最少的次数, 将文档中的字符数量变为恰好 $n$ 个。  </p>
<h3 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个正整数 $T\left(1 \leq T \leq 10^{3}\right)$ 一表示数据组数。<br>接下来 $T$ 行, 每一行表示一组数据, 每组数据仅一个正整数 $n\left(1 \leq n \leq 10^{9}\right)$ 一意义如题。  </p>
<h3 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h3><p>$T$ 行, 每行包含一个非负整数, 表示该组数据的答案。  </p>
<h3 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h3><p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">9</span><br><span class="line">998244353</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">10</span><br><span class="line">998244355</span><br></pre></td></tr></table></figure></p>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>对于样例中的第二组数据, 变化过程如下:<br>$a \stackrel{\text { select }}{\longrightarrow} a \stackrel{\text { copy }}{\longrightarrow} a \stackrel{\text { paste } \times 3}{\longrightarrow}$ $aaa$ $\stackrel{\text { select }}{\longrightarrow} a a a \stackrel{\text { copy }}{\longrightarrow} a a a \stackrel{\text { paste } \times 3}{\longrightarrow}$ $aaaaaaaaa$<br>字符外的方框表示被选中状态。总共 $10$ 次操作。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>群友的代码 (记忆化搜索)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[n] = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, m = <span class="built_in">sqrt</span>(n); i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp.<span class="built_in">find</span>(n / i) == dp.<span class="built_in">end</span>())</span><br><span class="line">                <span class="built_in">dfs</span>(n / i);</span><br><span class="line">            dp[n] = <span class="built_in">min</span>(dp[n], dp[n / i] + <span class="number">2</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (dp.<span class="built_in">find</span>(n) != dp.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;0&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">dfs</span>(n);</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span> (<span class="literal">false</span>),cin.<span class="built_in">tie</span> (<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="H-Hotpot"><a href="#H-Hotpot" class="headerlink" title="H Hotpot"></a>H Hotpot</h2><p>Time limit:  2 seconds  </p>
<p>Memory limit:  256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=6fd3039443ba09066f31d8e008c004d8.png">原题</a></p>
<p>Chongqing hotpot is one of the most famous dishes around the world. People love its spicy taste.<br>There are $n$ types of ingredients (say Maodu, Yachang, Yageng, Neiroupian, Sanxianrou,…) for the hotpot in total, the number of each type is infinity. For $i$ -th ingredient, it needs to be cooked for $a_{i}$ minutes.  </p>
<p>Every minute, HeartBlack will add one ingredient to hotpot or take out all well-cooked (ready-to-eat) ingredients in the hotpot (If there are no cooked ingredients, she will do nothing).  </p>
<p>Given what HeartBlack does at the start of every minute.<br>For each time she takes out ingredient, you need to print the types of ingredients she takes out in increasing order (If she takes out nothing, print -1) in a line. Attention, if there are more than one ingredients of the same type, the output needs to be repeated. For example, if there are 3 ingredients of type 2 taken out, you should print “2 2 2 “.  </p>
<h3 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h3><p>The first line contains two positive integers, $n$ and $t\left(1 \leq n \leq 2 \times 10^{5}, 1 \leq t \leq 2 \times 10^{5}\right)$, denoting the number of types of ingredient and the total time eating hotpot (minute).  </p>
<p>The second line contains $n$ positive integers, $a<em>{1}, a</em>{2}, \ldots, a<em>{n}\left(1 \leq a</em>{i}&lt;t\right)$, denoting the time each ingredient needs to be cooked.  </p>
<p>The next $t$ lines consist of one or two integers each. The first integer of $i$ -th line is $b<em>{i}\left(b</em>{i} \in{0,1}\right)$, denoting what HeartBlack does in $i$ -th minute.  </p>
<p>If $b<em>{i}$ is 0 , there is one more integer $c</em>{i}\left(1 \leq c<em>{i} \leq n\right)$, denoting HeartBlack adds a $c</em>{i}$ -th type of ingredient to hotpot.  </p>
<p>If $b_{i}$ is 1 , denoting HeartBlack takes out all the cooked ingredient.  </p>
<h3 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h3><p>For each minute HeartBlack takes out, print the types of ingredients she takes out in increasing order in a line or print -1 when there are no cooked ingredients.</p>
<h3 id="Example-6"><a href="#Example-6" class="headerlink" title="Example"></a>Example</h3><p>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">1 2 3</span><br><span class="line">0 2</span><br><span class="line">1</span><br><span class="line">0 3</span><br><span class="line">0 2</span><br><span class="line">0 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">1 2 2 3</span><br></pre></td></tr></table></figure></p>
<h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>Attention, if there are more than one ingredients of the same type, the output needs to be repeated. For<br>example, if there are $3$ ingredients of type $2$ taken out, you should print”$2\ 2\ 2$”.</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><p>用 set 解决，还并不知道是否正确。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; b,cooked;<span class="comment">//b代表等等待成熟的食物，cooked代表已经成熟的食物</span></span><br><span class="line"><span class="type">int</span> n, t, a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> time = <span class="number">1</span>; time &lt;= t; time++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            b.<span class="built_in">insert</span>(&#123;x, time + a[x]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = b.<span class="built_in">begin</span>(); it != b.<span class="built_in">end</span>();)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (time &gt;= it-&gt;second)</span><br><span class="line">                &#123;</span><br><span class="line">                    cooked.<span class="built_in">insert</span>(&#123;it-&gt;first,k++&#125;);</span><br><span class="line">                    it = b.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cooked.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : cooked)</span><br><span class="line">                    cout &lt;&lt; v.first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            cooked.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="I-井盖"><a href="#I-井盖" class="headerlink" title="I 井盖"></a>I 井盖</h2><p>Time limit:  3 seconds  </p>
<p>Memory limit:  256 megabytes  </p>
<p><a href="https://swu.eduxiji.net/cguserImages?_img=b7cfb799c1855a9b24cdb5490e8a481e.png">原题</a></p>
<p>在路面上, 有 $n$ 个井盖, 井盖可以视作一个点, 其面积忽略不计, 第 $i$ 个井盖在坐标 $\left(x<em>{i}, y</em>{i}\right)$ 。每个井盖都有 $p_{i}$ 的概率坏掉, 为了防止行人掉进去, 工作人员决定用警戒线将所有坏掉的井盖围住, 同时警戒线的长度最短。围住后, 在警戒线内部的区域都无法进入了。现在工作人员想知道, 被警戒线围住的区域的面积的期望是多少。请你帮他计算一下，并告诉他对 $10^{9}+7$ 取模后的答案。  </p>
<p>如果答案能表示为有理数的形式 $\frac{a}{b}$, 则对质数 $M$ 取模后的答案为 $a \times b^{M-2} \bmod M$ 。  </p>
<h3 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数 $n(1 \leqslant n \leqslant 2000)$ 。<br>接下来 $n$ 行中, 第 $i$ 行包含 4 个整数 $x<em>{i}, y</em>{i}, a<em>{i}, b</em>{i}\left(-10^{9} \leq x<em>{i}, y</em>{i} \leq 10^{9}, 1 \leq a<em>{i}&lt;b</em>{i} \leq 10^{9}\right)$, 表示第 $i$ 个点的坐标 $\left(x<em>{i}, y</em>{i}\right)$, 和出现的概率 $p<em>{i}=\frac{a</em>{i}}{b_{i}}$ 。  </p>
<h3 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个整数, 表示答案。  </p>
<h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p>input 1<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 0 1 2</span><br><span class="line">1 0 1 3</span><br><span class="line">0 2 1 4</span><br></pre></td></tr></table></figure><br>  output 1<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">41666667</span><br></pre></td></tr></table></figure><br>input 2<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 0 1 2</span><br><span class="line">2 0 1 2</span><br><span class="line">0 2 1 2</span><br><span class="line">2 2 1 2</span><br></pre></td></tr></table></figure><br>output 2<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">750000006</span><br></pre></td></tr></table></figure></p>
<h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>在第一个样例中, 坏掉一个或两个井盖被围住的面积都是 0 , 当坏掉了三个井盖的时候, 围住的面积是 $1$ , 概率为 $\frac{1}{2} \times \frac{1}{3} \times \frac{1}{4}=\frac{1}{24}$, 取模后为 $1 \times 24^{10^{9}+7} \bmod \left(10^{9}+7\right)=41666667$ 。</p>
]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Proving Equivalences</title>
    <url>/posts/4b84046e/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVALive-4287">Proving Equivalences</a><br>与 [[Network of Schools]] 的第二问答案一样。<br><a href="https://www.luogu.com.cn/problem/UVA12167">luogu</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>考虑到上述练习在一本普通的线性代数教科书中找到。设 $A$ 是一个 $n × n$ 矩阵。证明以下说法是等价的:<br>$(\text{a})$ $A$ 是可逆的。<br>$(\text{b})$ $Ax = b$ 对于每个 $n × 1$ 矩阵 $b$ 恰好有一个解。<br>$(\text{c})$ $Ax = b$ 对于每个 $n × 1$ 矩阵 $b$ 是一致的。<br>$(\text{d})$ $Ax = 0$ 仅有平凡解 $x = 0$。</p>
<p>($a\leftrightarrow b\cap b\leftrightarrow c\cap c\leftrightarrow d\cap d\leftrightarrow a$ 和 $a\to b\cap b\to c\cap c\to d\cap d\to a$ 都能表明了这四个说法是等价，但是明显第二种简单很多。) 现在你的任务是证明 $n$ 个命题全部等价，且你的朋友已经为你做出了 $m$ 次推导（已知每次推导的内容），你至少还需要做几次推导才能完成整个证明？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>首先是一个正整数，表示测试用例的数量($T\leq 100$) 对于每个测试用例:</p>
<ul>
<li>一行，包含两个整数 $n(1 ≤ n ≤ 2\times 10^4)$ 和 $m (0 ≤ m ≤ 5\times 10^4)$：已经证明的陈述的数量和蕴含关系的数量。</li>
<li>$m$ 行，每行有两个整数 $s_1$ 和 $s_2$$(1 ≤ s_1, s_2 ≤ n 且 s_1 ≠ s_2)$，表示已经证明了陈述 $s_1$ 蕴含陈述 $s_2$。<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2>每个测试用例：</li>
<li>一行，包含需要证明的额外蕴含关系的最小数量，以便证明所有的陈述是等价的。<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 0</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>(似乎没有平台可以提交这个代码，但是应该是对的)<br><code>ans=max(!rdu[i],!cdu[i])</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], tot, cnt, scc[N], siz[N], top, instk[N], stk[N], cdu[N], rdu[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tot;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    instk[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y : e[x])</span><br><span class="line">    &#123; <span class="comment">//邻接表存图</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (instk[y])</span><br><span class="line">        &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = stk[top--];</span><br><span class="line">            instk[y] = <span class="number">0</span>;</span><br><span class="line">            scc[y] = cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(scc, <span class="number">0</span>, <span class="keyword">sizeof</span> scc);</span><br><span class="line">    <span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="keyword">sizeof</span> siz);</span><br><span class="line">    <span class="built_in">memset</span>(instk, <span class="number">0</span>, <span class="keyword">sizeof</span> instk);</span><br><span class="line">    <span class="built_in">memset</span>(stk, <span class="number">0</span>, <span class="keyword">sizeof</span> stk);</span><br><span class="line">    <span class="built_in">memset</span>(cdu, <span class="number">0</span>, <span class="keyword">sizeof</span> cdu);</span><br><span class="line">    <span class="built_in">memset</span>(rdu, <span class="number">0</span>, <span class="keyword">sizeof</span> rdu);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        e[i].<span class="built_in">clear</span>();</span><br><span class="line">    cnt = <span class="number">0</span>, tot = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (scc[i] != scc[v])</span><br><span class="line">            &#123;</span><br><span class="line">                cdu[scc[i]]++;</span><br><span class="line">                rdu[scc[v]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cdu[i])</span><br><span class="line">            cnt2++;</span><br><span class="line">        <span class="keyword">if</span> (!rdu[i])</span><br><span class="line">            cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(cnt1, cnt2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="origin-problem"><a href="#origin-problem" class="headerlink" title="origin problem"></a>origin problem</h2><p>![[../../../../images/Z-attachment/Pasted image 20231223211955.png]]</p>
]]></content>
      <categories>
        <category>ACMExercises</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>Network of Schools</title>
    <url>/posts/e931917d/</url>
    <content><![CDATA[<h2 id="Destription"><a href="#Destription" class="headerlink" title="Destription"></a>Destription</h2><p>许多学校都与计算机网络相连。这些学校之间已达成协议：每所学校都有一份向其分发软件的学校名单（“接收学校”）。注意，如果 $B$ 在学校 $A$ 的分发列表中，则 $A$ 不一定出现在学校 $B$ 的列表中</p>
<p>你要编写一个程序，<strong>计算必须收到新软件副本的学校的最小数量</strong>，以便软件根据协议到达网络中的所有学校（子任务 $A$）。作为进一步的任务，我们要确保通过向任意学校发送新软件的副本，该软件将到达网络中的所有学校。为了实现这一目标，我们可能需要增加新成员的接收者名单。<strong>计算必须进行的最小扩展数量</strong>，以便我们将新软件发送到任何学校，它将到达所有其他学校（子任务 $B$）。一个扩展意味着在一所学校的接收者名单中引入一个新成员。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行包含整数 $N$：网络中的学校数量（$2 \leq N \leq 100$）。学校由前 $N$ 个正整数标识。接下来的 $N$ 行中的每一行描述接收器列表。行 $i+1$ 包含学校 $i$ 的接收者的标识符。每个列表都以 $0$ 结尾。一个空列表只在一行中包含一个$0$。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>第一行应该包含一个正整数：子任务 $A$ 的解。第二行应该包含子任务 $B$ 的解决方案。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 3 0</span><br><span class="line">4 5 0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>问题在于如何理解 <code>ans1</code> <code>ans2</code><br><code>ans1=cnt(!rdu[i])</code> <code>ans2=max(ans1,!cdu[i])</code></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, dfn[N], low[N], tot, cnt, scc[N], siz[N], top, instk[N], stk[N], cdu[N], rdu[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tot;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    instk[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y : e[x])</span><br><span class="line">    &#123; <span class="comment">//邻接表存图</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (instk[y])</span><br><span class="line">        &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = stk[top--];</span><br><span class="line">            instk[y] = <span class="number">0</span>;</span><br><span class="line">            scc[y] = cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; x &amp;&amp; x)</span><br><span class="line">            e[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="comment">/*-------------------------------*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (scc[i] != scc[v])</span><br><span class="line">            &#123;</span><br><span class="line">                cdu[scc[i]]++;</span><br><span class="line">                rdu[scc[v]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cdu[i])</span><br><span class="line">            cnt2++;</span><br><span class="line">        <span class="keyword">if</span> (!rdu[i])</span><br><span class="line">            cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">max</span>(cnt1, cnt2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">/*--------------------------------*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ACMExercises</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>The Largest Clique</title>
    <url>/posts/1fc66dad/</url>
    <content><![CDATA[<p>%% ### 题目描述</p>
<p>给你一张有向图 $G$，求一个结点数最大的结点集，使得该结点集中的任意两个结点 $u$ 和 $v$ 满足：要么 $u$ 可以达 $v$，要么 $v$ 可以达 $u$ （$u,v$ 相互可达也行）。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，输入一个整数，代表测试数据组数 $T$，每组数据的格式如下。</p>
<p>第一行为结点数 $n$ 和边数 $m$，结点编号 $1 \sim n$。</p>
<p>以下 $m$ 行每行两个整数 $u$ 和 $v$ ，表示一条有向边 $u \to v$。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据，输出最大结点集的结点数。 %%</p>
<p>原题 <a href="https://uva.onlinejudge.org/external/113/p11324.pdf">PDF</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个有向图 $G$，考虑以下转换。<br>首先，创建一个新图 $T (G)$，其顶点集与 $G$ 相同。如果 $G$ 中存在从 $u$ 到 $v$ 的路径只按照正向方向连通，则在 $T (G)$中创建从顶点 $u$ 到顶点 $v$ 的有向边。这个图 $T(G)$通常被称为 $G$ 的传递闭包。<br>我们定义有向图中的团为顶点集 $U$，使得对于 $U$ 中的任意两个顶点 $u$ 和 $v$，从 $u$ 到 $v$ 或者从 $v$ 到 $u$（或者两者都有）存在有向边。团的大小是指团中顶点的数量。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行给出了案例的数量。<br>每个测试案例描述了一个图 $G$。<br>它以两个整数 $n$ 和 $m$ 开头，其中 G 的顶点数 ($0≤ n ≤ 1000$)， G 的有向边的数量 $(0≤ m ≤ 50,000)$。$G$ 的顶点从 $1$ 到 $n$ 编号。<br>接下来的 $m$ 行包含两个不同的整数 $u$ 和 $v$，它们在 $1$ 到 $n$ 之间，定义了 $G$ 中从 $u$ 到 $v$ 的有向边。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每个测试案例，输出一个整数，表示 $T (G)$ 中最大团的大小。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">4 1</span><br><span class="line">5 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Tarjan+记忆化搜索<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],e2[N];</span><br><span class="line"><span class="type">int</span> n, m, t, dfn[N], low[N], instk[N], siz[N], scc[N], stk[N], top, tot, cnt, in[N], out[N], maxsum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tot;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    instk[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y : e[x])</span><br><span class="line">    &#123; <span class="comment">//邻接表存图</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (instk[y])</span><br><span class="line">        &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = stk[top--];</span><br><span class="line">            instk[y] = <span class="number">0</span>;</span><br><span class="line">            scc[y] = cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxsum[u] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    maxsum[u] = siz[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : e2[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        maxsum[u] = <span class="built_in">max</span>(maxsum[u], siz[u] + maxsum[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span> low);</span><br><span class="line">    <span class="built_in">memset</span>(scc, <span class="number">0</span>, <span class="keyword">sizeof</span> scc);</span><br><span class="line">    <span class="built_in">memset</span>(siz, <span class="number">0</span>, <span class="keyword">sizeof</span> siz);</span><br><span class="line">    <span class="built_in">memset</span>(instk, <span class="number">0</span>, <span class="keyword">sizeof</span> instk);</span><br><span class="line">    <span class="built_in">memset</span>(stk, <span class="number">0</span>, <span class="keyword">sizeof</span> stk);</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span> in);</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">    <span class="built_in">memset</span>(maxsum, <span class="number">-1</span>, <span class="keyword">sizeof</span> maxsum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        e[i].<span class="built_in">clear</span>(),e2[i].<span class="built_in">clear</span>();</span><br><span class="line">    cnt = <span class="number">0</span>, tot = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//重新构建缩点之后的图</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : e[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (scc[i] != scc[j])</span><br><span class="line">            &#123;</span><br><span class="line">                e2[scc[i]].<span class="built_in">push_back</span>(scc[j]);</span><br><span class="line">                in[scc[j]]++;</span><br><span class="line">                out[scc[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i); </span><br><span class="line">            ans = <span class="built_in">max</span>(ans, maxsum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACMExercises</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>受欢迎的牛</title>
    <url>/posts/209a6e85/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>原题来自：USACO 2003 Fall<br>每一头牛的愿望就是变成一头最受欢迎的牛。现在有 $N$ 头牛，给你 $M$ 对整数 $(A, B)$ ，表示牛 $A$ 认为牛 $B$ 受欢迎。这种关系是具有传递性的，如果 $A$ 认为 $B$ 受欢迎， $B$ 认为 $C$ 受欢迎，那么牛 $A$ 也认为牛 $C$ 受欢迎。你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。  </p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数 $N, M$<br>接下来 $M$ 行，每行两个数 $A, B$ ，意思是 $A$ 认为 $B$ 是受欢迎的<br>(给出的信息有可能重复，即有可能出现多个 $A, B$ )。<br>$1 \leq N \leq 10^{4}, 1 \leq M \leq 5 \times 10^{4}$ 。  </p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出被除自己之外的所有牛认为是受欢迎的牛的数量。  </p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2  </span><br><span class="line">2 1  </span><br><span class="line">2 3  </span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Notes:只有第三头牛被除自己之外的所有牛认为是受欢迎的。  </p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>受欢迎的奶牛只有可能是</p>
<ul>
<li><mark style="background: #CACFD9A6;">图中唯一的出度为零的强连通分量中的所有奶牛</mark>，<br>若出现两个以上出度为 0 的强连通分量</li>
</ul>
<p>$\because$ 这时已经有两个奶牛不喜欢任何人了，就不可能存在明星奶牛了。</p>
<p>$\therefore$ 这时不存在明星奶牛</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m, dfn[N], low[N], instk[N], siz[N], top, tot, cnt, scc[N], stk[N], cdu[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tot;</span><br><span class="line">    stk[++top] = x;</span><br><span class="line">    instk[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y : e[x])</span><br><span class="line">    &#123; <span class="comment">//邻接表存图</span></span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (instk[y])</span><br><span class="line">        &#123;</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = stk[top--];</span><br><span class="line">            instk[y] = <span class="number">0</span>;</span><br><span class="line">            scc[y] = cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*---------------核心代码--------------------*/</span></span><br><span class="line">    <span class="comment">//记录强连通分量的出度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : e[x])</span><br><span class="line">            <span class="keyword">if</span> (scc[x] != scc[y])</span><br><span class="line">                cdu[scc[x]]++;<span class="comment">//rdu[scc[y]]++;</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cdu[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//出现两个以上出度为 0 的强连通分量</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; siz[ans] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//输出该强连通分量的大小 </span></span><br><span class="line"><span class="comment">/*---------------核心代码--------------------*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACMExercises</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>强连通</tag>
      </tags>
  </entry>
  <entry>
    <title>寂寞双十一</title>
    <url>/posts/ddd01a7c/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>今年的双十一太冷清了，冷清到没人愿意在网上购物了。小 w 饿了，但是太晚了，小 w 只能去自动贩卖机购买泡面。因为自动贩卖机没有找零的功能，所以如果小 $\mathrm{w}$ 想购买 $X$ 元的泡面就必须准确投入总和为 $X$ 元的硬币。现在小 w 手里只有 $A$ 枚 1 元硬币， $B$ 枚 5 元硬币和 $C$ 枚十元硬币，请问小 w 能否成功购买泡面</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入一行四个整数 $A, B, C, X$ ，保证 $1 \leq A, B, C \leq 10000,1 \leq X \leq 10^{5}$    </p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果无法购买，则输出一行 <code>Impossable</code>  如果可以购买，则输出方案数</p>
<h3 id="用例输入-1"><a href="#用例输入-1" class="headerlink" title="用例输入 1"></a>用例输入 1</h3><p><code>1 2 3 37</code></p>
<h3 id="用例输出-1"><a href="#用例输出-1" class="headerlink" title="用例输出 1"></a>用例输出 1</h3><p><code>Impossable</code></p>
]]></content>
      <categories>
        <category>ACMExercises</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>W1024理论的推演</title>
    <url>/posts/ac1e164e/</url>
    <content><![CDATA[<p><a href="http://swpuacm.cn/problem/W1024">W1024理论的推演</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>艾尔海森最近在教令院中抓捕犯下累累罪行的大贤者，大贤者能够在教令院手握大权，最重要的原因是教令院中内鬼很多！</p>
<p>作为一个普通的「文弱书生」，他决定在武力清除这些余党前做一些计算。首先他将教令院关系网络列出，由于艾尔海森智力超群，他只研究这张关系网络的最小生成树。<br>在这棵树上，标注了若干<mark style="background: #FF5582A6;">红色</mark>的点，表示教令院中的内鬼。整个教令院内鬼间的团结程度定义为：<strong><u>所有红色点之间的距离之和</u></strong>。</p>
<p>由于艾尔海森还要去找卡维♂玩游戏，他现在要求你，教令院的学者，求出这棵教令院内鬼关系网络的最小生成树的内鬼之间的团结程度。聪明的你，一定能轻松解决这个问题。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>$\boxed{\begin{align}&amp;n&amp;m\&amp;r<em>{1}&amp;r</em>{2}&amp;&amp;\dots&amp;&amp;r<em>{m}\&amp;u</em>{1}&amp;v<em>{1}\&amp;u</em>{2}&amp;v<em>{2}\&amp;\vdots &amp;n-1\text{ lines}\&amp;u</em>{n-1}&amp;v_{n-1}\end{align}}$</p>
<p>输入包含 $n+1$ 行</p>
<ul>
<li>第一行包含两个整数 $n, m$ 分别表示树的点数，红色点的个数</li>
<li>第二行包含 $m$ 个数，表示红色点的编号</li>
<li>第 $3$ 到第 $n+1$ 行，每行包含两个整数 $u, v$，表示 $(u, v)$ 之间有一条边。<br>数据范围：</li>
<li>$1\leq n\leq 10^5$</li>
<li>$1\leq m\leq n$</li>
<li>$0\leq u,v\leq n-1$<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2>一个数，表示答案。</li>
</ul>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 3</span><br><span class="line">0 7 8</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">0 7</span><br><span class="line">1 4</span><br><span class="line">3 5</span><br><span class="line">5 6</span><br><span class="line">6 8</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p><img data-src="http://swpuacm.cn/public/upload/a9989fcda8.png" alt="250"><br>如图所示，红色点之间的距离分别为 $5,4,1$，和为 $10$。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>两个红点相会，会经过某条边 $x \times y$ 次，其中 $x,y$ 分别为这条边左右的红点数量。<br>显然所有边的贡献之和即为所求，一次 dfs 即可解决</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>$\Huge{/<em>\dots TODO</em>/}$</p>
]]></content>
      <categories>
        <category>swpuoj</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>倍增</tag>
        <tag>树形dp</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>2023新生赛题解</title>
    <url>/posts/94b6e9e3/</url>
    <content><![CDATA[<h3 id="A-数一数三角形"><a href="#A-数一数三角形" class="headerlink" title="A 数一数三角形"></a>A 数一数三角形</h3><h4 id="难度：简单"><a href="#难度：简单" class="headerlink" title="难度：简单"></a>难度：简单</h4><pre><code>- 在一般情况下，只要三个点不要都在一条边上就一定能构成三角形
    所以在一般情况下，将所有特殊点加起来除以 3 向下取整就可以，即: `cnt/3`
</code></pre><ul>
<li>当一条边特殊点的数量远远多于其他边的时候，这个时候只有除了这条边之外的点 可以和这个边能构成三角形，构成的三角形个数是 <code>cnt-max(a[i])</code></li>
<li>注意数据范围，需要开 <code>long long</code><br>即结果为: <code>min(cnt/3,cnt-max(a[i])</code><br>代码如下:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll n, a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll cnt = <span class="number">0</span>, maxa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], cnt += a[i], maxa = <span class="built_in">max</span>(maxa, a[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(cnt / <span class="number">3</span>, cnt - maxa) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-作文批改"><a href="#B-作文批改" class="headerlink" title="B 作文批改"></a>B 作文批改</h3><h4 id="难度-：入门"><a href="#难度-：入门" class="headerlink" title="难度 ：入门"></a>难度 ：入门</h4>一道考察大家代码功底的模拟题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string word;</span><br><span class="line"><span class="type">bool</span> head = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n --)    </span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; word;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((word.<span class="built_in">size</span>() == <span class="number">1</span> || word[<span class="number">1</span>] &lt; <span class="string">&#x27;A&#x27;</span>) &amp;&amp; word[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans ++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i ++] &gt; <span class="string">&#x27;Z&#x27;</span>)ans ++;</span><br><span class="line">            head = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; word.<span class="built_in">length</span>(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i] &lt; <span class="string">&#x27;A&#x27;</span> &amp;&amp; word[i] != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(word[i] &lt; <span class="string">&#x27;a&#x27;</span> &amp;&amp; word[i] &gt;= <span class="string">&#x27;A&#x27;</span>)ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-找找-ACM"><a href="#C-找找-ACM" class="headerlink" title="C 找找 ACM"></a>C 找找 ACM</h3><h4 id="难度：中等"><a href="#难度：中等" class="headerlink" title="难度：中等"></a>难度：中等</h4><p>此题主要考察<strong>前缀和</strong>。当 <code>s[i]</code> 满足 <code>s[i-2]==&#39;a&#39;&amp;&amp;s[i-1]==&#39;c&#39;&amp;&amp;s[i]==&#39;m&#39;</code> 时，我们标记该点为合格点，再利用前缀和求出下标从 <code>0</code> 到 <code>i</code> 共有多少个合格点记为 <code>g[i]</code>。对于每个询问即求出下标 <code>l+2</code> 到 <code>r</code> 共有多少个合格点（即使 <code>l</code> 或 <code>l+1</code> 为合格点，其对应’acm’的左半部分也超出了 <code>[l, r]</code> 的范围），即 <code>g[r]-g[l+1]</code> 的值。</p>
<p>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">2</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; s[i] == <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">            g[i] = <span class="number">1</span>;</span><br><span class="line">        g[i] += g[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; g[r] - g[l + <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-字符串相约"><a href="#D-字符串相约" class="headerlink" title="D 字符串相约"></a>D 字符串相约</h3><h4 id="难度：中等-1"><a href="#难度：中等-1" class="headerlink" title="难度：中等"></a>难度：中等</h4><p>如果答案是 <code>YES</code>，那么我们总能把两个字符串都变成 $00 \dots 01 \dots 11$ 的形式（前缀是 0，后缀是 1，所有 0 都在所有 1 之前）。之所以这么说，是因为在使两个字符串相等后，我们还可以对 $l = i, r = |a|$ 进行另一种操作，其中 $i$ 是使两个字符串相等后都有 $1$ 的最小索引。例如，在第一个测试用例中，在应用了语句中的所有操作后，字符串等于 $01110001$ 。我们可以通过对 $l = 2, r = 8$ 进行操作，将它们变成字符串 $01111111$ 。</p>
<p>现在让我们试着找出何时可以将字符串转化为 $00 \dots 0011 \dots 11$ 的形式。我们假设，当且仅当 $s<em>i = 0$ 和 $s</em>{i+1} = 1$ 时，可以将字符串 $s$ 变换为 <code>i 首元素为 0，其余元素均为 1</code> 的形式：</p>
<ul>
<li>如果有 $s<em>i = 0$ 和 $s</em>{i+1} = 1$ ，我们可以对 $l = 1, r = i$ 和 $l = i+1, r = |s|$ 进行两次运算，字符串就会变成  <code>i 首元素为 0，其余元素均为 1</code>  的形式；</li>
<li>然而，如果情况并非如此，那么要么是 $s<em>i = s</em>{i+1}$ ，要么是 $s<em>i = 1$ 和 $s</em>{i+1} = 0$ 。在前一种情况下，我们需要改变这两个元素中的一个；但由于它们相等且相邻，对它们的每个操作都会影响到它们两个，因此不可能只改变其中一个。在后一种情况下，我们需要先将 $s<em>i$ 设置为 $0$ 或将 $s</em>{i+1}$ 设置为 $1$ ；当我们这样做时，这两个元素就变得相等了，对它们进行的任何操作都会同时影响到它们。因此，我们不可能将字符串变成<code>i 的第一个元素为 0，其余元素均为 1</code>的形式。</li>
</ul>
<p>因此，如果有一个索引 $i$ 能使 $a<em>i = b_i = 0$ 和 $a</em>{i+1} = b_{i+1} = 1$ 相等，那么答案就是 <code>YES</code>。否则，答案就是 <code>NO</code>。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> size = a.<span class="built_in">size</span>(), flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>;i++)</span><br><span class="line">	        <span class="keyword">if</span>(a[i]==b[i]&amp;&amp;a[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i+<span class="number">1</span>]==b[i+<span class="number">1</span>]&amp;&amp;a[i+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="E-简单-DP"><a href="#E-简单-DP" class="headerlink" title="E 简单 DP"></a>E 简单 DP</h3><h4 id="难度：中等-2"><a href="#难度：中等-2" class="headerlink" title="难度：中等"></a>难度：中等</h4><p>对于每次加入或者删除一个小球我们重新去做一遍 dp 显然是不行的. 因为朴素的 dp 就是一个背包, 时间复杂度为 O（nv）。<br>我们考虑加入一个 x 小球：其实很好看出来就是让 $dp[j+x]+=dp[j]$ 从前往后是正好模拟了 dp 过程, 要是删除一个 x 小球：则是让以前的 dp 数组去<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真有人打ACM O.o?</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(k+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">char</span> c;cin&gt;&gt;c;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=x)(dp[j]-=dp[j-x])%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=k-x;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                (dp[j+x]+=dp[j])%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;(dp[k]+mod)%mod&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="F-两点距离"><a href="#F-两点距离" class="headerlink" title="F 两点距离"></a>F 两点距离</h3><h4 id="难度：困难"><a href="#难度：困难" class="headerlink" title="难度：困难"></a>难度：困难</h4><p>知识点：线段树、二分<br>这道题目难度较高，大家不必深究，感兴趣的同学可以先尝试了解线段树<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// duziteng ^ ^</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;<span class="number">0</span>?a/b:(a+b<span class="number">-1</span>)/b;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fast ios::sync_with_stdio(false);cin.tie(nullptr);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,v,cnt;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;u=tr[i],&amp;l=tr[i&lt;&lt;<span class="number">1</span>],&amp;r=tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    u.v=l.v+r.v;</span><br><span class="line">    u.cnt=l.cnt+r.cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[i].l=l,tr[i].r=r,tr[i].cnt=<span class="number">0</span>,tr[i].v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> k2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=x&amp;&amp;tr[i].r&lt;=x)&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;u=tr[i];</span><br><span class="line">        u.v+=k;</span><br><span class="line">        u.cnt+=k2;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;x||tr[i].r&lt;x)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[i&lt;&lt;<span class="number">1</span>].r&gt;=x)<span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>,x,k,k2);</span><br><span class="line">    <span class="keyword">if</span>(tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l&lt;=x)<span class="built_in">modify</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,k,k2);</span><br><span class="line">    <span class="built_in">pushup</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l==tr[i].r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tr[i].l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[i&lt;&lt;<span class="number">1</span>].cnt&gt;=f)<span class="keyword">return</span> <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>,f);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,f-tr[i&lt;&lt;<span class="number">1</span>].cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PII res=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;=l&amp;&amp;tr[i].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;u=tr[i];</span><br><span class="line">        <span class="keyword">return</span> &#123;u.v,u.cnt&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[i].l&gt;r||tr[i].r&lt;l)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span>(tr[i&lt;&lt;<span class="number">1</span>].r&gt;=l)&#123;</span><br><span class="line">        PII now= <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">        res.first+=now.first;</span><br><span class="line">        res.second+=now.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l&lt;=r)&#123;</span><br><span class="line">        PII now= <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        res.first+=now.first;</span><br><span class="line">        res.second+=now.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n+<span class="number">1</span>);</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">mpp</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i]-=i*<span class="number">114514</span>;</span><br><span class="line">        mp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [pos,w]:mp)&#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        mp[pos]=idx;</span><br><span class="line">        mpp[idx]=pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,idx+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;mid;i++)<span class="built_in">modify</span>(<span class="number">1</span>,mp[a[i]],a[i],<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,mp[a[i]],a[i],<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> z=mpp[<span class="built_in">query</span>(<span class="number">1</span>,<span class="built_in">up</span>(mid,<span class="number">2</span>))];</span><br><span class="line"><span class="comment">//            cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;z&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">auto</span> [lv,lcnt]=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,mp[z]);</span><br><span class="line">            <span class="keyword">auto</span> [rv,rcnt]=<span class="built_in">query</span>(<span class="number">1</span>,mp[z]+<span class="number">1</span>,idx);</span><br><span class="line"><span class="comment">//            cout&lt;&lt;lcnt&lt;&lt;&#x27; &#x27;&lt;&lt;lv&lt;&lt;&#x27; &#x27;&lt;&lt;rcnt&lt;&lt;&#x27; &#x27;&lt;&lt;rv&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//            cout&lt;&lt;lcnt*z-lv+rv-rcnt*z&lt;&lt;&#x27; &#x27;&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(lcnt*z-lv+rv-rcnt*z&lt;=m)flag=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,mp[a[i-mid+<span class="number">1</span>]],-a[i-mid+<span class="number">1</span>],<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">fast</span></span><br><span class="line"><span class="function">    <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="G-每日一棵？"><a href="#G-每日一棵？" class="headerlink" title="G 每日一棵？"></a>G 每日一棵？</h3><h4 id="难度：中等-3"><a href="#难度：中等-3" class="headerlink" title="难度：中等"></a>难度：中等</h4><p>答案显然具有单调性<br>因此我们可以二分。对于 x 维我们可以直接排序解决，y 维我们可以维护一个前缀后缀 min max 即可<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;PII&gt;v;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;a,<span class="built_in">pre_mn</span>(n,INF),<span class="built_in">pre_mx</span>(n,-INF),<span class="built_in">suf_mn</span>(n,INF),<span class="built_in">suf_mx</span>(n,-INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        v.<span class="built_in">push_back</span>(&#123;x,y&#125;);</span><br><span class="line">        a.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(v));</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i)pre_mn[i]=<span class="built_in">min</span>(pre_mn[i],pre_mn[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(i)pre_mx[i]=<span class="built_in">max</span>(pre_mx[i],pre_mx[i<span class="number">-1</span>]);</span><br><span class="line">        pre_mn[i]=<span class="built_in">min</span>(pre_mn[i],v[i].second);</span><br><span class="line">        pre_mx[i]=<span class="built_in">max</span>(pre_mx[i],v[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=n<span class="number">-1</span>)suf_mn[i]=<span class="built_in">min</span>(suf_mn[i],suf_mn[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(i!=n<span class="number">-1</span>)suf_mx[i]=<span class="built_in">max</span>(suf_mx[i],suf_mx[i+<span class="number">1</span>]);</span><br><span class="line">        suf_mn[i]=<span class="built_in">min</span>(suf_mn[i],v[i].second);</span><br><span class="line">        suf_mx[i]=<span class="built_in">max</span>(suf_mx[i],v[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x=mid,flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> L=a[i];</span><br><span class="line">            <span class="type">int</span> R=a[i]+x;</span><br><span class="line">            <span class="type">int</span> it=<span class="built_in">lower_bound</span>(<span class="built_in">all</span>(a),R)-a.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>(it==n)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(pre_mx[i]-suf_mn[it]&gt;=x||suf_mx[it]-pre_mn[i]&gt;=x)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="H-amp-I-找-0and找-0-pro"><a href="#H-amp-I-找-0and找-0-pro" class="headerlink" title="H &amp; I 找 0and找 0_pro"></a>H &amp; I 找 0<em>and</em>找 0_pro</h3><h4 id="难度-：入门-amp-简单"><a href="#难度-：入门-amp-简单" class="headerlink" title="难度 ：入门&amp;简单"></a>难度 ：入门&amp;简单</h4><p>此题的本意考察大家思维或者说数学功底，不用使用高精度算法<br>我们只需查找 $a,b$ 两数中有多少对 2 和 5 的因子，因为一对 2，5 因子相乘等于 10. 也就是一对就一定有一个末尾0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> A = a, B = b;</span><br><span class="line">    <span class="keyword">while</span>(A % <span class="number">2</span> == <span class="number">0</span>)A /= <span class="number">2</span>, cnt1 ++;</span><br><span class="line">    <span class="keyword">while</span>(B % <span class="number">2</span> == <span class="number">0</span>)B /= <span class="number">2</span>, cnt1 ++;</span><br><span class="line">    <span class="keyword">while</span>(a % <span class="number">5</span> == <span class="number">0</span>)a /= <span class="number">5</span>, cnt2 ++;</span><br><span class="line">    <span class="keyword">while</span>(b % <span class="number">5</span> == <span class="number">0</span>)b /= <span class="number">5</span>, cnt2 ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(cnt1, cnt2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">solve</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="J-黎明之剑"><a href="#J-黎明之剑" class="headerlink" title="J 黎明之剑"></a>J 黎明之剑</h3><h4 id="难度：中等-4"><a href="#难度：中等-4" class="headerlink" title="难度：中等"></a>难度：中等</h4><p>思路：搜索的模板<br>考察宽搜/深搜, 敌方地盘用 # 表示，部分敌方地盘有碉堡用！表示，而答案要求输出的敌方地盘大小就是二者的和，需要派遣的白骑士的数量就是地盘的数量加碉堡数量的二倍。所以我们要找的就是地盘加碉堡的和的最大值，并且记录下当前这片区域碉堡的数量。因此宽搜或者深搜都可以解决，需要注意可以将所有已经跑过的路标除以免跑重复道路导致超时。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1060</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> c[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ti[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> tj[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> v[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="comment">//搜索</span></span><br><span class="line">	<span class="type">int</span> nans1=<span class="number">1</span>,nans2=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(c[a][b]==<span class="string">&#x27;!&#x27;</span>)nans2++;</span><br><span class="line">	v[a][b]=<span class="literal">false</span>;</span><br><span class="line">	queue&lt;node&gt; Q;</span><br><span class="line">	node X;</span><br><span class="line">	X.x=a,X.y=b;</span><br><span class="line">	Q.<span class="built_in">push</span>(X);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node fi=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> x=fi.x,y=fi.y;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">			<span class="keyword">if</span>(v[x+ti[i]][y+tj[i]])&#123;</span><br><span class="line">				nans1++;nans2++;</span><br><span class="line">				<span class="keyword">if</span>(c[x+ti[i]][y+tj[i]]==<span class="string">&#x27;!&#x27;</span>)nans2++;</span><br><span class="line">				node N;</span><br><span class="line">				N.x=x+ti[i],N.y=y+tj[i];</span><br><span class="line">				Q.<span class="built_in">push</span>(N);</span><br><span class="line">				v[x+ti[i]][y+tj[i]]=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nans1&gt;ans1)&#123;</span><br><span class="line">		ans1=nans1;</span><br><span class="line">		ans2=nans2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="literal">false</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			cin&gt;&gt;c[i][j];</span><br><span class="line">			<span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;*&#x27;</span>)v[i][j]=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> v[i][j]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="keyword">if</span>(v[i][j])<span class="built_in">find</span>(i,j);</span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="K-重构代码"><a href="#K-重构代码" class="headerlink" title="K 重构代码"></a>K 重构代码</h3><h4 id="难度：简单-1"><a href="#难度：简单-1" class="headerlink" title="难度：简单"></a>难度：简单</h4><p>思路：排序+贪心<br>考察任意排序算法，将所有 bug 的位置进行排序后，求出每两个 bug 差即为需要修改的行数。因为需要修改的段落尽可能的少，所以再次进行排序后从修改行数第 m+1 多的位置开始累加即为答案。题面增加了阅读难度因此需要看懂样例和样例说明。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10050</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,n,m;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> b[maxn];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		b[i<span class="number">-1</span>]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n-m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		ans+=b[i];</span><br><span class="line">	cout&lt;&lt;ans;</span><br></pre></td></tr></table></figure></p>
<h3 id="L-概率机器人"><a href="#L-概率机器人" class="headerlink" title="L 概率机器人"></a>L 概率机器人</h3><h4 id="难度：中等-5"><a href="#难度：中等-5" class="headerlink" title="难度：中等"></a>难度：中等</h4><p>此题考查知识点为动态规划——dp<br>其实 dp 大家早在中学阶段就有所接触，如数列的递推公式。求解 dp 问题的关键步骤即为找出递推方程。因为规定机器人只能向下或是向右走，那么在一个格子所获得的期望值一定来自于它右方格子的期望乘以概率+它下方格子的期望乘以概率。我们定义一个二维数组 <code>dp[1000][1000]</code> 那么可得到递推公式 $dp[i][j]=dp[i+1][j]\times p_1+dp[i][j+1]\times p_2$ 即可得出答案<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Grid</span>&#123;</span><br><span class="line">  <span class="type">double</span> value;</span><br><span class="line">  <span class="type">double</span> pd, pr;</span><br><span class="line">&#125;g[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">      g[i][j].value += g[i + <span class="number">1</span>][j].value * g[i][j].pd + g[i][j + <span class="number">1</span>].value * g[i][j].pr; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">        cin &gt;&gt; g[i][j].value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">        <span class="type">double</span> p;</span><br><span class="line">        cin &gt;&gt; p;</span><br><span class="line">        g[i][j].pd = p / <span class="number">100</span>;</span><br><span class="line">        g[i][j].pr = <span class="number">1</span> - p / <span class="number">100</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ans[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(ans, <span class="string">&quot;%.0lf&quot;</span>, g[<span class="number">0</span>][<span class="number">0</span>].value);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="M-养生的大学生"><a href="#M-养生的大学生" class="headerlink" title="M 养生的大学生"></a>M 养生的大学生</h3><h4 id="难度：简单-2"><a href="#难度：简单-2" class="headerlink" title="难度：简单"></a>难度：简单</h4><p>思路：二进制+贪心<br>考察思维，代码实现考察与或非运算或者模拟，文中提到至少需要两杯一样的才能合成一杯，当前拥有的杯数可以合成多少杯可以想成一杯最多可以装多少杯，显而易见的是一定是 $2^n$ 才能压缩成一个杯子。因此我们可以将给定的数字 n 转化成二进制表示，二进制情况下每拥有一个 1 就证明需要多加一个杯子。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>N 的值</th>
<th>二进制表达</th>
<th>需要的杯子数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>所以问题就变成了查找当前二进制中 1 的个数，如果超出 m 就想办法消掉 1，计算到达 m 至少需要加多少。</p>
<p>代码实现：</p>
<ul>
<li><p>如果熟悉与或非运算就会记得负数的补码转为原码是对补码（除符号位）逐位取反后，并在最低位＋1。-n 是 n 的二进制补码的求补运算，它等于 ~n + 1，再与 n 进行&amp;运算就可以获得最小 1 的位置。</p>
</li>
<li><p>如果对于或非不熟悉就可以暴力打表记录下 $2^{27}$ 所有数字的值然后手动模拟查找位数过程，也可以获得答案。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(__builtin_popcount(n) &gt; m) ans += n &amp; -n, n += n &amp; -n;</span><br><span class="line">    <span class="comment">//__builtin_popcount返回二进制数中1的个数</span></span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>W1032LCA</title>
    <url>/posts/2f0367e5/</url>
    <content><![CDATA[<p><a href="http://swpuacm.cn/problem/W1032">oj | 【模板】LCA</a><br><a href="https://loj.ac/p/10130">点的距离</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>求给定 $m$ 组询问，每次询问 两个点之间在树上的距离</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>$\boxed{\begin{align}&amp;n&amp;m\&amp;u<em>{1}&amp;v</em>{1}\&amp;u<em>{2}&amp;v</em>{2}\&amp;\vdots&amp;n-1\text{ lines}\&amp;u<em>{n-1}&amp;v</em>{n-1}\&amp;x<em>{1}&amp;y</em>{1}\&amp;x<em>{2}&amp;y</em>{2}\&amp;\vdots &amp;m\text{ lines}\&amp;x<em>{n}&amp;y</em>{n}\end{align}}$</p>
<p>数据范围： </p>
<ul>
<li>$1\leq n\leq 10^6$</li>
<li>$1\leq m\leq 10^5$</li>
<li>$0\leq u,v,x,y\leq n-1$</li>
<li>$x\neq y$<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2>输出 $m$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次询问的答案。</li>
</ul>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">0 4</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>样例说明<br><img data-src="http://43.136.219.90/public/upload/e133b9af75.png" alt="250"></p>
<p>这种题一般是倍增算法和树链解刨分，tarjan 算法在求 [[lca]] 用的不多。但是在求强连通分量用的最多<br>那么在求 LCA 时需要用到倍增。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dis</span>(x,y)=dep[x]+dep[y]<span class="number">-2</span>*dep[<span class="built_in">lca</span>(x,y)];</span><br></pre></td></tr></table></figure></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><p>在需要在模板基础上修改的地方后面加上了//<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, r;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; query[N];</span><br><span class="line"><span class="type">int</span> fa[N], vis[N], ans[N],dis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == fa[u])</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">return</span> fa[u] = <span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v] = dis[u] + <span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            fa[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q : query[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = q.first, i = q.second;</span><br><span class="line">        <span class="keyword">if</span> (vis[v])</span><br><span class="line">            ans[i] = dis[u] + dis[v] - dis[<span class="built_in">find</span>(v)] * <span class="number">2</span>;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">        query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>![[../../../../images/Z-attachment/Pasted image 20231224221840.png]]</p>
<h2 id="董晓对于-loj10130-的三种方法代码"><a href="#董晓对于-loj10130-的三种方法代码" class="headerlink" title="董晓对于 loj10130 的三种方法代码"></a>董晓对于 loj10130 的三种方法代码</h2><p>10130 . 「一本通 4.4 例 1」 <a href="https://lov.ac/p/10130">点的距离</a></p>
<h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//倍增算法  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,h=<span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dep[N],fa[N][<span class="number">19</span>],dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">  dep[u]=dep[father]+<span class="number">1</span>;</span><br><span class="line">  fa[u][<span class="number">0</span>]=father;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=h; i++)</span><br><span class="line">    fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    dis[v]=dis[u]+<span class="number">1</span>;        </span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y])</span><br><span class="line">      x=fa[x][i];</span><br><span class="line">  <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=h; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) </span><br><span class="line">      x=fa[x][i],y=fa[y][i];</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="type">int</span> d=dis[a]+dis[b]-dis[<span class="built_in">lca</span>(a,b)]*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树链剖分  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,c;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> dep[N],fa[N],son[N],sz[N],dis[N];</span><br><span class="line"><span class="type">int</span> top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">  fa[u]=father,dep[u]=dep[father]+<span class="number">1</span>,sz[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">    dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    sz[u]+=sz[v];</span><br><span class="line">    <span class="keyword">if</span>(sz[son[u]]&lt;sz[v])son[u]=v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">  top[u]=t;</span><br><span class="line">  <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[u],t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    x=fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="type">int</span> d=dis[a]+dis[b]-dis[<span class="built_in">lca</span>(a,b)]*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan-1"><a href="#Tarjan-1" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Tarjan 算法 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">vector&lt;PII&gt; query[N];</span><br><span class="line"><span class="type">int</span> fa[N],vis[N],dis[N];</span><br><span class="line"><span class="type">int</span> ans[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fa[u]==u) <span class="keyword">return</span> u;</span><br><span class="line">  <span class="keyword">return</span> fa[u]=<span class="built_in">find</span>(fa[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  vis[u]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">    dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">tarjan</span>(v);</span><br><span class="line">    fa[v]=u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> ed:query[u])&#123;</span><br><span class="line">    <span class="type">int</span> v=ed.first,i=ed.second;</span><br><span class="line">    <span class="keyword">if</span>(vis[v])</span><br><span class="line">      ans[i]=dis[u]+dis[v]-dis[<span class="built_in">find</span>(v)]*<span class="number">2</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    query[a].<span class="built_in">push_back</span>(&#123;b,i&#125;);</span><br><span class="line">    query[b].<span class="built_in">push_back</span>(&#123;a,i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>swpuoj</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>倍增</tag>
        <tag>LCA</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>W1053「无圆数」</title>
    <url>/posts/a9874a5e/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1 Description"></a>1 Description</h2><p>派派最近没能抽到喜欢的卡，他变成了一个《原神》黑子。现在他很讨厌看到圆。</p>
<p>尤其是数字里的圆。</p>
<p>通过问题 <a href="http://swpuacm.cn/problem/W1045">W1045 - 我超，原</a>，你已经知道数字 0,4,6,8,9 包含圆。</p>
<p><img data-src="http://swpuacm.cn/public/upload/d796c61f2d.png" alt="100"></p>
<p>并称呼这个新的计数系统叫做「无圆数」。现在他想将他所能看到的所有数字都变为「无圆数」，即，将所有十进制的正整数向所有「无圆数」进行映射。但是他正忙着玩《崩坏：星穹铁道》，并希望你能慷慨地帮助他解决这个小小的问题。</p>
<h2 id="2-Input"><a href="#2-Input" class="headerlink" title="2 Input"></a>2 Input</h2><p>输入仅包含一个正整数 x，表示派派想让你转换的数字。</p>
<p>这里「转换」的意思是，将所有「无圆数」列出后，排序后第 x 个「无圆数」是什么？</p>
<h3 id="2-1-数据范围"><a href="#2-1-数据范围" class="headerlink" title="2.1 数据范围"></a>2.1 数据范围</h3><ul>
<li>$1≤x≤77777777777777777$（一共 $17$ 个 $7$）。</li>
</ul>
<h2 id="3-Output"><a href="#3-Output" class="headerlink" title="3 Output"></a>3 Output</h2><p>输出 x 对应的「无圆数」。</p>
<h2 id="4-样例"><a href="#4-样例" class="headerlink" title="4 样例"></a>4 样例</h2><p>Sample Input 1<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><br>Sample Output 1<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><br>Sample Input 2<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><br>Sample Output 2<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">357</span></span><br></pre></td></tr></table></figure><br>Sample Input 3<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">77777777777777777</span></span><br></pre></td></tr></table></figure><br>Sample Output 3<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7777777</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-Hint"><a href="#5-Hint" class="headerlink" title="5 Hint"></a>5 Hint</h2><p><img data-src="http://swpuacm.cn/public/upload/d29325dca0.png" alt="100"><br>前 $10$ 个「无圆数」是：$1,2,3,5,7,11,12,13,15,17$。</p>
<p><strong>模拟五进制即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> w[<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        x--;<span class="comment">//卡在这里了（why）</span></span><br><span class="line">        <span class="type">int</span> y = x % <span class="number">5</span>;</span><br><span class="line">        w[++i] = a[y];</span><br><span class="line">        x /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        cout &lt;&lt; w[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>swpuoj</category>
      </categories>
      <tags>
        <tag>补题</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>新生赛</title>
    <url>/posts/f5c5d428/</url>
    <content><![CDATA[<h2 id="1-数一数三角形"><a href="#1-数一数三角形" class="headerlink" title="1 数一数三角形"></a>1 数一数三角形</h2><h3 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h3><blockquote>
<p>在那遥远的角落三条边相拥相依它们相隔却又相连像爱情中的你我他<br>三角形有着神秘的力量让我们的爱情纯粹又完美无论相隔多远，相连多近爱，永远如三角形般美丽</p>
</blockquote>
<p>你得到一个正 $N$ 边多边形。将任意一条边标记为边 $1$，然后按顺时针顺序将下一条边标记为边 $2$、$3$、$\dots$、$N$。在 $i$ 侧有 $A_i$ 个特殊点。这些点的位置使得边 $i$ 被分成长度相等的 $A_i + 1$ 段。</p>
<p>您希望创建尽可能多的 <strong>满足条件的三角形</strong>，同时满足以下要求。</p>
<ul>
<li>每个三角形由 3 个不同的特殊点组成（不一定来自不同的边）作为它的角。</li>
<li>每个特殊点只能成为最多 1 个三角形的角。</li>
<li>所有的三角形不能互相相交。<br>请你数一数可以创建的满足条件的三角形的<strong>最大数量</strong>。</li>
</ul>
<h3 id="1-2-输入"><a href="#1-2-输入" class="headerlink" title="1.2 输入"></a>1.2 <strong>输入</strong></h3><blockquote>
<p>$\boxed{\begin{array}&amp;N\ A<em>{1} &amp;A</em>{2}&amp;  &amp;\cdots&amp; &amp;A_{n} \end{array}}$</p>
<blockquote>
<p><strong>数据范围</strong>:<br>$3 \leq N \leq 200\ 000$, $1 \leq A_i \leq 2 \cdot 10^9$</p>
<h3 id="1-3-输出"><a href="#1-3-输出" class="headerlink" title="1.3 输出"></a>1.3 <strong>输出</strong></h3></blockquote>
<p>输出一个整数，表示可以创建的三角形的最大数量。</p>
</blockquote>
<h3 id="1-4-示例-1"><a href="#1-4-示例-1" class="headerlink" title="1.4 示例 1"></a>1.4 <strong>示例 1</strong></h3><p>输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 1 4 6</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="1-5-示例-2"><a href="#1-5-示例-2" class="headerlink" title="1.5 示例 2"></a>1.5 <strong>示例 2</strong></h3><p>输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h3 id="1-6-说明"><a href="#1-6-说明" class="headerlink" title="1.6 说明"></a>1.6 <strong>说明</strong></h3><p>例如样例一，有一个正四边形。假设最上面的一条边被标记为边 $1$，下图显示了当 $A = [3,1,4,6]$ 时特殊点如何位于每一边内及一种可行的方案<br><img data-src="https://espresso.codeforces.com/ec3216a369f3c7c1379a84eda39ed90754644904.png" alt="500"></p>
<h3 id="1-7-代码"><a href="#1-7-代码" class="headerlink" title="1.7 代码"></a>1.7 代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll n, a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll cnt = <span class="number">0</span>, maxa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i], cnt += a[i], maxa = <span class="built_in">max</span>(maxa, a[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(cnt / <span class="number">3</span>, cnt - maxa) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ll ans = sum/3;</span></span><br><span class="line"><span class="comment">    if (mx &gt; 2 * (sum - mx)) &#123;</span></span><br><span class="line"><span class="comment">        ans = sum - mx;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; ans &lt;&lt; endl;*/</span></span><br></pre></td></tr></table></figure>
<h2 id="2-字符串相约"><a href="#2-字符串相约" class="headerlink" title="2 字符串相约"></a>2 字符串相约</h2><h3 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h3><blockquote>
<p>在无尽的二进制海洋中，邂逅了你。就像在复杂的计算机代码里，我找到了那一行的灵魂诗。<br>在你的眼睛里，我看到星光，像是一个完美的算法, 在你的笑容下，我的心跳加速，我知道我已经陷入你的陷阱。<br>无论数据流如何冲刷，无论代码多么艰难，我都会矢志不渝，因为，我爱你。<br>你是我的私钥，我是你的公钥，在这信息海洋里，相互加密，无人能解。<br>当所有的数字疯狂旋转，当所有的指针失去方向，我将在你的离散空间里，等待，直到时间指向永恒。<br>这不仅仅是爱情的密语，它还保存了我们共同的记忆，无论虚拟空间如何寒冷，只要有你，我就能找到温暖。<br>在这个充满机器语言的世界，你我找到了属于我们的诗篇。虽然我们只是两个二进制字符串，但我们的爱情，已经超越了生命的边界。<br>两个二进制字符串开始了甜甜的爱情, 随着时光的飞逝，岁月的冲刷，他们长得也越来越像彼此 $\dots$ </p>
</blockquote>
<p>有两个长度相等的字符串 $a, b$ ,它们只包含字符 $0$ 或 $1$; 两个字符串都以字符 $0$ 开始，以字符 $1$ 结束。</p>
<p>您可以执行以下操作任意次数（可能为零）：</p>
<ul>
<li>选择其中一个字符串和两个相等的字符; 然后将它们之间的所有字符替换为这个字符。</li>
</ul>
<p>即: 选择这两个字符串之一(假设为 $s$)，然后选择两个整数 $l$ 和 $r$ ,满足 $1\leq l&lt;r&lt;\mid s\mid$ 且 $s<em>{l}=s</em>{r}$ .然后替换在区间 $[l, r)$ 的所有字符 $s<em>{i}$ ,使得 $s</em>{i}$ 都替换为 $s<em>{l}$ 。( $\sum \limits</em>{i=l}^{r-1}s<em>{i}=s</em>{l}$)</p>
<h3 id="2-2-输入"><a href="#2-2-输入" class="headerlink" title="2.2 输入"></a>2.2 输入</h3><blockquote>
<p>$\boxed{\begin{align}&amp;T\&amp;a<em>{1} &amp;b</em>{1}\&amp;a<em>{2} &amp;b</em>{2}\ &amp;\vdots&amp;\vdots\&amp;a<em>{T}&amp;b</em>{T}\end{align}}$</p>
<blockquote>
<p>$T$ 为测试用例数量，每个测试用例由 $a,b$ 两行组成<br>$a,b$ 都以字符 $0$ 开始，以字符 $1$ 结束</p>
</blockquote>
<p>数据范围</p>
<blockquote>
<p>$2\leq \mid a\mid=\mid b\mid\leq 5\ 000$ , $1\leq T\leq 2\ 000$<br>$\sum \limits<em>{i=1}^T\mid a</em>{i}\mid\leq 50\ 000$</p>
<h3 id="2-3-输出"><a href="#2-3-输出" class="headerlink" title="2.3 输出"></a>2.3 输出</h3><p>对于每个测试用例，如果可以使两个字符串相等，则打印 <code>YES</code>。否则，打印 <code>NO</code>。</p>
<h3 id="2-4-示例"><a href="#2-4-示例" class="headerlink" title="2.4 示例"></a>2.4 示例</h3><p>输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">01010001</span><br><span class="line">01110101</span><br><span class="line">01001</span><br><span class="line">01001</span><br><span class="line">000101</span><br><span class="line">010111</span><br><span class="line">00001</span><br><span class="line">01111</span><br><span class="line">011</span><br><span class="line">001</span><br><span class="line">001001</span><br><span class="line">011011</span><br><span class="line">010001</span><br><span class="line">011011</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-说明"><a href="#2-5-说明" class="headerlink" title="2.5 说明"></a>2.5 说明</h3><p>在第一个测试用例中，我们可以执行以下操作：</p>
<ul>
<li>选择字符串 $a, l=2, r=4;$ 此操作后， $a$ 为 $01110001$， $b$ 为 $01110101$;</li>
<li>选择字符串 $b, l=5, r=7;$ 此操作后， $a$ 为 $01110001$， $b$ 为 $01110001$。<br>在第二个测试用例中，字符串已经相等。<br>在第三个测试用例中，我们可以执行以下操作：</li>
<li>选择字符串 $a,l=4, r=6;$ 此操作后，$a$ 为 $000111$， b 为 $010111$;</li>
<li>选择字符串 $b, l=1, r=3;$ 此操作后， $a$ 为 $000111$， b 为 $000111$。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="2-6-代码"><a href="#2-6-代码" class="headerlink" title="2.6 代码"></a>2.6 代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> size = a.<span class="built_in">size</span>(), flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]&amp;&amp;a[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i+<span class="number">1</span>]==b[i+<span class="number">1</span>]&amp;&amp;a[i+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">	        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="3-1-题目描述-："><a href="#3-1-题目描述-：" class="headerlink" title="3.1 题目描述 ："></a>3.1 题目描述 ：</h3><p>WZ 学长最近迷恋上了泡养生茶，他买了枸杞，决明子，菊花，栀子，桑葚，桑叶，蒲公英，金银花，茯苓，人参… 某天他突发奇想，是不是把两杯液体重量一样的养生茶倒到其中一个杯子里面再喝下去，就会获得双倍的效果还能少喝一杯茶！（智慧的眼神）<br>说干就干！假设 WZ 学长一共有 $n$ 杯养生茶，每个杯子无限大并且初始只有 $1$ 升养生茶。WZ 学长每次只会把两杯质量一样的茶倒进其中一个杯子（别问我为什么要一样多），而他每次最多只愿喝 $m$ 杯，那么他最少还需要再调配多少杯养生茶。<br>（放心如果要喝的养生茶超过 $1$ 升，那么 WZ 就会把多的都送给 Jiejie 学长并且看着他喝完！）</p>
<h3 id="3-2-输入"><a href="#3-2-输入" class="headerlink" title="3.2 输入"></a>3.2 输入</h3><p>$\boxed{\begin{align}&amp;n&amp;m\end{align}}$<br>$n$ 为 WZ 已有的养生茶杯数，$m$ 为他愿意最多喝的养生茶数量</p>
<h3 id="3-3-输出"><a href="#3-3-输出" class="headerlink" title="3.3 输出"></a>3.3 输出</h3><p>输出一行最少还需要再买多少杯</p>
<h3 id="3-4-样例"><a href="#3-4-样例" class="headerlink" title="3.4 样例"></a>3.4 样例</h3><p>输入<br>3 1<br>输出<br>1<br>题解：二进制问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(__builtin_popcount(n) &gt; m) ans += n &amp; -n, n += n &amp; -n;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="4-1-题目描述-："><a href="#4-1-题目描述-：" class="headerlink" title="4.1 题目描述 ："></a>4.1 题目描述 ：</h3><p>WZ 最近想要学卷积神经网络了！但是因为这是他第一次做这种项目，于是乎，，，一个拥有数不清 bug 的屎山就诞生了! 虽心有余想要全部删了重构，然而项目就快要结题了，只好央求我们英俊潇洒风流倜傥的 Jiejie 学长来挽救于危难之间。Jiejie 虽然看不懂问题到底出在了哪里，但他发现 WZ 的 bug 出现的很有规律，每个 bug 只会影响当前行的代码，为了 debug 的舒服他决定数行数行的进行修改。于是他决定帮 WZ 重构 $m$ 个片段（即从一个 bug 到另一个 bug 算一个片段），于是想问 Jiejie 学长最少需要重构多少行代码。</p>
<h3 id="4-2-输入"><a href="#4-2-输入" class="headerlink" title="4.2 输入"></a>4.2 输入</h3><p>$\boxed{\begin{align}&amp;x &amp;n&amp; &amp;m\&amp;a<em>{1} &amp;a</em>{2}&amp; &amp;\cdots &amp;&amp;a<em>{n}\end{align}}$<br>第一行输入代码总长度 $x$ 和 $n$ 个 bug 以及 Jiejie 愿意重构 $m$ 个片段数<br>第二行一共有 $n$ 个数字代表每个 bug 的位置<br>数据范围：<br>$1\leq a</em>{i}\leq x$<br>$1 \leq x,n,m\leq 1\  000$</p>
<h3 id="4-3-输出"><a href="#4-3-输出" class="headerlink" title="4.3 输出"></a>4.3 输出</h3><p>Jiejie 学长最少需要更改的行数</p>
<h3 id="4-4-样例"><a href="#4-4-样例" class="headerlink" title="4.4 样例"></a>4.4 样例</h3><p>输入<br>11 5 2<br>2 4 6 9 10</p>
<p>输出<br>5</p>
<p>题解：排序＋贪心<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10050</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,n,m;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> b[maxn];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		b[i<span class="number">-1</span>]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n-m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		ans+=b[i];</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><h3 id="5-1-题目描述-："><a href="#5-1-题目描述-：" class="headerlink" title="5.1 题目描述 ："></a>5.1 题目描述 ：</h3><blockquote>
<p>“鲁迅说的话关我周树人什么事，文则打游戏关我高某人什么事。“</p>
</blockquote>
<p>WZ 最近迷恋上了塔防益智小游戏，目标是尽可能多的净化敌方的区域，整个地图由“*”构成，敌方的地盘用“#”表示。每块敌方的地区 WZ 都需要派遣一位白骑士去净化，但是敌方为了保护自己的地盘建立了多个碉堡，每个碉堡用“!”表示。WZ 只能攻占一片敌方的区域，而这片区域每拥有一个碉堡 WZ 就需要多派一个白骑士去净化。问 WZ 想要尽可能多的净化敌方区域至少需要派遣多少个白骑士。</p>
<blockquote>
<p>一曲忠诚的赞歌~</p>
</blockquote>
<h3 id="5-2-输入格式"><a href="#5-2-输入格式" class="headerlink" title="5.2 输入格式"></a>5.2 输入格式</h3><p>$\boxed{\begin{align}&amp;n\ \ \ \ \ \ \ m\&amp;ch<em>{11}ch</em>{12}\dots ch<em>{1m}\&amp;ch</em>{21}ch<em>{22}\dots ch</em>{2m}\ &amp;\vdots\ &amp;ch<em>{n1}ch</em>{n2}\dots ch_{nm}\end{align}}$<br>第一行，输入两个整数 $n$ 和 $m$ 代表整张地图的大小<br>接下来 $n$ 行，每行将输入 $m$ 个字符代表当前位置情况<br>$1\leq n,m\leq 500$</p>
<h3 id="5-3-输出格式"><a href="#5-3-输出格式" class="headerlink" title="5.3 输出格式"></a>5.3 输出格式</h3><p>$\boxed{\begin{align}&amp;x&amp;y\end{align}}$<br>$x$ 代表 WZ 可以占领的敌方区域大小，$y$ 代表 WZ 至少需要派遣多少个白骑士</p>
<h3 id="5-4-样例"><a href="#5-4-样例" class="headerlink" title="5.4 样例"></a>5.4 样例</h3><p>输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">#!**</span><br><span class="line">!#**</span><br><span class="line">*#*#</span><br><span class="line">*#*!</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 8</span><br></pre></td></tr></table></figure></p>
<p>题解：宽搜/深搜<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1060</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> c[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ti[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> tj[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">bool</span> v[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="comment">//搜索</span></span><br><span class="line">	<span class="type">int</span> nans1=<span class="number">1</span>,nans2=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(c[a][b]==<span class="string">&#x27;!&#x27;</span>)nans2++;</span><br><span class="line">	v[a][b]=<span class="literal">false</span>;</span><br><span class="line">	queue&lt;node&gt; Q;</span><br><span class="line">	node X;</span><br><span class="line">	X.x=a,X.y=b;</span><br><span class="line">	Q.<span class="built_in">push</span>(X);</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node fi=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> x=fi.x,y=fi.y;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">			<span class="keyword">if</span>(v[x+ti[i]][y+tj[i]])&#123;</span><br><span class="line">				nans1++;nans2++;</span><br><span class="line">				<span class="keyword">if</span>(c[x+ti[i]][y+tj[i]]==<span class="string">&#x27;!&#x27;</span>)nans2++;</span><br><span class="line">				node N;</span><br><span class="line">				N.x=x+ti[i],N.y=y+tj[i];</span><br><span class="line">				Q.<span class="built_in">push</span>(N);</span><br><span class="line">				v[x+ti[i]][y+tj[i]]=<span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(nans1&gt;ans1)&#123;</span><br><span class="line">		ans1=nans1;</span><br><span class="line">		ans2=nans2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v,<span class="literal">false</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			cin&gt;&gt;c[i][j];</span><br><span class="line">			<span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;*&#x27;</span>)v[i][j]=<span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> v[i][j]=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="keyword">if</span>(v[i][j])<span class="built_in">find</span>(i,j);</span><br><span class="line">	cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>W1054 永无止境的反转</title>
    <url>/posts/c496f16f/</url>
    <content><![CDATA[<h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1 Description"></a>1 Description</h2><p>给定一条长度为 $n$ 的数轴，初始 $n$ 个整点全为白色。接下来将执行若干次<strong>反转</strong>操作：将某个区间内的所有白色整点变为黑色，所有黑色整点变为白色。</p>
<p>举例来说，若数轴为 $WBWWBBBB$，将其中红色部分反转后变为 $WWBBWBBB$。其中 $W$ 和 $B$ 分别表示白色和黑色。</p>
<p>你的任务是在每次操作后，求出当前还有多少白色块。注意，每次操作将会<strong>永久地</strong>改变数轴。</p>
<h2 id="2-Input"><a href="#2-Input" class="headerlink" title="2 Input"></a>2 Input</h2><script type="math/tex; mode=display">\boxed{ 
\begin{align}
&n & m \\&l_1& r_1 \\&l_2& r_2\\ &\vdots  \\&l_m& r_m​
\end{align}
}</script><p>其中 $n$ 表示数轴的长度，而 $m$ 表示操作数。</p>
<p>接下来 $m$ 行，每行两个数表示当前反转了 $[l,r]$ 区间内的元素。</p>
<h3 id="2-1-数据范围"><a href="#2-1-数据范围" class="headerlink" title="2.1 数据范围"></a>2.1 数据范围</h3><ul>
<li>$n,m,l_i​,r_i​$ 为整数。</li>
<li>$1≤l_i​≤r_i​≤n≤10^{18}$。</li>
<li>$1≤m≤2×10^3$。</li>
</ul>
<h2 id="3-Output"><a href="#3-Output" class="headerlink" title="3 Output"></a>3 Output</h2><script type="math/tex; mode=display">
\boxed{ 
\begin{align}
&w_{1} \\ &w_{2} \\ &\vdots \\ &w_{m}​
\end{align}
}</script><ul>
<li>表示每次操作后，当前数轴上有多少白点。<h2 id="4-示例"><a href="#4-示例" class="headerlink" title="4 示例"></a>4 示例</h2>Sample Input 1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Sample Output 1<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-Hint"><a href="#5-Hint" class="headerlink" title="5 Hint"></a>5 Hint</h2><p>操作序列：</p>
<ul>
<li>$\Huge{1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 0}$</li>
<li>$WWWWWWWWWW→BBBBBBBWWW→3$</li>
<li>$BBBBBBBWWW→BBWWWWWBBW→6$</li>
<li>$BBWWWWWBBW→BBWWBBBWWB→4$</li>
</ul>
]]></content>
      <categories>
        <category>swpuoj</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>补题</tag>
      </tags>
  </entry>
  <entry>
    <title>复习提纲</title>
    <url>/posts/c9775b26/</url>
    <content><![CDATA[<h1 id="第-1-章"><a href="#第-1-章" class="headerlink" title="第 1 章"></a>第 1 章</h1><ol>
<li><p>数据管理的发展阶段</p>
<ul>
<li>人工</li>
<li>文件系统</li>
<li>数据库系统</li>
<li>NoSQL 非结构化数据库 <ul>
<li>四大分类</li>
<li>常见的 NoSQL 数据库</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库相关概念 </p>
<ul>
<li>数据库</li>
<li>数据库系统</li>
<li>数据库管理系统<br>数据定义语言（DDL）定义数据库中的数据对象<br>数据查询语言 (DQL)<br>数据操纵语言（DML）实现对数据库的基本操作 (查询、插入、删除和修改）<br>数据库控制语言（DCL）</li>
</ul>
</li>
</ol>
<h1 id="第-2-章"><a href="#第-2-章" class="headerlink" title="第 2 章"></a>第 2 章</h1><ol>
<li>数据模型（数据模型通常由数据结构、数据操作和 完整性约束三个部分组成）<ul>
<li>概念模型</li>
<li>逻辑模型</li>
<li>物理模型</li>
</ul>
</li>
<li>==概念模型——ER 图==</li>
<li>逻辑模型——关系模型</li>
<li>==三层模式体系结构和数据独立性==<br>三级模式：(逻辑)模式，外模式，内模式。<br>数据独立性</li>
</ol>
<ul>
<li>数据与程序间的互不依赖性, 即数据库中数据独立于应用程序而不依赖于应用程序。也就是说, 数据的逻辑结构、存储结构与存取方式的改变不会影响应用程序</li>
</ul>
<p>两级映像：</p>
<ol>
<li>外模式／概念模式映象(保证数据的逻辑独立性)</li>
</ol>
<ul>
<li>模式：描述的是数据的全局逻辑结构</li>
<li>外模式：描述的是数据的局部逻辑结构 </li>
<li>每一个外模式，数据库系统都有一个外模式／模式映象 </li>
<li>外模式／模式映象定义了该外模式与概念模式之间的对应关系。</li>
<li>映象定义通常包含在各自外模式的描述中</li>
</ul>
<ol>
<li>概念模式／内模式映象(保证数据的物理独立性)</li>
</ol>
<ul>
<li>定义了数据全局逻辑结构与存储结构之间的对应关系。如，说明逻辑记录和字段在内部是如何表示的</li>
<li>数据库中模式／内模式映象是唯一的</li>
<li>该映象定义通常包含在模式描述中<h1 id="第-3-章"><a href="#第-3-章" class="headerlink" title="第 3 章"></a>第 3 章</h1></li>
</ul>
<ol>
<li>关系模型概念<ul>
<li>域、属性、元组和关系 </li>
<li>主码（主关键字）</li>
<li>外码（外关键字）</li>
</ul>
</li>
<li>关系的完整性约束<ul>
<li>实体完整性：关系模型以主码作为唯一性标识，主码中的属性即主属性不能取空值</li>
<li>参照完整性：外码</li>
<li>用户定义完整性：反映某一具体应用所涉及的数据必须满足的语义要求</li>
<li>域完整性</li>
</ul>
</li>
<li>关系代数<ul>
<li>并交差（ $R∪S$ 、 $R∩S$ 、 $R-S$ ）</li>
<li>笛卡尔积、自然连接（ $R×S$ 、 $R*S$ ）</li>
<li>选择、投影（ $\sigma(R)$ 、 $πA(R)$ ）</li>
<li>除 $(R÷S)$</li>
</ul>
</li>
</ol>
<h1 id="第-4-章"><a href="#第-4-章" class="headerlink" title="第 4 章"></a>第 4 章</h1><ol>
<li>==SQL 语言的功能组成==: 数据定义(DDL)、数据查询(DQL)、数据操纵(DML)、数据控制 (DCL)</li>
<li>==SQL 语言的特点==：</li>
</ol>
<ul>
<li>一体化</li>
<li>高度非过程化</li>
<li>面向集合的操作方式</li>
<li>提供多种方式使用</li>
<li>语言简洁</li>
</ul>
<ol>
<li>SQL 中的表和关系模型中关系的区别：==表是关系模型中关系的具体实现==，在 SQL 中，一个表可以对应一个实体，多个表之间的关联关系可以用 SQL 语句和外键来描述。</li>
<li>单表查询<ul>
<li>不带元组筛选条件的单表查询</li>
<li>重命名查询结果关系列名</li>
<li>筛选元组</li>
<li>三值逻辑与空值检查</li>
<li>查询结果排序</li>
<li>返回“计算列”</li>
<li>IN、BETWEEN、DISTINCT、LIKE 的用法</li>
<li>五个汇总函数的用法<ul>
<li>COUNT ( ) </li>
<li>SUM ( ) </li>
<li>MAX ( )</li>
<li>MIN ( )</li>
<li>AVG ( )</li>
</ul>
</li>
<li>分组及对分组的筛选</li>
</ul>
</li>
<li>多表连接查询<ul>
<li>内联接：<code>table1 [inner] join table2 on 条件</code></li>
<li>外联接 ：<code>table1 left [outer] join table2 on 条件</code></li>
<li>自联接</li>
</ul>
</li>
<li>子查询<ul>
<li>带有 IN 谓词的子查询</li>
<li>带有比较运算符的子查询</li>
<li>带有 ANY 或 ALL 谓词的子查询</li>
<li>带有 EXISTS 谓词的子查询</li>
<li>不相关子查询与相关子查询的区别</li>
</ul>
</li>
<li>数据的增、删、改<ul>
<li>DDL 数据定义语言</li>
<li>创建数据库 (简易版)：重命名数据库： <code>sp_renamedb &#39;old_name&#39;, &#39;new_name&#39;</code> 和 <code>ALTER DATABASE mydb RENAME TO newdb;</code><ul>
<li>删除数据库：<code>DROP DATABASE database_name;</code></li>
<li>创建数据库表：指定数据类型、是否允许为空、标识列</li>
<li>修改数据库表：增加列、修改列、删除列</li>
<li>删除数据库表</li>
</ul>
</li>
<li>完整性约束条件</li>
<li>默认值约束: <code>DEFAULT(constant_expression | NULL)</code></li>
<li>对数据格式的约束: <code>IN LIKE BETWEEN</code></li>
<li>对取值范围或取值集合的约束: <code>check(约束)</code></li>
<li>主键约束：<code>[constraint pk_name] primary key</code>   OR    <code>primary key(c1,c2...)</code></li>
<li>外键约束: <code>foreign key(c1) references table(c1)</code><br>（级联删除——on delete cascade、级联更新——on update cascade)</li>
<li>唯一约束: <code>unique</code> 且允许为空</li>
<li>删除约束<br>修改数据库表(ALTER TABLE)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> name <span class="keyword">ADD</span> email <span class="type">VARCHAR</span> (<span class="number">100</span>); <span class="comment">--会在名为 `name` 的表中添加一个名为 `email` 的新列，其数据类型为 `VARCHAR (100)`。</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> name <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> salary <span class="type">DECIMAL</span> (<span class="number">12</span>, <span class="number">2</span>); <span class="comment">--这将修改 `name` 表中 `salary` 列的数据类型为 `DECIMAL (12, 2)`。</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> name <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> phone_number; <span class="comment">--这会从 name 表中删除 phone_number 列。</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> name <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_customer_id <span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers (customer_id); <span class="comment">--这会在 `name` 表中添加一个外键约束，确保 `customer_id` 列的值必须是 `customers` 表中的 `customer_id`。</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> name <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> chk_salary; <span class="comment">--这会从 `name` 表中删除名为 `chk_salary` 的检查约束。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>… 具体在知识点总结里面有很多例子[[《数据库原理及应用》知识点整理 + 习题_数据库原理及应用重点总结 - CSDN 博客]]</li>
</ul>
<ol>
<li>视图的概念<ul>
<li>视图的优点</li>
<li>视图的创建</li>
<li>视图的修改</li>
<li>删除视图</li>
<li>查询视图的步骤</li>
<li>视图的更新</li>
<li>==视图可更新性的基本判断原则==<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">5</span><span class="operator">*</span> <span class="keyword">from</span> sc <span class="comment">--前五条记录</span></span><br><span class="line"><span class="keyword">select</span> top <span class="number">20</span> <span class="keyword">percent</span> <span class="operator">*</span> <span class="keyword">from</span> sc <span class="comment">-- 前20%的记录</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>判断取值为空的语句格式为：列名 <code>IS NULL</code></li>
<li>判断取值不为空的语句格式为：列名 <code>IS NOT NULL</code></li>
</ul>
<hr>
<p><code>order by</code> 默认升序，<code>desc</code> 降序<br>Example：查询全体学生的信息，查询结果按所在系的系名升序排列，同一系的学生按年龄降序排列<br><code>SELECT * FROM Student ORDER BY Sdept, Sage DESC</code></p>
<p>对于 <code>group by</code> 后面的那个属性，前面必须有相应属性。使用 Group By 就必须使用集合函数<br>只有 <code>count(*)</code> 能计算上空值，其他函数忽略空值</p>
<hr>
<p>例如</p>
<ol>
<li>查询年龄最大的学生姓名<br>错误写法：<code>SELECT Sname FROM Student WHERE Sage = MAX (Sage)</code> ╳ (<code>where</code> 后面不能加函数)<br>正确写法;   <code>SELECT Sname FROM Student WHERE Sage = (SELECT MAX (SAGE) FROM STUDENT);</code></li>
<li>查询选修了“数据库基础”课程的学生的学号、姓名<br>子查询：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line"> ( <span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno <span class="keyword">IN</span></span><br><span class="line"> (<span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> Course <span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数据库基础&#x27;</span>) )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="第-5-章"><a href="#第-5-章" class="headerlink" title="第 5 章"></a>第 5 章</h1><ol>
<li>函数依赖<ul>
<li>部分依赖</li>
<li>完全依赖</li>
<li>传递依赖</li>
</ul>
</li>
<li>范式<ul>
<li>第一范式: 所有属性都是不可分的数据项</li>
<li>第二范式: 如果 $R (U, F)∈1 NF$，并且 $R$ 中的每个非主属性都完全函数依赖于主码，则 $R (U, F)∈2 NF$<ul>
<li>确定候选键：找出能够唯一标识每条记录的属性集合。在实际情况中可能需要参考业务规则及数据语义。</li>
<li>检查部分依赖：对每个非主属性，检查它是否完全依赖于候选键。也就是说，一个候选键的一部分能否独立决定某个非主属性的值，如果可以，说明存在部分依赖，那么它就不符合第二范式。</li>
</ul>
</li>
<li>第三范式:如果 $R (U, F )∈2 NF$，并且所有非主属性都不传递依赖于主码，则 $R (U, F )∈3 NF$</li>
<li>BC 范式：如果关系模式满足第三范式，并且不存在主属性对非所在码（不包含本主属性的码）的传递依赖和部分依赖，则称其满足BC 范式<br>“好”的模式</li>
</ul>
</li>
</ol>
<ul>
<li>不会发生插入异常、删除异常、更新异常</li>
<li>数据冗余应尽可能少。</li>
</ul>
<h1 id="第-6-章"><a href="#第-6-章" class="headerlink" title="第 6 章"></a>第 6 章</h1><ol>
<li>数据库设计的基本过程及每阶段的主要任务</li>
<li>==E-R 建模和绘制 E-R 图的方法==</li>
<li>“数据库逻辑结构设计阶段”的任务</li>
<li>将 E-R 模型转换为关系模型的规则和方法<br>各局部 E-R 图之间的冲突</li>
</ol>
<ul>
<li>属性冲突<ul>
<li>属性域冲突。即属性的类型、取值范围和取值集合不同</li>
<li>属性取值单位冲突</li>
</ul>
</li>
<li>命名冲突<ul>
<li>同名异义</li>
<li>异名同义</li>
</ul>
</li>
<li>结构冲突<ul>
<li>同一对象在不同应用中具有不同的抽象</li>
<li>同一实体在不同的 E-R 模型中，其属性的个数和排列次序不完全相同</li>
<li>实体间联系在不同局部 E-R 图中类型不同<h1 id="第-7-章"><a href="#第-7-章" class="headerlink" title="第 7 章"></a>第 7 章</h1></li>
</ul>
</li>
</ul>
<ol>
<li>事务<ul>
<li>定义：事务是用户定义的一个数据操作序列，这些操作要么全部执行、要么全部不执行，是一个不可分割的工作单元</li>
<li>ACID 特性：原子性，一致性，隔离性，持久性。</li>
</ul>
</li>
<li>并发控制<ul>
<li>==并发调度的可串行性==：多个事务的并发执行是正确的，当且仅当其结果与按某一顺序的串行执行的结果相同，则我们称这种调度为可串行化的调度</li>
<li>并发操作引起的问题：丢失数据修改，读脏数据，不可重复读。</li>
<li>并发控制——锁<ul>
<li>共享锁 (S 锁)</li>
<li>排他锁 (X 锁)</li>
<li>==封锁协议== (一，二，三级协议)</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>一级协议：对事务 T 要修改的数据加 X 锁，直到事务结束（包括正常结束和非正常结束）时才释放</p>
<ul>
<li>不能保证可重复读</li>
<li>不能保证不读“脏数据<br>二级协议：一级封锁协议加上对事务 T 对要读取的数据加 S 锁，读完后即释放 S 锁</li>
<li>不能防止可重复读<br>三级协议：一级封锁协议加上事务 T 对要读取的数据加 S 锁，并直到事务结束才释放</li>
<li>无缺点<br>==死锁==：两个事务相互等待对方先释放资源<br>多采用诊断并解除死锁的方法<br>两段锁协议：</li>
<li>在对数据进行读、写操作前，首先获得对该数据的封锁。</li>
<li>在释放一个封锁之后，事务不再申请和获得其他任何封锁<br>==所有遵守两段锁协议的事务，其并行执行的结果一定是正确的==</li>
</ul>
<p><mark style="background: #FF5582A6;">TODO: 7,10,11 chapter 复习完之后，再去看看期末模拟卷子，然后就复习计算机网络</mark></p>
<h1 id="第-10-章"><a href="#第-10-章" class="headerlink" title="第 10 章"></a>第 10 章</h1><ol>
<li>SQL SERVER 的安全控制过程、安全控制模型</li>
<li>SQL SERVER 的身份验证模式</li>
<li>SQL SERVER 登录名的管理</li>
<li>SQL SERVER 数据库用户的管理</li>
<li>SQL SERVER 权限的管理</li>
<li>SQL SERVER 角色的管理<br>创建数据库<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line"> [ON</span><br><span class="line"> [ &lt;文件格式&gt; [ , … n ] ]</span><br><span class="line"> ]</span><br><span class="line"> [ LOG ON &#123; &lt;文件格式&gt; [ , … n ] &#125; ]</span><br><span class="line"> &lt;文件格式&gt; ::= </span><br><span class="line"> ( [ NAME = 逻辑文件名, ]</span><br><span class="line"> FILENAME = ‘操作系统下的物理路径和文件名’</span><br><span class="line"> [, SIZE = 文件初始大小 ]</span><br><span class="line"> [, MAXSIZE = 文件最大大小 | UNLIMITED ]</span><br><span class="line"> [, FILEGROWTH = 增量值 ] ) [ , … n]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> login user1 <span class="keyword">with</span> password<span class="operator">=</span><span class="string">&#x27;1234&#x27;</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> us1 <span class="keyword">for</span> login user1</span><br></pre></td></tr></table></figure>
<p>权限问题：<br><code>grant select on student to user1</code><br><code>REVOKE SELECT ON Student FROM user1</code><br><code>DENY UPDATE ON student TO user1</code></p>
<h1 id="第-11-章"><a href="#第-11-章" class="headerlink" title="第 11 章"></a>第 11 章</h1><ol>
<li>备份类型：完整备份，差异备份，事务日志备份。</li>
<li>备份策略：完整备份+差异备份+日志备份<br>恢复数据库的顺序：<br>1）恢复最近的完全数据库备份<br>2）恢复完全备份后的最近的差异数据库备份<br>3）按日志备份的先后顺序恢复自完全备份或差异备份之后的所有日志备份<h1 id="第-12-章"><a href="#第-12-章" class="headerlink" title="第 12 章"></a>第 12 章</h1></li>
<li>变量</li>
<li>流程控制语句</li>
<li>存储过程<ul>
<li>定义</li>
<li>优点</li>
<li>创建</li>
<li>执行</li>
</ul>
</li>
<li>触发器<ul>
<li>创建</li>
</ul>
</li>
</ol>
<p>常用的全局变量：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>全局变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>@@ERROR</td>
<td>最后一个 T-SQL 错误的错误号误号</td>
</tr>
<tr>
<td>@@IDENTITY</td>
<td>最后一次插入的标记值</td>
</tr>
<tr>
<td>@@LANGUAGE</td>
<td>当前使用的语言的名称</td>
</tr>
<tr>
<td>@@MAX_CONNECTIONS</td>
<td>可以创建的同时连接的最大数目</td>
</tr>
<tr>
<td>@@ROWCOUNT</td>
<td>受上一个 SQL 语句影响的行数行数</td>
</tr>
<tr>
<td>@@SERVERNAME</td>
<td>本地服务器的名称</td>
</tr>
<tr>
<td>@@TRANSCOUT</td>
<td>当前连接打开的事务数</td>
</tr>
<tr>
<td>@@VERSION</td>
<td>SQL Server 的版本信息本</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>例如判断张长弓是否是计算机学院的学生<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @院系 <span class="type">CHAR</span> (<span class="number">20</span>)</span><br><span class="line"><span class="keyword">SELECT</span> @院系<span class="operator">=</span>Sdept <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sname<span class="operator">=</span>‘张长弓<span class="string">&#x27;</span></span><br><span class="line"><span class="string">IF @院系=‘计算机学院’</span></span><br><span class="line"><span class="string">PRINT ‘张长弓是计算机学院的学生’</span></span><br><span class="line"><span class="string">ELSE</span></span><br><span class="line"><span class="string">PRINT ‘张长弓不是计算机学院的学生’</span></span><br></pre></td></tr></table></figure></p>
<p>==创建存储过程==<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--创建</span><br><span class="line">CREATE PROCEDURE porc_name</span><br><span class="line">AS</span><br><span class="line">BEGIN</span><br><span class="line">	statement_1</span><br><span class="line">	[statement_2...]</span><br><span class="line">END</span><br><span class="line">--执行</span><br><span class="line">EXECUTE porc_name</span><br></pre></td></tr></table></figure><br>==输出参数的过程==<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create Procedure prcAVG @课程名 char(30).</span><br><span class="line">@平均成绩 FLOAT OUTPUT</span><br><span class="line">As</span><br><span class="line">BEGIN</span><br><span class="line">	Select @平均成绩 =AVG(Grade)From SC where Tno=</span><br><span class="line">	(Select Cno From Course where Cname= @课程名)</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">DECLARE @avgGrade float</span><br><span class="line">EXECUTE prcAVG &#x27;数据库基础&#x27;,@avgGrade OUTPUT</span><br></pre></td></tr></table></figure></p>
<p>==触发器的创建==<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name ON &#123; OBJECT NAME &#125;</span><br><span class="line">&#123; FOR | AFTER | INSTEAD OF &#125; &#123; event_type [,...n ] | DDL_DATABASE_LEVEL_EVENTS &#125;</span><br><span class="line">&#123; AS&#123; sql_statement [ ...n ] &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>==例子==：修改 Course 表时，自动将 ModifiedDate 设为当前时间<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create trigger trgTime on Course</span><br><span class="line">after update </span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">	update Course</span><br><span class="line">		set ModifiedDate=getdate() from inserted</span><br><span class="line">			where Course.cno=inserted.cno</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>改变触发器<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name</span><br><span class="line">&#123; FOR | AFTER&#125; &#123; event_type [ ,... n ]|</span><br><span class="line">DDL_DATABASE_LEVEL_EVENTS&#125;</span><br><span class="line">&#123;AS</span><br><span class="line">&#123; sal statement [ ... n ] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>删除触发器:<br><code>DROP TRIGGER &#123;trigger&#125;</code></p>
<p>需要加强的方面的是：</p>
<ul>
<li>概念</li>
<li>TSQL 语句</li>
<li>锁</li>
<li>函数依赖与范式</li>
<li>嵌套查询</li>
</ul>
<h1 id="TSQL-权限管理方面"><a href="#TSQL-权限管理方面" class="headerlink" title="TSQL 权限管理方面"></a>TSQL 权限管理方面</h1><h3 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h3><p><code>CREATE DATABASE</code> 语句用于创建新的数据库。它允许指定数据库的名称、文件位置、大小和增长设置。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE MyNewDatabase</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">PRIMARY</span></span><br><span class="line">( NAME <span class="operator">=</span> MyNewDatabase_Data,</span><br><span class="line">  FILENAME <span class="operator">=</span> <span class="string">&#x27;C:\SQLData\MyNewDatabase.mdf&#x27;</span>,</span><br><span class="line">  SIZE <span class="operator">=</span> <span class="number">10</span>MB,</span><br><span class="line">  MAXSIZE <span class="operator">=</span> UNLIMITED,</span><br><span class="line">  FILEGROWTH <span class="operator">=</span> <span class="number">10</span><span class="operator">%</span></span><br><span class="line">)</span><br><span class="line">LOG <span class="keyword">ON</span></span><br><span class="line">( NAME <span class="operator">=</span> MyNewDatabase_Log,</span><br><span class="line">  FILENAME <span class="operator">=</span> <span class="string">&#x27;C:\SQLLog\MyNewDatabase.ldf&#x27;</span>,</span><br><span class="line">  SIZE <span class="operator">=</span> <span class="number">5</span>MB,</span><br><span class="line">  MAXSIZE <span class="operator">=</span> <span class="number">100</span>MB,</span><br><span class="line">  FILEGROWTH <span class="operator">=</span> <span class="number">5</span>MB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了一个名为 <code>MyNewDatabase</code> 的数据库，主数据文件位于 <code>C:\SQLData\</code>，日志文件位于 <code>C:\SQLLog\</code>。</p>
<h3 id="用户和角色管理"><a href="#用户和角色管理" class="headerlink" title="用户和角色管理"></a>用户和角色管理</h3><ul>
<li><code>CREATE LOGIN</code> 用于创建新的登录账户。</li>
<li><code>CREATE USER</code> 用于在数据库中创建用户。</li>
<li><code>sp_addrolemember</code> 用于将用户添加到角色中。</li>
<li><code>sp_droprolemember</code> 用于从角色中删除用户。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建登录账户</span></span><br><span class="line"><span class="keyword">CREATE</span> LOGIN user1 <span class="keyword">WITH</span> PASSWORD <span class="operator">=</span> <span class="string">&#x27;password123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user1 <span class="keyword">FOR</span> LOGIN user1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将用户添加到角色</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_addrolemember <span class="string">&#x27;db_datareader&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从角色中删除用户</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_droprolemember <span class="string">&#x27;db_datareader&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul>
<li><code>GRANT</code> 用于授予权限。</li>
<li><code>REVOKE</code> 用于收回权限。</li>
<li><code>DENY</code> 用于拒绝权限。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> MyTable <span class="keyword">TO</span> user1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 收回权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> MyTable <span class="keyword">FROM</span> user1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拒绝权限</span></span><br><span class="line">DENY <span class="keyword">UPDATE</span> <span class="keyword">ON</span> MyTable <span class="keyword">TO</span> user1;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，用户 <code>user1</code> 被赋予了对 <code>MyTable</code> 表的查询权限，然后这个权限被收回，最后用户被拒绝对 <code>MyTable</code> 表进行更新操作。</p>
<h3 id="固定数据库角色"><a href="#固定数据库角色" class="headerlink" title="固定数据库角色"></a>固定数据库角色</h3><p>SQL Server 提供了一些预定义的数据库角色，这些角色有特定的权限。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予数据库角色权限</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_addrolemember <span class="string">&#x27;db_owner&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从数据库角色中删除用户</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_droprolemember <span class="string">&#x27;db_owner&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，用户 <code>user1</code> 被添加到 <code>db_owner</code> 角色中，然后从 <code>db_owner</code> 角色中删除。</p>
]]></content>
  </entry>
  <entry>
    <title>最后的总结</title>
    <url>/posts/0/</url>
    <content><![CDATA[<p>==对于给定的一个关系模式，判断是第几范式，并如何规范化到满足要求的范式==<br>考试题：</p>
<ol>
<li>设有关系模式 R （职工 ID，职工名，项目 ID，项目名，工资）职工 ID 和项目 ID 具有唯一性，职工 ID 可决定职工名，项目 ID 可决定项目名，每个职工可参加多个项目，各领一份工资。请分析 R 是否满足第三范式，并说明原因；如果不满足第三范式，请将其规范化到满足第三范式。<br>【参考答案】<br>(1)上面关系存在如下函数依赖：<br>职工 ID→职工名，项目 ID→项目名，（职工 ID，项目 ID）→工资所以关系的主码是（职工 ID，项目 ID），不存在非主属性对码的传递函数依赖，单存在非主属性对主码的部分函数依赖，因此不满足第二范式，也就不满足第三范式。<br>（2）将 R 通过分解为成如下三个关系模式：<br>R 1= (职工 ID，项目 ID, 工资)，主码（职工 ID，项目 ID）<br>R 2= (职工 ID，职工名)，主码职工 ID<br>R 3= (项目 ID，项目名)，主码项目 ID<br>以上三个关系模式不存在非主属性对码的部分或传递函数依赖，满足第三范式。</li>
</ol>
<p>==设计 ER 图==<br>考试题：<br>某水果外卖平台为了实现对其经营水果的管理，拟开发一个数据库系统，提出的要求如下：<br>①所有水果的单位均为公斤，水果种类很多，每种水果都有自己独有的编号，还有水果名和<br>基准售价；<br>②水果每次采购回来时都要有入库记录，记录入库的数量，入库时间和成本价，同一入库时<br>间可能入库多种水果，但一种水果每次入库的入库时间肯定不一样；<br>③客户可以通过网上下单订购水果，一个客户可以多次下单购买，但一个订单只能是一个客<br>户下单；<br>④需要记录客户的电话，姓名和地址，客户电话具有唯一性；<br>⑤还需要记录订单的订单编号，下单时间；<br>⑥一个订单中可以订购多种水果，需要记录订购每种水果的数量及单价，并需要知道订单总<br>价。<br>（1）请根据以上需求设计 E-R 图<br>（2）将上面 E-R 图转换为等价的关系模式（需要注明每个关系模式的主码，每个外码及其<br>所参照的主码）</p>
<p>==嵌套查询==</p>
<ol>
<li>查询 “数据库原理及应用”课程成绩优秀（大于等于 90）的学生学号、姓名，要求使用子查询实现，结果显示学生学号、姓名。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Sno, Sname FROM Student WHERE Sno IN </span><br><span class="line">(SELECT Sno FROM SC WHERE Grade&gt;=90 AND Cno=(SELECE Cno FROM Course WHERE Cname=&#x27;数据库原理及应用&#x27;))</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个名为 vwStu 的视图，包含每个学生的学号、姓名及其目前已选修课程的总学分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view vwStu (学号, 姓名, 总学分)</span><br><span class="line">as</span><br><span class="line">select Student.Sno,Sname,sum(Ccredit)</span><br><span class="line">From Student join SC on Student. Sno=SC. Sno</span><br><span class="line">join Course on Course.Cno=SC.Cno</span><br><span class="line">Group by Student.Sno,Sname</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个存储过程 prcFindByCno，接收课程号作为参数，通过输出参数返回该课程目前已选修人数。已知在表中课程号定义为 char (10)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create proc prcFindByCno @cno char (10),@total int output</span><br><span class="line">As</span><br><span class="line">Select @total=count (*) from SC where Cno=@cno</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据库系统的特-点"><a href="#数据库系统的特-点" class="headerlink" title="数据库系统的特 点:"></a>数据库系统的特 点:</h2><p>（1）数据结构化。<br>（2）数据共享性高、冗余少且易扩充。<br>（3）数据独立性高。<br>（4）数据由 DBMS 统一管理和控制。</p>
<h2 id="数据库的应用"><a href="#数据库的应用" class="headerlink" title="数据库的应用"></a>数据库的应用</h2><ul>
<li>管理信息系统</li>
<li>数据挖掘</li>
<li>决策支持系统</li>
<li>大数据<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2>如果不对并发操作进行正确调度，可能导致数据的不一致性问题，主要包括==丢失修改、不可重复读和读 “脏” 数据。==</li>
</ul>
<ol>
<li>丢失修改：两个事务读入同一数据并修改，其中一个事务的修改会丢失</li>
<li>不可读重复：事务 T 1 读取数据后，T 2 执行更新操作，使 T 1 无法再现前一次读取结果</li>
<li>读脏数据：“脏”数据指事务 T 1 修改某一数据，并将其写回磁盘，事务 T 2 读取同一数据后，T 1 由于某种原因被撤销，则 T 2 读取到的数据就为 “脏” 数据，即不正确的数据。</li>
</ol>
<p>==并发调度的可串行性==：多个事务的并发执行是正确的，==当且仅当==其结果与按某一顺序的串行执行的结果相同，则我们称这种调度为==可串行化==的调度</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><ol>
<li>一级协议：对事务 T 要修改的数据加 X 锁，直到事务结束（包括正常结束和非正常结束）时才释放<br>缺点：</li>
</ol>
<ul>
<li>不能保证可重复读</li>
<li>不能保证不读“脏数据</li>
</ul>
<ol>
<li>二级协议：一级封锁协议加上对事务 T 对要读取的数据加 S 锁，读完后即释放 S 锁<br>缺点：</li>
</ol>
<ul>
<li>不能防止可重复读</li>
</ul>
<ol>
<li>三级协议：一级封锁协议加上事务 T 对要读取的数据加 S 锁，并直到事务结束才释放</li>
</ol>
<ul>
<li>无缺点<br>![[../../../../images/Z-attachment/Pasted image 20240101214643.png]]<br>==死锁==：两个事务相互等待对方先释放资源<br>多采用诊断并解除死锁的方法 </li>
<li>超时法</li>
<li>等待图法<h3 id="两段锁协议-："><a href="#两段锁协议-：" class="headerlink" title="两段锁协议 ："></a>两段锁协议 ：</h3></li>
<li>在对数据进行读、写操作前，首先获得对该数据的封锁。</li>
<li>在释放一个封锁之后，事务不再申请和获得其他任何封锁<br>==所有遵守两段锁协议的事务，其并行执行的结果一定是正确的==</li>
</ul>
<h2 id="E-R-图合并冲突"><a href="#E-R-图合并冲突" class="headerlink" title="E-R 图合并冲突"></a>E-R 图合并冲突</h2><h3 id="一、属性冲突"><a href="#一、属性冲突" class="headerlink" title="一、属性冲突"></a>一、属性冲突</h3><p>①属性域冲突: 不同的子 E-R 图中，同一属性的数据类型、取值范围或者取值集合不同。<br>②属性单位冲突: 不同的子 E-R 图中，同一属性的单位不同，如一个是厘米，一个是米。</p>
<h3 id="二、命名冲突"><a href="#二、命名冲突" class="headerlink" title="二、命名冲突:"></a>二、命名冲突:</h3><p>①同名异义: 不同的子 E-R 图中具有相同的属性（对象）名，但是意义不一样。<br>②异名同义: 不同的子 E-R 图中，不同的属性（对象）名具有相同的意义。</p>
<h3 id="三、结构冲突"><a href="#三、结构冲突" class="headerlink" title="三、结构冲突:"></a>三、结构冲突:</h3><p>①同一对象在不同的子 E-R 图中具有不同的抽象，如其中一个是实体，一个是属性。解决方法是把实体变属性或者属性变成实体。<br>②同一实体在不同的子 E-R 图中具有不同的属性列，或者属性列顺序不同。解决方案是两个实体取并集。<br>③实体间的联系在不同的子 E-R 图中具有不同的类型，如 E 1，E 2 在这里是一对一关系，而在另外一个子 E-R 图中是一对多关。解决方法是根据语义进行综合调整。</p>
<p>==E-R 建模和绘制 E-R 图的方法==</p>
<h2 id="概念模型——ER-图"><a href="#概念模型——ER-图" class="headerlink" title="==概念模型——ER 图=="></a>==概念模型——ER 图==</h2><p>一个1:1的联系转换为一个关系，相连实体的关键字都是关系的候选关键字： 一个 1: n 的联系转换为一个关系，多方实体的关键字是关系的关键字；一个 n: m 的联系转换为一个关系，相连实体的关键字的组合组成关系的关键字 (复合关键字)。</p>
<h2 id="三层模式体系结构和数据独立性"><a href="#三层模式体系结构和数据独立性" class="headerlink" title="==三层模式体系结构和数据独立性=="></a>==三层模式体系结构和数据独立性==</h2><p>==三级模式==：(逻辑)模式，外模式，内模式。<br>数据独立性</p>
<ul>
<li>数据与程序间的互不依赖性, 即数据库中数据独立于应用程序而不依赖于应用程序。也就是说, 数据的逻辑结构、存储结构与存取方式的改变不会影响应用程序</li>
</ul>
<p>两级映像：</p>
<ol>
<li>外模式／概念模式映象 (保证数据的逻辑独立性)</li>
</ol>
<ul>
<li>模式：描述的是数据的全局逻辑结构</li>
<li>外模式：描述的是数据的局部逻辑结构 </li>
<li>每一个外模式，数据库系统都有一个外模式／模式映象 </li>
<li>外模式／模式映象定义了该外模式与概念模式之间的对应关系。</li>
<li>映象定义通常包含在各自外模式的描述中</li>
</ul>
<ol>
<li>概念模式／内模式映象 (保证数据的物理独立性)</li>
</ol>
<ul>
<li>定义了数据全局逻辑结构与存储结构之间的对应关系。如，说明逻辑记录和字段在内部是如何表示的</li>
<li>数据库中模式／内模式映象是唯一的</li>
<li>该映象定义通常包含在模式描述中</li>
</ul>
<h2 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h2><ul>
<li>实体完整性：关系模型以主码作为唯一性标识，主码中的属性即主属性不能取空值</li>
<li>参照完整性：外码</li>
<li>用户定义完整性：反映某一具体应用所涉及的数据必须满足的语义要求</li>
</ul>
<h2 id="SQL-语言的功能组成"><a href="#SQL-语言的功能组成" class="headerlink" title="==SQL 语言的功能组成==:"></a>==SQL 语言的功能组成==:</h2><p>数据定义 (DDL)、数据查询 (DQL)、数据操纵 (DML)、数据控制 (DCL)</p>
<p>==SQL 语言的特点==：</p>
<ul>
<li>一体化</li>
<li>高度非过程化</li>
<li>面向集合的操作方式</li>
<li>提供多种方式使用</li>
<li>语言简洁</li>
</ul>
<h2 id="SQL-中的表和关系模型中关系的区别："><a href="#SQL-中的表和关系模型中关系的区别：" class="headerlink" title="SQL 中的表和关系模型中关系的区别："></a>SQL 中的表和关系模型中关系的区别：</h2><p>==表是关系模型中关系的具体实现==，在 SQL 中，一个表可以对应一个实体，多个表之间的关联关系可以用 SQL 语句和外键来描述。</p>
<h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><ul>
<li>内联接：<code>table1 [inner] join table2 on 条件</code></li>
<li>外联接 ：<code>table1 left [outer] join table2 on 条件</code></li>
<li>自联接<br>子查询</li>
<li>带有 IN 谓词的子查询</li>
<li>带有比较运算符的子查询</li>
<li>带有 ANY 或 ALL 谓词的子查询</li>
<li>带有 EXISTS 谓词的子查询</li>
<li>不相关子查询与相关子查询的区别</li>
</ul>
<h2 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h2><ul>
<li>默认值约束: <code>DEFAULT(constant_expression | NULL)</code></li>
<li>对数据格式的约束: <code>IN LIKE BETWEEN</code></li>
<li>对取值范围或取值集合的约束: <code>check(约束)</code></li>
<li>主键约束：<code>[constraint pk_name] primary key</code>   OR    <code>primary key(c1,c2...)</code></li>
<li>外键约束: <code>foreign key(c1) references table(c1)</code><br>（级联删除——on delete cascade、级联更新——on update cascade)</li>
<li>唯一约束: <code>unique</code> 且允许为空</li>
</ul>
<p>==视图可更新性的基本判断原则==</p>
<ul>
<li><p>单表视图的更新性：如果视图仅仅由单个基本表构成，并且满足特定条件，那么这个视图通常是可更新的。</p>
</li>
<li><p>多表连接视图的更新性：如果视图是由多个表进行连接而成的，那么其具有可更新性的情况将会更加复杂。通常来说，仅当视图中的字段可以映射到基本表中的唯一字段时，视图才具有可更新性。</p>
</li>
<li><p>视图中必须包含主键：更新视图所依赖的基本表中，视图中包含的字段必须可以唯一标识基本表的特定行，也就是说这些字段必须是主键或存在唯一约束。</p>
</li>
</ul>
<h2 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h2><ul>
<li>简化复杂查询</li>
<li>数据安全性</li>
<li>简化数据操作</li>
<li>重用 SQL 查询</li>
<li>逻辑数据独立性</li>
</ul>
<h2 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h2><p>例如</p>
<ol>
<li>查询年龄最大的学生姓名<br>错误写法：<code>SELECT Sname FROM Student WHERE Sage = MAX (Sage)</code> ╳ (<code>where</code> 后面不能加函数)<br>正确写法;   <code>SELECT Sname FROM Student WHERE Sage = (SELECT MAX (SAGE) FROM STUDENT);</code></li>
<li>查询选修了“数据库基础”课程的学生的学号、姓名<br>子查询：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></span><br><span class="line"> ( <span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno <span class="keyword">IN</span></span><br><span class="line"> (<span class="keyword">SELECT</span> Cno <span class="keyword">FROM</span> Course <span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数据库基础&#x27;</span>) )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><ol>
<li>范式<ul>
<li>第一范式: 所有属性都是不可分的数据项</li>
<li>第二范式: 如果 $R (U, F)∈1 NF$，并且 $R$ 中的每个非主属性都完全函数依赖于主码，则 $R (U, F)∈2 NF$<ul>
<li>确定候选键：找出能够唯一标识每条记录的属性集合。在实际情况中可能需要参考业务规则及数据语义。</li>
<li>检查部分依赖：对每个非主属性，检查它是否完全依赖于候选键。也就是说，一个候选键的一部分能否独立决定某个非主属性的值，如果可以，说明存在部分依赖，那么它就不符合第二范式。</li>
</ul>
</li>
<li>第三范式: 如果 $R (U, F )∈2 NF$，并且所有非主属性都不传递依赖于主码，则 $R (U, F )∈3 NF$</li>
<li>BC 范式：如果关系模式满足第三范式，并且不存在主属性对非所在码（不包含本主属性的码）的传递依赖和部分依赖，则称其满足 BC 范式<br>“好”的模式</li>
</ul>
</li>
</ol>
<ul>
<li>不会发生插入异常、删除异常、更新异常</li>
<li>数据冗余应尽可能少。<br>==对于给定的一个关系模式，判断是第几范式，并如何规范化到满足要求的范式==</li>
</ul>
<h2 id="T-SQL"><a href="#T-SQL" class="headerlink" title="==T-SQL=="></a>==T-SQL==</h2><h3 id="TSQL-权限管理方面"><a href="#TSQL-权限管理方面" class="headerlink" title="TSQL 权限管理方面"></a>TSQL 权限管理方面</h3><p><code>CREATE DATABASE</code> 语句用于创建新的数据库。它允许指定数据库的名称、文件位置、大小和增长设置。</p>
<h4 id="用户和角色管理"><a href="#用户和角色管理" class="headerlink" title="用户和角色管理"></a>用户和角色管理</h4><ul>
<li><code>CREATE LOGIN</code> 用于创建新的登录账户。</li>
<li><code>CREATE USER</code> 用于在数据库中创建用户。</li>
<li><code>sp_addrolemember</code> 用于将用户添加到角色中。</li>
<li><code>sp_droprolemember</code> 用于从角色中删除用户。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建登录账户</span></span><br><span class="line"><span class="keyword">CREATE</span> LOGIN user1 <span class="keyword">WITH</span> PASSWORD <span class="operator">=</span> <span class="string">&#x27;password123&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user1 <span class="keyword">FOR</span> LOGIN user1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将用户添加到角色</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_addrolemember <span class="string">&#x27;db_datareader&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从角色中删除用户</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_droprolemember <span class="string">&#x27;db_datareader&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4></li>
<li><code>GRANT</code> 用于授予权限。</li>
<li><code>REVOKE</code> 用于收回权限。</li>
<li><code>DENY</code> 用于拒绝权限。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授予权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> MyTable <span class="keyword">TO</span> user1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 收回权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> MyTable <span class="keyword">FROM</span> user1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拒绝权限</span></span><br><span class="line">DENY <span class="keyword">UPDATE</span> <span class="keyword">ON</span> MyTable <span class="keyword">TO</span> user1;</span><br></pre></td></tr></table></figure>
<h2 id="T-SQL-1"><a href="#T-SQL-1" class="headerlink" title="T-SQL"></a>T-SQL</h2>| 全局变量名 | 含义 |<br>| —— | —— |<br>| @@ERROR | 最后一个 T-SQL 错误的错误号误号 |<br>| @@IDENTITY | 最后一次插入的标记值 |<br>| @@LANGUAGE | 当前使用的语言的名称 |<br>| @@MAX_CONNECTIONS | 可以创建的同时连接的最大数目 |<br>| @@ROWCOUNT | 受上一个 SQL 语句影响的行数行数 |<br>| @@SERVERNAME | 本地服务器的名称 |<br>| @@TRANSCOUT | 当前连接打开的事务数 |<br>| @@VERSION | SQL Server 的版本信息本 |</li>
</ul>
<p>判断张长弓是否是计算机学院的学生<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @院系 <span class="type">CHAR</span> (<span class="number">20</span>)</span><br><span class="line"><span class="keyword">SELECT</span> @院系<span class="operator">=</span>Sdept <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> sname<span class="operator">=</span>‘张长弓<span class="string">&#x27;</span></span><br><span class="line"><span class="string">IF @院系=‘计算机学院’</span></span><br><span class="line"><span class="string">PRINT ‘张长弓是计算机学院的学生’</span></span><br><span class="line"><span class="string">ELSE</span></span><br><span class="line"><span class="string">PRINT ‘张长弓不是计算机学院的学生’</span></span><br></pre></td></tr></table></figure><br>==创建存储过程==<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> porc_name</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	statement_1</span><br><span class="line">	[statement_2...]</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">--执行</span></span><br><span class="line"><span class="keyword">EXECUTE</span> porc_name</span><br></pre></td></tr></table></figure></p>
<h4 id="输出参数的过程"><a href="#输出参数的过程" class="headerlink" title="==输出参数的过程=="></a>==输出参数的过程==</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Procedure</span> prcAVG @课程名 <span class="type">char</span>(<span class="number">30</span>).</span><br><span class="line">@平均成绩 <span class="type">FLOAT</span> OUTPUT</span><br><span class="line"><span class="keyword">As</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">Select</span> @平均成绩 <span class="operator">=</span><span class="built_in">AVG</span>(Grade)<span class="keyword">From</span> SC <span class="keyword">where</span> Tno<span class="operator">=</span></span><br><span class="line">	(<span class="keyword">Select</span> Cno <span class="keyword">From</span> Course <span class="keyword">where</span> Cname<span class="operator">=</span> @课程名)</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@avgGrade</span> <span class="type">float</span></span><br><span class="line"><span class="keyword">EXECUTE</span> prcAVG <span class="string">&#x27;数据库基础&#x27;</span>,<span class="variable">@avgGrade</span> OUTPUT</span><br></pre></td></tr></table></figure>
<p>==触发器的创建==<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name ON &#123; OBJECT NAME &#125;</span><br><span class="line">&#123; FOR | AFTER | INSTEAD OF &#125; &#123; event_type [,...n ] | DDL_DATABASE_LEVEL_EVENTS &#125;</span><br><span class="line">&#123; AS&#123; sql_statement [ ...n ] &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>==例子==：修改 Course 表时，自动将 ModifiedDate 设为当前时间<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create trigger trgTime on Course</span><br><span class="line">after update </span><br><span class="line">as</span><br><span class="line">begin</span><br><span class="line">	update Course</span><br><span class="line">		set ModifiedDate=getdate() from inserted</span><br><span class="line">			where Course.cno=inserted.cno</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>改变触发器<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name</span><br><span class="line">&#123; FOR | AFTER&#125; &#123; event_type [ ,... n ]|</span><br><span class="line">DDL_DATABASE_LEVEL_EVENTS&#125;</span><br><span class="line">&#123;AS</span><br><span class="line">&#123; sal statement [ ... n ] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>删除触发器:<br><code>DROP TRIGGER &#123;trigger&#125;</code></p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>判断取值为空的语句格式为：列名 <code>IS NULL</code></li>
<li>判断取值不为空的语句格式为：列名 ==<code>IS NOT NULL</code>==</li>
<li><p><code>order by</code> 默认升序，<code>desc</code> 降序<br>  Example：查询全体学生的信息，查询结果按所在系的系名升序排列，同一系的学生按年龄降序排列<br>  <code>SELECT * FROM Student ORDER BY Sdept, Sage DESC</code></p>
</li>
<li><p>对于 <code>group by</code> 后面的那个属性，==前面必须有相应属性==。使用 Group By 就必须使用集合函数</p>
</li>
<li><p>只有 <code>count(*)</code> 能计算上空值，其他函数忽略空值</p>
<p>  解决并发操作带来的数据不一致问题普遍采用【封锁】技术。<br>  为了防止一个用户的工作不适当地影响另一个用户，应该采取【并发控制】<br>  下列不属于并发操作带来的问题是【死锁】<br>  DBMS 普遍采用【封锁】方法来保证调度的正确性<br>  事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放，这是【一级封锁协议】<br>  如果事务 T 获得了数据项 Q 上的排他锁，则 T 对 Q【既可读又可写】<br>  设事务 T 1 和 T 2，对数据库中地数据 A 进行操作，可能有如下几种情况，请问哪一种不会发生冲突操作【T 1 正在读 A，T 2 也要读 A】<br>  如果有两个事务，同时对数据库中同一数据进行操作，不会引起冲突的操作是【两个都是 SELECT】<br>  在数据库系统中，死锁属于【事务故障】</p>
<p>  FULL JOIN 不等价于 CROSS JOIN。<br>  CROSS JOIN 是对两个表进行笛卡尔积，返回所有可能的组合。<br>  FULL JOIN 是将两个表中的所有记录都组合起来，没有匹配的记录则用 NULL 填充。</p>
</li>
</ul>
<h2 id="NOSQL-数据库"><a href="#NOSQL-数据库" class="headerlink" title="NOSQL 数据库"></a>NOSQL 数据库</h2><ul>
<li>键值 (Key-Value)数据库 (Riak、Redis、Memcached、Amazon’s Dynamo、Project Voldemort)</li>
<li>面向文档 (Document-Oriented)数据库 (MongoDB、CouchDB、RavenDB)</li>
<li>列存储 (Wide Column Store/Column-Family)数据库 (Cassandra、HBase)</li>
<li>图 (Graph-Oriented)数据库 (Neo 4 J、Infinite Graph、OrientDB)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【最全】《数据库原理及应用》知识点整理 + 习题_数据库原理及应用重点总结 - CSDN 博客</title>
    <url>/posts/46820a67/</url>
    <content><![CDATA[<h2 id="第-1-章-绪论"><a href="#第-1-章-绪论" class="headerlink" title="第 1 章 绪论"></a>第 1 章 绪论</h2><h3 id="1-1-术语"><a href="#1-1-术语" class="headerlink" title="1.1 术语"></a>1.1 术语</h3><ol>
<li>数据（Data）</li>
</ol>
<p>数据是数据库中存储的基本对象。定义为描述事务的符号记录。数据的含义称为语义，数据与其语义是不可分的。</p>
<ol>
<li>数据库（DataBase，DB）</li>
</ol>
<p>长期存储在计算机内，有组织的，可共享的大量数据的集合。</p>
<p>数据库基本特征：1. 永久存储  2. 有组织  3. 可共享 4. 冗余度小 5. 易扩展</p>
<ol>
<li>数据库管理系统（DataBase Management System,DBMS）</li>
</ol>
<p>位于用户与操作系统之间的一层数据管理软件</p>
<p>数据库管理系统和操作系统一样是计算机的基础软件。</p>
<p>主要功能：提供数据定义语言（DDL）、数据操纵语言（DML）等</p>
<ol>
<li>数据库系统（DataBase System,DBS）</li>
</ol>
<p>数据库系统由数据库（DB），数据库管理系统 (DBMS)，应用程序和数据库管理员(DBA) 组成的存储、管理、处理和维护数据的系统。</p>
<h3 id="1-2-重要概念"><a href="#1-2-重要概念" class="headerlink" title="1.2 重要概念"></a>1.2 重要概念</h3><h4 id="数据库管理技术的发展过程（三个阶段）"><a href="#数据库管理技术的发展过程（三个阶段）" class="headerlink" title="数据库管理技术的发展过程（三个阶段）"></a>数据库管理技术的发展过程（三个阶段）</h4><p><strong>1. 人工管理阶段：</strong></p>
<p>在计算机出现之前，人们运用常规的手段从事记录、存储和对数据加工，也就是利用纸张来记录和利用计算工具（算盘、计算尺）来进行计算，并主要使用人的大脑来</p>
<p>管理和利用这些数据。</p>
<p>特点:</p>
<p>(1) 计算机系统不提供对用户数据的管理功能；</p>
<p>(2) 数据不能共享；</p>
<p>(3) 不保存数据。</p>
<p><strong>2. 文件系统阶段：</strong></p>
<p>在这一阶段（20 世纪 50 年代后期至 60 年代中期）计算机不仅用于科学计算，还利用在信息管理方面。随着数据量的增加，数据的存储、检索和维护问题成为紧迫的需要，数据结构和数据管理技术迅速发展起来。此时，外部存储器已有磁盘、磁鼓等直接存取的存储设备。软件领域出现了操作系统和高级软件。操作系统中的文件系统是专门管理外存的数据管理软件，文件是操作系统管理的重要资源之一。</p>
<p>特点:</p>
<p>数据以 “文件” 形式可长期保存在外部存储器的磁盘上。由于计算机的应用转向信息管理，因此对文件要进行大量的查询、修改和插入等操作，这些操作由文件系统提供。   </p>
<p>缺点:</p>
<p>数据冗余; 不一致性; 数据独立性差。</p>
<p><strong>3. 数据库系统阶段：</strong></p>
<p>20 世纪 60 年代后期以来 ，计算机性能得到进一步提高，更重要的是出现了大容量磁盘，存储容量大大增加且价格下降。在此基础上，才有可能克服文件 系统管理数据时的不足，而满足和解决实际应用中多个用户、多个 应用程序共享数据的要求，从而使数据能为尽可能多的 应用程序服务，这就出现了数据库这样的数据管理技术。</p>
<p>特点:</p>
<p>（1）数据结构化。</p>
<p>（2）数据共享性高、冗余少且易扩充。</p>
<p>（3）数据独立性高。</p>
<p>（4）数据由 DBMS 统一管理和控制。</p>
<h4 id="数据模型（Data-Model）"><a href="#数据模型（Data-Model）" class="headerlink" title="数据模型（Data Model）"></a>数据模型（Data <a href="https://so.csdn.net/so/search?q=Model&amp;spm=1001.2101.3001.7020">Model</a>）</h4><p>一、数据模型的分类</p>
<ol>
<li>概念模型</li>
</ol>
<p>按用户的观点来对数据和信息建模，主要用于数据库设计</p>
<p>概念模型的表示方法很多，最常用的为实体 - 联系方法 (Entity-Relationship approach），该方法用 E-R 图来描述概念模型。E-R 方法也成为 E-R 模型</p>
<ol>
<li>逻辑模型和物理模型</li>
</ol>
<p>逻辑模型主要包括层次模型、网状模型、<a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B&amp;spm=1001.2101.3001.7020">关系模型</a>、面向对象模型和对象关系数据模型等，主要用于数据库管理系统的实现。</p>
<p>物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192441167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt="500"></p>
<p>二、数据模型的组成要素</p>
<p>数据模型通常由数据结构、数据操作和完整性约束三个部分组成。</p>
<p><strong>数据结构</strong>描述数据库的组成对象以及对象之间的联系，通常按其数据结构的类型来命名数据模型，例如层次结构、网状结构和关系结构的数据模型分别命名为层次模型、网状模型、关系模型。</p>
<p><strong>数据操作</strong>是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及其有关的规则，主要分为查询和更新（插入、删除、修改）两大类操作。</p>
<p><strong>完整性约束条件</strong>是给定的数据模型中数据及其联系所具有的制约和依存规则，在关系模型中体现为实体完整性和参照完整性。例如，某大学的数据库中规定学生成绩如果有 6 门以上不及格则不能授予学士学位，教授的退休年龄是 65 周岁等。</p>
<h4 id="逻辑模型的分类（非关系模型与关系模型）"><a href="#逻辑模型的分类（非关系模型与关系模型）" class="headerlink" title="逻辑模型的分类（非关系模型与关系模型）"></a>逻辑模型的分类（非关系模型与关系模型）</h4><p>非关系模型：层次模型 (Hierarchical Model)、网状模型 (Network Model)</p>
<p>关系模型 (Relational Model) </p>
<p>层次模型，满足下面两个条件的基本层次联系的集合为层次模型（就是树结构）：</p>
<p>①有且只有一个结点没有双亲结点，这个结点称为根结点</p>
<p>②根以外的其它结点有且只有一个双亲结点</p>
<p>网状模型，满足下面两个条件的基本层次联系的集合（一对多关系，结构上像有向图）：</p>
<p>①允许一个以上的结点无双亲；</p>
<p>②一个结点可以有多于一个的双亲。</p>
<p>关系模型术语：</p>
<ol>
<li><p>关系：一个关系对应通常说的一张表。</p>
</li>
<li><p>属性：表中的一列即为一个属性。</p>
</li>
<li><p>域：属性的取值范围。</p>
</li>
<li><p>元组：表中的一行即为一个元组。</p>
</li>
<li><p>码：也称码键。表中的某个属性组，它可以唯一确定一个元组。</p>
</li>
<li><p>分量：元组中的一个属性值。</p>
</li>
<li><p>关系模式：对关系的描述，一般表示为 关系名（属性 1，属性 2，…..，属性 n）</p>
</li>
</ol>
<h4 id="画-E-R-图"><a href="#画-E-R-图" class="headerlink" title="画 E-R 图"></a>画 E-R 图</h4><p>实体 - 联系方法（Entity-Relationship Approach）是概念模型的一种表示方法，其提供了表示实体型、属性和联系的方法。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192500338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>实体型：用矩形表示，矩形框内写明实体名</p>
<p>属性：用椭圆表示，并用无向边将其与相应的实体型连接起来</p>
<p>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时标明联系的类型（1:1， 1：n， m：n）</p>
<p>比如有两个简单实体，分别是单位和职员，它们的关系就是 1:m，一个单位可以有多个职员；</p>
<p>再比如有两个实体，分别是学生和图书，它们的关系就是 m:n，从而形成中间表学生借阅的图书，结果是 1 本图书可以被多人借阅，1 个人也可以借多本图书。</p>
<h4 id="数据库系统结构"><a href="#数据库系统结构" class="headerlink" title="数据库系统结构"></a>数据库系统结构</h4><p>数据库系统的三级模式结构：模式（Schema）、外模式（External Schema）、内模式（Internal Schema）</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192529400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>模式（也称逻辑模式）：</strong></p>
<p>①数据库中全体数据的逻辑结构和特征的描述</p>
<p>②所有用户的公共数据视图，综合了所有用户的需求</p>
<p>模式的地位：是数据库系统模式结构的中间层</p>
<p>①与数据的物理存储细节和硬件环境无关</p>
<p>②与具体的应用程序、开发工具及高级程序设计语言无关</p>
<p><strong>外模式（也称子模式或用户模式）：</strong></p>
<p>①数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</p>
<p>②数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</p>
<p>外模式的用途：①保证数据库安全性的一个有力措施 ②每个用户只能看见和访问所对应的外模式中的数据</p>
<p><strong>内模式（也称存储模式）：</strong></p>
<p>①是数据物理结构和存储方式的描述</p>
<p>②是数据在数据库内部的表示方式：</p>
<p>a. 记录的存储方式（顺序存储，按照 B 树结构存储，按 hash 方法存储）</p>
<p>b. 索引的组织方式</p>
<p>c. 数据是否压缩存储</p>
<p>d. 数据是否加密</p>
<p>e. 数据存储记录结构的规定</p>
<h2 id="第-2-章-关系数据库"><a href="#第-2-章-关系数据库" class="headerlink" title="第 2 章 关系数据库"></a>第 2 章 <a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93&amp;spm=1001.2101.3001.7020">关系数据库</a></h2><p>由之前的内容直到，关系模型是由关系数据结构、关系操作集合、关系完整性约束三部分组成的，所以要了解对于关系模型这三部分的含义</p>
<h3 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1 关系数据结构及形式化定义"></a>2.1 关系数据结构及形式化定义</h3><p>关系模型是建立在集合代数的基础上的，因此从集合论角度给出关系数据结构的形式化定义。</p>
<p><strong>1. 域（Domain）</strong>：域是一组具有相同数据类型的值的集合，例如整数、自然数都是域</p>
<p><strong>2. 笛卡尔积（Cartesian Product）</strong>：笛卡尔积是域上面的一种集合运算。</p>
<p>给定一组域 D1，D2，…，Dn，允许其中某些域是相同的。 D1，D2，…，Dn 的笛卡尔积为：<br>$D<em>{1}\times D</em>{2}\times\dots \times D<em>{n}={(d</em>{1},d<em>{2},\dots,d</em>{n})|d<em>{i}\in D</em>{i},i=1,2,\dots,n}$</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192647367.png" alt=""></p>
<p>笛卡尔积中每个元素 (d1,d2,…dn) 称为一个 n 元组或简称<strong>元组</strong></p>
<p>笛卡尔积可表示为一个二维表，<strong>表中每行对应一个元组，表中每一列的值来自一个域</strong></p>
<p>例如，给出 3 个域：</p>
<p>D1 = 导师集合 SUPERVISOR=｛张清玫，刘逸｝</p>
<p>D2 = 专业集合 SPECIALITY=｛计算机专业，信息专业｝</p>
<p>D3 = 研究生集合 POSTGRADUATE=｛李勇，刘晨，王敏｝</p>
<p>D1，D2，D3 的笛卡尔积为</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192657261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>3. 关系（Relation）</strong></p>
<p>D1×D2×…×Dn 的子集叫作在域 D1，D2，…，Dn 上的关系，</p>
<p>表示为 R（D1，D2，…，Dn）</p>
<p>R：关系名</p>
<p>n：关系的目或度（Degree）</p>
<p>关系也是一个二维表，每行对应一个元组，每列对应一个域，每列称为属性</p>
<p>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为<strong>候选码（Candidate key）</strong></p>
<p>若一个关系有多个候选码，则选定其中一个或多个为<strong>主码（Primary key）</strong></p>
<p>候选码的多个属性称为<strong>主属性（Prime attribute）</strong>，不包含在任何候选码中的属性称为<strong>非主属性</strong>；最简单的情况下，候选码只包含一个属性，如果关系模式的所有属性都是这个关系的候选码，则称为<strong>全码（All-key）</strong></p>
<h3 id="2-2-关系操作"><a href="#2-2-关系操作" class="headerlink" title="2.2 关系操作"></a>2.2 关系操作</h3><p>关系模型中常用的关系操作包括查询（Query）操作和插入（Insert）、删除（Delete）、修改（Update）操作这两大部分。</p>
<p>查询操作又分为：选择（Select）、投影（Project）、连接（Join）、除（Divide）、并（Union）、差（Except）、交（Intersection）、笛卡尔积等；其中：<strong>选择、投影、并、差、笛卡尔积</strong>是 5 种基本操作，其他操作是可以用基本操作来定义和导出的。</p>
<h3 id="2-3-关系的完整性"><a href="#2-3-关系的完整性" class="headerlink" title="2.3 关系的完整性"></a>2.3 关系的完整性</h3><p>关系模型的完整性规则是对关系的某种约束条件，关系模型中有三类完整性约束：</p>
<p>实体完整性（Entity Integrity）：关系模型以主码作为唯一性标识，主码中的属性即主属性不能取空值</p>
<p>参照完整性（Referential Integrity）：外码</p>
<p>用户自定义完整性（User-defined Integrity）：反映某一具体应用所涉及的数据必须满足的语义要求</p>
<h3 id="2-4-关系代数"><a href="#2-4-关系代数" class="headerlink" title="2.4 关系代数"></a>2.4 <a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0&amp;spm=1001.2101.3001.7020">关系代数</a></h3><p>并、差、投影、笛卡尔积、选择为五个基本操作，交、连接、除等为附加操作，附加操作可以用五个基本操作表示</p>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>选择运算是从关系 R 中选取使逻辑表达式 F 为真的元组，是从行的角度进行的运算</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192739586.png" alt=""></p>
<p>如查询信息系（IS 系）全体学生   </p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192743765.png" alt="200"></p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>投影操作主要是从列的角度进行运算，但投影成功之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192754689.png" alt=""></p>
<p>如查询学生的姓名和所在系 </p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192758641.png" alt="200"></p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接运算的含义：<strong>从两个关系的笛卡尔积中选取属性间满足一定条件的元组</strong></p>
<p>等值连接：θ为’=’的连接运算称为等值连接，即选取属性相等的元组</p>
<p>自然连接：特殊的等值连接，两个关系中进行比较的分量必须是相同的属性组，在结果中要把重复的属性列去掉</p>
<p>一般的连接操作是从行的角度进行运算的，自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192808482.png" alt=""></p>
<p>例如：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192817517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>可以先得到两个关系的笛卡尔积，然后筛选出 C &lt; E 的</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192826234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192831415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>自然连接是特殊的等值连接，相同的属性组进行比较，并去除重复的属性列。即笛卡尔积里找出 B 相等的然后合并 R.B 和 S.B 为 B</p>
<p><strong>悬浮元组与外连接</strong></p>
<p>两个关系 R 和 S 在做<strong>自然连接</strong>时，关系 R 中某些元组有可能在 S 中不存在公共属性上值相等的元组，从而造成 R 中这些元组在操作时被舍弃了，这些被舍弃的元组称为<strong>悬浮元组</strong>。</p>
<p>外连接（OUTER JOIN）</p>
<p>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值 (Null)，就叫做外连接</p>
<p>左外连接 (LEFT OUTER JOIN 或 LEFT JOIN)：只保留左边关系 R 中的悬浮元组</p>
<p>右外连接 (RIGHT OUTER JOIN 或 RIGHT JOIN)：只保留右边关系 S 中的悬浮元组</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192906828.png" alt=""></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192909893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><p>除操作是同时从行和列的角度进行运算的</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192919637.png" alt=""></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192922956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629192929734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="第-3-章-SQL"><a href="#第-3-章-SQL" class="headerlink" title="第 3 章 SQL"></a>第 3 章 SQL</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img data-src="https://img-blog.csdnimg.cn/20190629192938312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>在 SQL 中一个关系就对应一个基本表，一个（或多个）基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。</p>
<p>存储文件的逻辑结构组成了关系数据库的内模式</p>
<p>视图是从一个或几个基本表导出的表，它本身不独立存储在数据库中，这些数据仍存放在导出视图的基本表中</p>
<h3 id="专有名词及解释"><a href="#专有名词及解释" class="headerlink" title="专有名词及解释"></a>专有名词及解释</h3><p><strong>1. 索引</strong>：建立索引是加快查询速度的有效手段，用户（数据库管理员或建表者）可以在基本表上建立一个或多个索引，以提供多种存取路径，系统在存取数据时会自动选择合适的索引作为存取路径。</p>
<p>索引是关系数据库的内部实现技术，属于内模式的范畴。</p>
<p>唯一索引：使用 UNIQUE 关键字，每个索引值对应唯一一条数据记录</p>
<p>非唯一索引：不使用 UNIQUE 关键字</p>
<p>聚簇索引：指索引项的顺序与表中记录的物理顺序一致的索引组织，可以在最经常查询的列上建立聚簇索引，对于经常更新的列不宜建立聚簇索引。一个表只能建立一个聚簇索引，一般默认是主键，所谓 “与记录的物理顺序一致” 即该记录升序索引也升序之类的？</p>
<p><strong>2. 视图</strong>：视图是从一个或几个基本表（或视图）导出的表，数据库只存放视图的定义而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中数据发生变化，从视图查询出的数据也会随之改变。</p>
<p>视图的作用：</p>
<p>①简化用户的操作：用户所做的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无须了解。</p>
<p>②使用户能以多种角度来看待同一数据：当许多不同种类的用户共享同一个数据库时，这种灵活性是非常有必要的。</p>
<p>③对重构数据库提供了一定的逻辑独立性：即使重构数据库也不一定需要修改应用程序。</p>
<p>④能够对机密数据提供安全保护：只允许用户查询提供给他的视图而不是直接查询表，可以隐藏表中的机密数据</p>
<p>⑤适当的利用视图可以更清晰地表达查询语句：利用视图来表达查询语句</p>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><p>SQL 数据定义语句</p>
<table border="1" cellspacing="0"><tbody><tr><td rowspan="2"><p>操作对象</p></td><td colspan="3"><p>操作方式</p></td></tr><tr><td><p>创建</p></td><td><p>删除</p></td><td><p>修改</p></td></tr><tr><td><p>模式</p></td><td><p>CREATE SCHEMA</p></td><td><p>DROP SCHEMA</p></td><td></td></tr><tr><td><p>表</p></td><td><p>CREATE TABLE</p></td><td><p>DROP TABLE</p></td><td><p>ALTER TABLE</p></td></tr><tr><td><p>视图</p></td><td><p>CREATE VIEW</p></td><td><p>DROP VIEW</p></td><td></td></tr><tr><td><p>索引</p></td><td><p>CREATE INDEX</p></td><td><p>DROP INDEX</p></td><td></td></tr></tbody></table>

<h4 id="1-创建-删除数据库"><a href="#1-创建-删除数据库" class="headerlink" title="1. 创建 / 删除数据库"></a>1. 创建 / 删除数据库</h4><p>create database 数据库名 [其他选项];</p>
<p>例如我们需要创建一个名为 samp_db 的数据库, 在命令行下执行以下命令:</p>
<p>create database samp_db character set gbk;</p>
<p>为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk。</p>
<p>drop database 数据库名 删除数据库</p>
<h4 id="2-创建-删除-修改基本表"><a href="#2-创建-删除-修改基本表" class="headerlink" title="2. 创建 / 删除 / 修改基本表"></a>2. 创建 / 删除 / 修改基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"></span><br><span class="line">id <span class="type">int</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line"></span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line"></span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"></span><br><span class="line"><span class="type">date</span> <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line"></span><br><span class="line">content <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">)<span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>【说明】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATATYPE <span class="comment">-- 数据类型，mysql 有 bit int decimal float varchar char date datetime</span></span><br><span class="line"></span><br><span class="line">NUT <span class="keyword">NULL</span> <span class="comment">-- 可不可以允许资料有空的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY <span class="comment">-- 是本表的主键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CONSTRAINT</span> <span class="comment">-- 是对表里的字段添加约束.(约束类型有 Check,Unique,Primary key,not null,Foreign key);</span></span><br></pre></td></tr></table></figure>
<p>删除表：<code>drop table student</code></p>
<p><em>修改表：</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#表结构修改</span><br><span class="line"></span><br><span class="line">create table test</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">id int not null auto_increment primary key, #设定主键</span><br><span class="line"></span><br><span class="line">name varchar(20) not null default &#x27;NoName&#x27;, #设定默认值</span><br><span class="line"></span><br><span class="line">department_id int not null,</span><br><span class="line"></span><br><span class="line">position_id int not null,</span><br><span class="line"></span><br><span class="line">unique (department_id,position_id) #设定唯一值</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#修改表的名字</span><br><span class="line"></span><br><span class="line">#格式: alter table tbl_name rename to new_name</span><br><span class="line"></span><br><span class="line">alter table test rename to test_rename;</span><br><span class="line"></span><br><span class="line">#向表中增加一个字段 (列)</span><br><span class="line"></span><br><span class="line">#格式: alter table tablename add columnname type;/alter table tablename add(columnname type);</span><br><span class="line"></span><br><span class="line">alter table test add  columnname varchar(20);</span><br><span class="line"></span><br><span class="line">#修改表中某个字段的名字</span><br><span class="line"></span><br><span class="line">alter table tablename change columnname newcolumnname type;  #修改一个表的字段名</span><br><span class="line"></span><br><span class="line">alter table test change name uname varchar(50);</span><br><span class="line"></span><br><span class="line">select * from test;</span><br><span class="line"></span><br><span class="line">#表 position 增加列 test</span><br><span class="line"></span><br><span class="line">alter table position add(test char(10));</span><br><span class="line"></span><br><span class="line">#表 position 修改列 test</span><br><span class="line"></span><br><span class="line">alter table position modify test char(20) not null;</span><br><span class="line"></span><br><span class="line">#表 position 修改列 test 默认值</span><br><span class="line"></span><br><span class="line">alter table position alter test set default &#x27;system&#x27;;</span><br><span class="line"></span><br><span class="line">#表 position 去掉 test 默认值</span><br><span class="line"></span><br><span class="line">alter table position alter test drop default;</span><br><span class="line"></span><br><span class="line">#表 position 去掉列 test</span><br><span class="line"></span><br><span class="line">alter table position drop column test;</span><br><span class="line"></span><br><span class="line">#表 depart_pos 删除主键</span><br><span class="line"></span><br><span class="line">alter table depart_pos drop primary key;</span><br><span class="line"></span><br><span class="line">#表 depart_pos 增加主键</span><br><span class="line"></span><br><span class="line">alter table depart_pos add primary key PK_depart_pos</span><br><span class="line"></span><br><span class="line">(department_id,position_id);</span><br></pre></td></tr></table></figure>
<h4 id="3-主键和外键"><a href="#3-主键和外键" class="headerlink" title="3. 主键和外键"></a>3. 主键和外键</h4><p>主键具有唯一性，能够唯一标识表中的一个单独的行</p>
<p>定义外键是为了确保这一列的值是有效的（比如说该列为该表与另一个表 “共同使用” 的列，那么需要保证其“确实存在”，即在另一个表中有对应的值才能进行相关操作）</p>
<h4 id="4-建立索引"><a href="#4-建立索引" class="headerlink" title="4. 建立索引"></a>4. 建立索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span> 索引名 <span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>(<span class="operator">&lt;</span> 列名 <span class="operator">&gt;</span>[<span class="operator">&lt;</span> 次序 <span class="operator">&gt;</span>][,<span class="operator">&lt;</span> 列名 <span class="operator">&gt;</span>[<span class="operator">&lt;</span> 次序 <span class="operator">&gt;</span>] ]…);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">*</span>   <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>：要建索引的基本表的名字</span><br><span class="line"><span class="operator">*</span>   索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔</span><br><span class="line"><span class="operator">*</span>   <span class="operator">&lt;</span>次序<span class="operator">&gt;</span>：指定索引值的排列次序，升序：<span class="keyword">ASC</span>，降序：<span class="keyword">DESC</span>。缺省值：<span class="keyword">ASC</span></span><br><span class="line"><span class="operator">*</span>   <span class="keyword">UNIQUE</span>：此索引的每一个索引值只对应唯一的数据记录</span><br><span class="line"><span class="operator">*</span>   CLUSTER：表示要建立的索引是聚簇索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/2019062919311513.png" alt=""></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193118937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span> 目标列表达式 <span class="operator">&gt;</span> [，<span class="operator">&lt;</span> 目标列表达式 <span class="operator">&gt;</span>] …</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[， <span class="operator">&lt;</span> 表名或视图名 <span class="operator">&gt;</span> ] …</span><br><span class="line"></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span> 条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line"></span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span> 列名 <span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span> 条件表达式 <span class="operator">&gt;</span> ] ]</span><br><span class="line"></span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span> 列名 <span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] ]；</span><br></pre></td></tr></table></figure>
<p>语义：根据 WHERE 子句的条件表达式，从 FROM 子句指定的基本表或视图中找出满足条件的元组，再按 SELECT 子句中的目标表达式，选出元组中的属性值形成结果表。</p>
<p>如果有 GROUP BY 子句，则将结果按 &lt;列名 1&gt; 的值进行分组，该属性列值相等的元组称为一个组。如果 GROUP BY 子句带 HAVING 短语，则只有满足指定条件的组才予以输出。</p>
<p>如果有 ORDER BY 子句，则结果表还要按 &lt;列名 2&gt; 的值的升序或降序排列</p>
<h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><p><strong>1. 选择表中的若干列</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname <span class="keyword">FROM</span> Student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Student</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname, <span class="number">2014</span> – Sage <span class="keyword">FROM</span> Student <span class="comment">/* 查询结果的第 2 列是一个算术表达式，表中会得到 2014 – Sage 的值 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname NAME, ‘<span class="keyword">Year</span> <span class="keyword">of</span> Birth’: BIRTH, <span class="number">2004</span> – Sage BIRTHDAY, <span class="built_in">LOWER</span>(Sdept) DEPARTMENT <span class="comment">/* 可以通过指定别名来改变查询结果的列标题，Sname 列名会变为 NAME */</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 选择表中的若干元组</strong></p>
<p>①SELECT DISTINCT Sno FROM SC /<em> 使用 DISTINCT 关键字消除重复的行 </em>/</p>
<p>②使用 WHERE 查询满足条件的元组</p>
<table border="1" cellspacing="0"><tbody><tr><td><p>查 询 条 件</p></td><td><p>谓 词</p></td></tr><tr><td><p>比 较</p></td><td><p>=，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt;；NOT + 上述比较运算符</p></td></tr><tr><td><p>确定范围</p></td><td><p>BETWEEN AND，NOT BETWEEN AND</p></td></tr><tr><td><p>确定集合</p></td><td><p>IN，NOT IN</p></td></tr><tr><td><p>字符匹配</p></td><td><p>LIKE，NOT LIKE</p></td></tr><tr><td><p>空 值</p></td><td><p>IS NULL，IS NOT NULL</p></td></tr><tr><td><p>多重条件（逻辑运算）</p></td><td><p>AND，OR，NOT</p></td></tr></tbody></table>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Sdept, Sage <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询年龄在 20~23 岁（包括 20 岁和 23 岁）之间的学生的姓名、系别、年龄 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Sname, Ssex <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (‘CS’, ‘MA’, ‘<span class="keyword">IS</span>’)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IN 用于查找属性值属于指定集合的元组，即 Sdept 等于’CS’ ‘MA’ ‘IS’中的一个即可 */</span></span><br><span class="line"></span><br><span class="line">字符匹配：[<span class="keyword">NOT</span>] <span class="keyword">LIKE</span> ‘<span class="operator">&lt;</span> 匹配串 <span class="operator">&gt;</span>’ [<span class="keyword">ESCAPE</span> ‘ <span class="operator">&lt;</span> 换码字符 <span class="operator">&gt;</span>’]</span><br><span class="line"></span><br><span class="line">语义：查找指定的属性列值与 <span class="operator">&lt;</span>匹配串<span class="operator">&gt;</span> 相匹配的元组，<span class="keyword">ESCAPE</span> 用于对通配符的转义，如 <span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> ‘DB\_Design’ <span class="keyword">ESCAPE</span> ‘\’</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 \ 定义为转义字符，这样匹配的就是’DB_Design’，即’_’失去了通配符的含义 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>%：代表任意长度（&gt;=0）的字符串</li>
<li>_：代表任意单个字符</li>
<li>[ ]：匹配括号内所列字符中的一个,</li>
<li><sup><a href="#fn_" id="reffn_"></a></sup>：匹配不在括号内所列字符中的单个字符</li>
</ul>
<p>注：数据库字符集为 ASCII 时一个汉字需要两个_，字符集为 GBK 时只需要一个</p>
<p>③多重条件查询，逻辑运算符 AND 和 OR 可用来联结过个查询条件，AND 的优先级高于 OR，但可用括号改变优先级</p>
<p><code>SELECT Sname FROM Student WHERE Sdept = ‘CS’ AND Sage &lt; 20</code></p>
<p><strong>3.ORDER BY 子句</strong></p>
<p>对查询结果按一个或多个属性列的升序（ASC）或降序（DESC）排列，缺省值为升序</p>
<p><strong>4. 聚集函数（系统自带函数?）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">COUNT（<span class="operator">*</span>）                                    统计元组个数  </span><br><span class="line"></span><br><span class="line">COUNT（[<span class="keyword">DISTINCT</span><span class="operator">|</span><span class="keyword">ALL</span>] <span class="operator">&lt;</span> 列名 <span class="operator">&gt;</span>）  统计一列中值的个数</span><br><span class="line"></span><br><span class="line">SUM（[<span class="keyword">DISTINCT</span><span class="operator">|</span><span class="keyword">ALL</span>] <span class="operator">&lt;</span> 列名 <span class="operator">&gt;</span>）   计算一列值的总和（此列必须为数值型）</span><br><span class="line"></span><br><span class="line">AVG（[<span class="keyword">DISTINCT</span><span class="operator">|</span><span class="keyword">ALL</span>] <span class="operator">&lt;</span> 列名 <span class="operator">&gt;</span>）            计算一列值的平均值（此列必须为数值型）</span><br><span class="line"></span><br><span class="line">MAX（[<span class="keyword">DISTINCT</span><span class="operator">|</span><span class="keyword">ALL</span>] <span class="operator">&lt;</span> 列名 <span class="operator">&gt;</span>）      求一列中的最大值</span><br><span class="line"></span><br><span class="line">MIN（[<span class="keyword">DISTINCT</span><span class="operator">|</span><span class="keyword">ALL</span>] <span class="operator">&lt;</span> 列名 <span class="operator">&gt;</span>）       求一列中的最小值</span><br></pre></td></tr></table></figure>
<p>如果指定 DISTINCT 短语，则表示在计算时取消指定列中的重复值，ALL 为缺省值，表示不取消重复值</p>
<p><code>SELECT COUNT(*) FROM Student /* 查询学生总人数 */</code></p>
<p><strong>5.GROUP BY 子句</strong></p>
<p>GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组；分组的目的是为了细化聚集函数的作用对象，如果未对查询结果分组，聚集函数将作用于整个查询结果分组后聚集函数将作用于每一个组，即每一个组都有一个函数值</p>
<p><code>SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*) &gt; 3</code></p>
<p>这里先用 GROUP BY 子句按 Sno 进行分组，再用聚集函数 COUNT 对每一个组计数，HAVING 短语给出了选择组的条件。</p>
<p>另外，注意 WHERE 子句与 HAVING 子句的作用对象，WHERE 子句作用于基本表或视图，从中选择满足条件的元组；HAVING 短语作用于组，从中选择满足条件的组</p>
<p>如下面的语句是不对的：</p>
<p>SELECT Sno, AVG(Grade) FROM SC</p>
<p>  WHERE AVG(Grade) &gt;= 90 GROUP BY Sno;</p>
<p>正确的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(Grade) <span class="keyword">FROM</span> SC</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade) <span class="operator">&gt;=</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>若一个查询同时涉及两个以上的表，则称之为连接查询</p>
<p><strong>1. 等值与非等值连接查询</strong></p>
<p>连接查询的 WHERE 子句中用来连接两个表的条件称为链接条件或连接谓词，其一般格式如下：</p>
<p><code>[&lt;表名 1&gt;.]&lt; 列名 1&gt; &lt; 比较运算符 &gt; [&lt; 表名 2&gt;.]&lt; 列名 2&gt;</code></p>
<p>运算符为 = 时称为等值连接，否则称为非等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student. <span class="operator">*</span>, SC. <span class="operator">*</span> <span class="keyword">FROM</span> Student, SC</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno</span><br></pre></td></tr></table></figure>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193231904.png" alt=""></p>
<p>自然连接（在等值连接中把目标列中重复的属性列去掉）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> Student, SC</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno</span><br></pre></td></tr></table></figure>
<p><strong>2. 自身连接</strong></p>
<p>需要取两个表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIRST.Cno, SECOND.Cpno</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> SECOND.Cno</span><br></pre></td></tr></table></figure>
<p><strong>3. 外连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">LEFT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span>(Student.Sno <span class="operator">=</span> SC.Sno)</span><br></pre></td></tr></table></figure>
<p><strong>4. 复合条件连接</strong></p>
<p>INNER JOIN（内连接, 或等值连接）：获取两个表中字段匹配关系的记录。</p>
<p>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</p>
<p>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2019062919325667.png" alt="200"></p>
<p><img data-src="https://img-blog.csdnimg.cn/2019062919325688.png" alt="200"></p>
<p><img data-src="https://img-blog.csdnimg.cn/2019062919325695.png" alt="200"></p>
<p><strong>嵌套查询和集合查询</strong></p>
<p>在子查询中，程序先运行在嵌套在最内层的语句，再运行外层。因此在写子查询语句时，可以先测试下内层的子查询语句是否输出了想要的内容，再一层层往外测试，增加子查询正确率。否则多层的嵌套使语句可读性很低</p>
<p><code>exists 的返回结果是 bool 型，只有 true 或者 false</code></p>
<p>如 <code>SELECT * FROM alumni_info t WHERE EXISTS(SELECT a_id FROM alumni_education e WHERE e.a_id=&#39;6588&#39;)</code>，返回的结果跟 <code>SELECT * FROM alumni_info t</code> 一样（a_id=6588 存在），因为 select 语句先执行 where 条件后的语句，再筛选字段，当执行完 where 条件后，若这条结果集存在，则 where 表达式后面永远都是 true，否则为 false。也就是说要么查询所有，要么没有数据。</p>
<h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p>注意：子查询的 SELECT 语句中不能使用 ORDER BY 子句，ORDER BY 子句只能对最终查询结果排序</p>
<p>子查询的查询条件依赖于父查询，则称这类子查询为相关子查询，否则称不相关子查询。</p>
<p><strong>1. 带有 IN 谓词的子查询</strong></p>
<p>子查询结果往往是一个集合，所以谓词 IN 是嵌套查询中最常使用的谓词</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Sdept <span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Sdept <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname<span class="operator">=</span>’刘晨’)</span><br></pre></td></tr></table></figure>
<p><strong>2. 带有比较运算符的子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Cno <span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Grade) <span class="keyword">FROM</span> SC y <span class="keyword">WHERE</span> y.Sno <span class="operator">=</span> x.Sno) <span class="comment">/* 依赖 x.Sno，相关子查询 */</span></span><br></pre></td></tr></table></figure>
<p>其可能的执行过程：</p>
<p>①从外层查询中取出 SC 的一个元组 x，将元组 x 的 Sno 值传送给内层查询</p>
<p>②执行内层查询，得到值 88，用该值代替内层查询，得到外层查询</p>
<p>③执行这个查询，得到</p>
<p>(200215121, 1)</p>
<p>(200215121, 3)</p>
<p>④然后外层查询取出下一个元组重复①~③，直到外层的 SC 元组全部处理完毕</p>
<p>如果是不相关子查询，可以发现其求解顺序是从内向外的。</p>
<p><strong>3. 带有 ANY(SOME) 或 ALL 谓词的子查询</strong></p>
<p>子查询如果返回多值，就需要使用 ANY 或 ALL 谓词，其语义为</p>
<blockquote>
<p>ANY           大于子查询结果中的某个值</p>
<p>ALL            大于子查询结果中的所有值</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Sage <span class="keyword">FROM</span> Student</span><br><span class="line"></span><br><span class="line">  <span class="keyword">WHERE</span> Sage <span class="operator">&lt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> Sage <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sdept <span class="operator">=</span> ‘CS’) <span class="keyword">AND</span> Sdept <span class="operator">&lt;&gt;</span> ‘CS’;</span><br></pre></td></tr></table></figure>
<p>查询其他系中比计算机科学系所有学生年龄都小的学生姓名及年龄</p>
<p>执行此查询时，首先处理子查询，找出 CS 系中所有学生的年龄，构成一个集合（20， 19），然后处理父查询</p>
<p><strong>4. 带有 EXISTS 谓词的子查询</strong></p>
<p>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑值”true” 或”false”</p>
<p>若内层查询结果非空，则外层的 WHERE 子句返回真值，否则返回假值，带 EXISTS 的子查询一般都是用 *</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">FROM</span> Student</span><br><span class="line"></span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span> Cno <span class="operator">=</span> ‘<span class="number">1</span>’);</span><br></pre></td></tr></table></figure>
<p>其处理过程：首先取外层查询 Student 表中的第一个元组，根据它与内层查询相关的属性值（Sno）处理内层查询，若 WHERE 子句返回值为真，则取外层查询中该元组的 Sname 放入结果表；……</p>
<h4 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h4><p>集合操作包括并操作 UNION、交操作 INTERSECT 和差操作 EXCEPT，参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同。（相同属性列？）</p>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>INSERT 通常有两种形式，一种是插入一个元组，另一种是插入子查询结果。后者可一次插入多个元组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span> 属性列 <span class="number">1</span><span class="operator">&gt;</span>[，<span class="operator">&lt;</span> 属性列 <span class="number">2</span> <span class="operator">&gt;</span>…)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="operator">&lt;</span>常量 <span class="number">1</span><span class="operator">&gt;</span> [，<span class="operator">&lt;</span> 常量 <span class="number">2</span><span class="operator">&gt;</span>] … )</span><br></pre></td></tr></table></figure>
<p>注意：INTO 子句中没有出现的属性列，新元组在这些列上将取空值。如果表定义说明了 NOT NULL 的属性列不能取空值，否则会出错。</p>
<p>如果 INTO 子句没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值。</p>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span> 表达式 <span class="operator">&gt;</span>[，<span class="operator">&lt;</span> 列名 <span class="operator">&gt;=</span><span class="operator">&lt;</span> 表达式 <span class="operator">&gt;</span>]…</span><br><span class="line"></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span> 条件<span class="operator">&gt;</span>]；</span><br></pre></td></tr></table></figure>
<p>修改指定表中满足 WHERE 子句条件的元组，如果省略 WHERE 子句，则表示要修改表中所有的元组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student <span class="keyword">SET</span> Sage <span class="operator">=</span> Sage <span class="operator">+</span> <span class="number">1</span> <span class="comment">/* 将所有学生的年龄增加 1 岁 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Student <span class="keyword">SET</span> Sage <span class="operator">=</span> <span class="number">22</span> <span class="keyword">WHERE</span> Sno <span class="operator">=</span> ‘<span class="number">200215121</span>’</span><br></pre></td></tr></table></figure>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span> 条件<span class="operator">&gt;</span>]；</span><br></pre></td></tr></table></figure>
<p>从指定表删除满足 WHERE 子句条件的所有元组。如果省略 WHERE 子句，则删除表中全部元组，但表的定义仍在字典中。即 DELETE 语句删除的是表中的数据，而不是关于表的定义。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW</span><br><span class="line"></span><br><span class="line">&lt;视图名&gt; [(&lt; 列名 &gt; [，&lt; 列名 &gt;]…)]</span><br><span class="line"></span><br><span class="line">AS &lt;子查询&gt;</span><br><span class="line"></span><br><span class="line">[WITH CHECK OPTION]；</span><br></pre></td></tr></table></figure>
<h2 id="第-4-章-数据库安全性"><a href="#第-4-章-数据库安全性" class="headerlink" title="第 4 章 数据库安全性"></a>第 4 章 数据库安全性</h2><p>这里只讨论用户标识和鉴定、存取控制、视图、审计、数据加密技术。</p>
<h3 id="专有名词及解释-1"><a href="#专有名词及解释-1" class="headerlink" title="专有名词及解释"></a>专有名词及解释</h3><p><strong>1. 数据库管理员</strong>：拥有所有对象的所有权限，根据实际情况不同的权限授予不同的用户</p>
<p><strong>2. 用户</strong>：拥有自己建立的对象的全部的操作权限，可以使用 GRANT，把权限授予其他用户</p>
<p><strong>3. 角色</strong>：数据库角色是权限的集合。可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程。</p>
<p><strong>4. 审计</strong>：启用一个专用的审计日志（Audit Log），将用户对数据库的所有操作记录在上面；审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容。</p>
<ul>
<li>审计很费时间和空间</li>
<li>DBA 可以根据应用对安全性的要求，灵活地打开或关闭审计功能</li>
<li>审计功能主要用于安全性要求较高的部门</li>
</ul>
<h3 id="用户标识与鉴别（Identification-amp-Authentication）"><a href="#用户标识与鉴别（Identification-amp-Authentication）" class="headerlink" title="用户标识与鉴别（Identification &amp; Authentication）"></a>用户标识与鉴别（Identification &amp; Authentication）</h3><p>即由系统提供一定的方式让用户标识自己的名字或身份，每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供机器使用权。如连接数据库时输入的用户名和密码。</p>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>存取控制机制主要包括两部分：</p>
<ol>
<li><p>定义用户权限，并将用户权限登记到数据字典中</p>
</li>
<li><p>合法权限检查：每当用户发出存取数据库的操作请求后，DBMS 查找数据字典，根据安全规则进行合法权限检查。</p>
</li>
</ol>
<p><strong>自主存取控制（Discretionary Access Control，DAC）</strong>：用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可以将其拥有的存取权限转授给其他用户。非常灵活。主要通过 SQL 的 GRANT 语句和 REVOKE 语句来实现。</p>
<p><strong>强制存取控制（Mandatory Access Control，MAC）</strong>：每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。较为严格。</p>
<h4 id="自主存取控制"><a href="#自主存取控制" class="headerlink" title="自主存取控制"></a>自主存取控制</h4><p><img data-src="https://img-blog.csdnimg.cn/20190629193418876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT &lt;权限&gt;[,&lt; 权限 &gt;]...</span><br><span class="line"></span><br><span class="line">ON &lt;对象类型&gt; &lt; 对象名 &gt;[,&lt; 对象类型 &gt; &lt; 对象名 &gt;]…</span><br><span class="line"></span><br><span class="line">TO &lt;用户&gt;[,&lt; 用户 &gt;]...</span><br><span class="line"></span><br><span class="line">[WITH GRANT OPTION];</span><br></pre></td></tr></table></figure>
<p>语义：将对指定操作对象的指定操作权限授予指定的用户。发出该 GRANT 语句的可以是 DBA，也可以是数据库对象创建者，也可以是已经拥有该权限的用户。</p>
<p>如果指定了 WITH GRANT OPTION 子句，则获得某种权限的用户还可以把这种权限再授予其他的用户。不允许循环授权</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193433550.png" alt="500"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT ON TABLE Student TO U1; /* 把查询 Student 表的权限授予用户 U1 */</span><br><span class="line"></span><br><span class="line">REVOKE &lt;权限&gt;[,&lt; 权限 &gt;]...</span><br><span class="line"></span><br><span class="line">ON &lt;对象类型&gt; &lt; 对象名 &gt;[,&lt; 对象类型 &gt; &lt; 对象名 &gt;]…</span><br><span class="line"></span><br><span class="line">FROM &lt;用户&gt;[,&lt; 用户 &gt;]...[CASCADE|RESTRICT];</span><br><span class="line"></span><br><span class="line">REVOKE UPDATE(Sno) ON TABLE Student FROM U4; /* 回收用户 U4 修改学生学号的权限 */</span><br></pre></td></tr></table></figure>
<h4 id="强制存取控制"><a href="#强制存取控制" class="headerlink" title="强制存取控制"></a>强制存取控制</h4><ol>
<li>保证更高程度的安全性</li>
<li>用户不能直接感知或进行控制</li>
<li>适用于对数据有严格而固定密级分类的部门</li>
</ol>
<p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类：</p>
<p><strong>主体</strong>是系统中的活动实体，如：DBMS 所管理的实际用户，代表用户的各进程</p>
<p><strong>客体</strong>是系统中的被动实体，受主体操纵，如：文件、基表、索引、视图</p>
<p><strong>敏感度标记（Label）</strong>：对于主体和客体，DBMS 为它们每个实例（值）指派一个敏感度标记（Label）敏感度标记分成若干级别</p>
<ul>
<li>绝密（Top Secret，TS）</li>
<li>机密（Secret，S）</li>
<li>可信（Confidential，C）</li>
<li>公开（Public，P）</li>
</ul>
<p>TS&gt;=S&gt;=C&gt;=P</p>
<p>主体的敏感度标记称为<strong>许可证级别</strong>（Clearance Level）</p>
<p>客体的敏感度标记称为<strong>密级</strong>（Classification Level）</p>
<p>当一个用户以标记 label 注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：</p>
<p>(1) 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</p>
<p>(2) 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体</p>
<p>注意第 2 点，即用户可以写入数据但是不能再读取自己写入的数据。</p>
<h2 id="第-5-章-数据库完整性"><a href="#第-5-章-数据库完整性" class="headerlink" title="第 5 章 数据库完整性"></a>第 5 章 数据库完整性</h2><p>数据库完整性是指数据的正确性和相容性。完整性是为了防止数据库中存在不符合语义的数据，即防止数据库中存在不正确的数据。</p>
<p>为了维护数据库的完整性，DBMS 必须能够：</p>
<ol>
<li><p>提供定义完整性约束条件的机制：完整性一般由 SQL 的 DDL 语句来实现，它们作为数据库模式的一部分存入数据字典中。</p>
</li>
<li><p>提供完整性检查的方法：检查数据是否满足完整性约束条件的机制</p>
</li>
<li><p>违约处理：若用户违背了完整性约束条件，应该采取的动作</p>
</li>
</ol>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>关系模型的实体完整性在 CREATE TABLE 中用 PRIMARY KEY 定义。一种是定义为列级约束条件，另一种是定义为表级约束条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE Student (</span><br><span class="line">       Sno CHAR(9) PRIMARY KEY, /* 在列级定义主码 */</span><br><span class="line">       Sname CHAR(20) NOT NULL,</span><br><span class="line">       Ssex CHAR(2),</span><br><span class="line">       Sage SMALLINT,</span><br><span class="line">       Sdept CHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE Student (</span><br><span class="line">       Sno CHAR(9) ,</span><br><span class="line">       Sname CHAR(20) NOT NULL,</span><br><span class="line">       Ssex CHAR(2),</span><br><span class="line">       Sage SMALLINT,</span><br><span class="line">       Sdept CHAR(20)</span><br><span class="line">       PRIMARY KEY(Sno)  /* 在表级定义主码 */</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE Student (</span><br><span class="line">       Sno CHAR(9) ,</span><br><span class="line">       Sname CHAR(20) NOT NULL,</span><br><span class="line">       Ssex CHAR(2),</span><br><span class="line">       Sage SMALLINT,</span><br><span class="line">       Sdept CHAR(20)</span><br><span class="line">       PRIMARY KEY(Sno,Sname)  /* 属性组定义为主码，只能在表级定义 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>违约处理：</p>
<p>当用户程序对基本表插入一条记录或对主码列进行更新操作时，会进行如下检查</p>
<p>（1）检查主码值是否唯一，如果不唯一则拒绝插入或修改</p>
<p>（2）检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>关系模型的参照完整性在 CREATE TABLE 中用 FOREIGN KEY 短语定义哪些列为外码，用 REFERENCES 短语指明这些外码参照哪些表的主码。</p>
<p>例如，关系 SC 中一个元组表示一个学生选修的某门课程的成绩，（Sno,Cno）是主码。Sno、Cno 分别参照引用 Student 表的主码和 Course 表的主码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC (</span><br><span class="line">       Sno CHAR(9) NOT NULL,</span><br><span class="line">       Cno CHAR(4) NOT NULL,</span><br><span class="line">       Grade SMALLINT,</span><br><span class="line">       PRIMARY KEY(Sno, Cno),</span><br><span class="line">       FOREIGN KEY(Sno) REFERENCES Student(Sno),</span><br><span class="line">       FOREIGN KEY(Cno) REFERENCES Course(Cno)    /* 在表级定义参照完整性 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>违约检查：</p>
<p>对被参照表和参照表进行增删改操作时都会进行检查</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193507146.png" alt=""></p>
<p>当不一致发生时，系统可以采用如下策略处理：</p>
<p>（1）拒绝 (NO ACTION) 执行：不允许该操作执行，该策略一般设置为默认策略</p>
<p>（2）级联 (CASCADE) 操作：当删除或修改被参照表的一个元组导致与参照表（SC）的不一致时，删除或修改参照表中的所有导致不一致的元组。</p>
<p>（3）设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有造成不一致的元组的对应属性设置为空值。</p>
<p>如果要采取非默认策略需要显式地加以说明，如：</p>
<p>ON DELETE NO ACTION</p>
<p>ON UPDATE CASCADE</p>
<h3 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h3><ol>
<li>属性上的约束条件的定义</li>
</ol>
<p>NULL/NOT NULL、DEFAULT，UNIQUE、CHECK</p>
<ul>
<li>列值非空（NOT NULL）</li>
<li>列值唯一（UNIQUE）</li>
</ul>
<ol>
<li>元组上的约束条件</li>
</ol>
<p>使用 CHECK 短语定义元组上的约束条件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE SC (</span><br><span class="line">       Sno CHAR(9) NOT NULL,</span><br><span class="line">       Cno CHAR(4) NOT NULL,</span><br><span class="line">       Grade SMALLINT,</span><br><span class="line">       PRIMARY KEY(Sno, Cno),</span><br><span class="line">       CHECK(Sno=&#x27;x&#x27; OR Cno NOT LIKE &#x27;MS.%&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>违约处理：拒绝执行</p>
<h3 id="触发器（Trigger）"><a href="#触发器（Trigger）" class="headerlink" title="触发器（Trigger）"></a>触发器（Trigger）</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程，其不仅可以用于数据库完整性检查，也可以用来实现数据库的其他功能，包括数据库安全性，以及一些业务流程和控制流程。</p>
<p>定义触发器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER &lt;触发器名&gt;    /* 每当触发事件发生时，该触发器被激活 */</span><br><span class="line"></span><br><span class="line">&#123;BEFORE | AFTER&#125; &lt; 触发事件 &gt; ON &lt; 表名 &gt; /* 指明触发器激活的时间是在执行触发事件前或后 */</span><br><span class="line"></span><br><span class="line">REFERENCING NEW|OLD ROW AS &lt;变量&gt; /*REFERENCING 指出引用的变量 */</span><br><span class="line"></span><br><span class="line">FOR EACH &#123;ROW | STATEMENT&#125;             /* 定义触发器的类型，指明动作体执行的频率 */</span><br><span class="line"></span><br><span class="line">[WHEN &lt; 触发条件&gt; ]                         /* 仅当触发条件为真时才执行触发动作体 */</span><br><span class="line"></span><br><span class="line">&lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>
<p>要点:</p>
<ol>
<li>只有创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器</li>
<li>触发器名唯一</li>
<li>触发器只能定义在基本表上，不能定义在视图上</li>
<li>触发事件可以是 <code>INSERT</code> <code>DELETE</code> 或 <code>UPDATE</code>，也可以是这几个事件的组合，如 <code>INSERT OR DELETE</code>等，还可以是 <code>UPDATE OF &lt;触发列, …&gt;</code> 指明修改哪些列时激活触发器。</li>
<li><code>AFTER / BEFORE</code> 是触发的时机，<code>AFTER</code> 表示在触发事件的操作执行之后激活触发器。</li>
<li>触发器类型：FOR EACH ROW（行级触发器）和 FOR EACH STATEMENT（语句触发器），假设表 TEACHAR 有 1000 行，行级触发器将执行 1000 次，而语句触发器只执行 1 次</li>
<li>触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行；否则触发动作体不执行。如果省略 WHEN 触发条件，则触发动作体在触发器激活后立即执行。</li>
<li>触发动作体：在过程体中可以使用 NEW 和 OLD 来引用 UPDATE/INSERT 事件之后的新值和之前的旧值，如果是语句级触发器则不能使用 NEW 或 OLD 引用。</li>
</ol>
<p>多个执行语句的触发器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件</span><br><span class="line"></span><br><span class="line">ON 表名 FOR EACH ROW</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">    执行语句列表</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER Insert_Or_Update_Sal</span><br><span class="line"></span><br><span class="line">  BEFORE INSERT OR UPDATE ON Teacher</span><br><span class="line"></span><br><span class="line">  FOR EACH ROW</span><br><span class="line"></span><br><span class="line">  AS BEGIN</span><br><span class="line"></span><br><span class="line">       IF (new.Job = ‘教授’) AND (new.Sal &lt; 4000) THEN</span><br><span class="line"></span><br><span class="line">         new.Sal := 4000;</span><br><span class="line"></span><br><span class="line">       END IF;</span><br><span class="line"></span><br><span class="line">  END;</span><br></pre></td></tr></table></figure>
<p>删除触发器：<code>DROP TRIGGER &lt;触发器名&gt; ON &lt; 表名 &gt;</code></p>
<h2 id="第-6-章-关系数据库理论"><a href="#第-6-章-关系数据库理论" class="headerlink" title="第 6 章 关系数据库理论"></a>第 6 章 关系数据库理论</h2><h3 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a><strong>数据依赖</strong></h3><p>数据依赖是一个关系内部属性与属性之间的一种约束关系。有多种类型的数据依赖，其中最重要的是<strong>函数依赖（Functional Dependency,FD）和多值依赖（Multivalued Dependency,MVD）</strong></p>
<p>一个不好的关系模式会存在以下一些问题：</p>
<p>(1) 数据冗余太大：信息被重复存储，导致浪费大量存储空间</p>
<p>(2) 更新异常：当重复信息的一个副本被修改，所有副本都必须进行同样的修改。因此当更新数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。</p>
<p>(3) 插入异常：只有当一些信息事先已经存放在数据库中时，另外一些信息才能存入数据库中</p>
<p>(4) 删除异常：删除某些信息时可能丢失其它信息</p>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>规范化理论是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决数据冗余、插入异常、更新异常、删除异常这些问题。</p>
<p>定义 1：设 R(U) 是一个属性集 U 上的关系模式，X 和 Y 是 U 的子集。若对于 R(U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等， 而在 Y 上的属性值不等， 则称 “X 函数确定 Y” 或 “Y 函数依赖于 X”，记作 X→Y。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2019062919355019.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>即 Sno→Sname 这个函数依赖只有在不可能存在两个元组在 Sno 上的值相等，而在 Sname 上的值不等时才成立。（左边相等右边必相等）</p>
<p>在关系模式 R(U) 中，对于 U 的子集 X 和 Y，</p>
<p>如果 X→Y，但 Y 不为 X 的子集？，则称 X→Y 是<strong>非平凡的函数依赖</strong></p>
<p>若 X→Y，但 Y Í X, 则称 X→Y 是<strong>平凡的函数依赖</strong></p>
<p>完全函数依赖：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193601651.png" alt="100"></p>
<p>部分函数依赖：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193601806.png" alt="100"></p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193609721.png" alt=""></p>
<p>上图中</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193615156.png" alt="200">是完全函数依赖，</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193615144.png" alt="200">是部分数依赖，因为 Sno→Sdept 成立，而 Sno 是（Sno，Cno）的真子集</p>
<p>范式：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193641297.png" alt=""></p>
<p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化</p>
<h4 id="1NF："><a href="#1NF：" class="headerlink" title="1NF："></a>1NF：</h4><p>如果一关系模式 r(R)的每个属性对应的域值都是不可分的 (即原子的)，则称 r(R) 属于第一范式，记为 $r(R)Î1NF$.</p>
<p>第一范式的目标是：将基本数据划分成称为实体集或表的逻辑单元，当设计好每个实体后，需要为其指定主码。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193650963.png" alt="700"></p>
<p>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库</p>
<h4 id="2NF："><a href="#2NF：" class="headerlink" title="2NF："></a>2NF：</h4><p>若关系模式 R∈1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则 R∈2NF。</p>
<p>第二范式的目标：将只部分依赖于候选码（即依赖于候选码的部分属性）的非主属性移到其他表中。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193705542.png" alt="500"></p>
<p>S-L-C 这个函数依赖图中非主属性 Sdept 和 Sloc 部分函数依赖于码 (Sno, Cno)</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193713265.png" alt="500"></p>
<p>将其分为两个表后使得非主属性对其各自的码都是完全函数依赖</p>
<p>2NF 范式虽然消除了由于非主属性对候选码的部 分依赖所引起的冗余及各种异常，但并没有排除传递依赖。因此，还需要对其进一步规范化</p>
<h4 id="3NF："><a href="#3NF：" class="headerlink" title="3NF："></a>3NF：</h4><p>若 R∈3NF，则每一个非主属性既不部分依赖于码也不传递依赖于码</p>
<p>第三范式的目标：去掉表中不直接依赖于候选码的非主属性</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193726860.png" alt="500"></p>
<p>Sno→Sdept  Sdept → Sno  Sdept→Sloc 可得： Sno→Sloc，即 S-L 中存在非主属性对码的传递函数依赖，S-L ∉ 3NF</p>
<p>采用投影分解法，把 S-L 分解为两个关系模式，以消除传递函数依赖：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193735197.png" alt="500"></p>
<h4 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h4><p>通常认为 BCNF 是修正的第三范式，有时也称为扩充的第三范式。</p>
<p>一个满足 BCNF 的关系模式有：</p>
<ul>
<li>所有非主属性都完全函数依赖于每个候选码</li>
<li>所有的主属性都完全函数依赖于每个不包含它的候选码</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性</li>
</ul>
<p>BCNF 范式排除了：</p>
<ul>
<li>任何属性 (包括主属性和非主属性) 对候选码的部分依赖和传递依赖；</li>
<li>主属性之间的传递依赖。</li>
</ul>
<p>例子：</p>
<p>关系模式 STJ(S,T,J) 中，S 表示学生，T 表示教师，J 表示课程。每一教师只教一门课，</p>
<p>每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。</p>
<p>由语义可得到函数依赖：(S,J)→T；(S,T)→J；T→J</p>
<p>因为没有任何非主属性对码传递依赖或部分依赖，</p>
<p>STJ ∈ 3NF。</p>
<p>因为 T 是决定因素，而 T 不包含码，所以 STJ 不属于 BCNF 关系。</p>
<p>候选码可以有多个，如上面（S,J）和（S,T）都是候选码，包含在任一一个候选码中的属性称为主属性，那么 S,J,T 都是主属性, 以上不满足 “所有的主属性都完全函数依赖于每个不包含它的候选码”，是否可以直接理解为决定因素必须为候选码中的一个？</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img data-src="https://img-blog.csdnimg.cn/20190629193928110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="第-7-章-数据库设计"><a href="#第-7-章-数据库设计" class="headerlink" title="第 7 章 数据库设计"></a>第 7 章 数据库设计</h2><p>数据库设计可以分为以下 6 个阶段：</p>
<ol>
<li>需求分析：准确了解和分析用户需求（包括数据和处理）</li>
<li>概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体 DBMS 的概念模型</li>
<li>逻辑结构设计：将概念结构转换为某个 DBMS 所支持的数据模型，并对其进行优化</li>
<li>物理结构设计：为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）</li>
<li>数据库实施：根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库并试运行</li>
<li>数据库运行和维护：在数据库投入正式使用后不断地对其进行评价、调整与修改</li>
</ol>
<p>其具体要做的事情如下图：</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629193947799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong>数据流图表达了数据和处理的关系，数据字典是系统中各类数据描述的集合</strong></p>
<p>数据字典通常包括数据项、数据结构、数据流、数据存储、处理过程 5 个部分</p>
<ol>
<li><p>数据项：数据项描述 = {数据项名，数据项含义说明，别名，数据类型，取值范围……}</p>
</li>
<li><p>数据结构：数据结构反映了数据之间的组合关系。数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}</p>
</li>
<li><p>数据流：数据流是数据结构在系统内传输的路径。数据流描述 = {数据流名，数据流来源，数据流去向，平均流量，高峰期流量，组成：{数据结构}}</p>
</li>
<li><p>数据存储：数据存储是数据结构停留或保存的地方。数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}</p>
</li>
<li><p>处理过程：处理过程的具体处理逻辑一般用判定表或判定树来描述。处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}} 概念结构设计</p>
</li>
</ol>
<p>需求分析阶段完成数据字典（用于表示收集到的数据）和一组数据流程图（Data Flow Diagram，DFD）</p>
<h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><p>设计概念结构通常有四类方法</p>
<p>自顶向下：即首先定义全局概念结构的框架，然后逐步细化</p>
<p>自底向上：即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构</p>
<p>逐步扩张：首先定义最重要的核心概念结构，然后向外扩充</p>
<p>混合策略：即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。</p>
<h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>E-R 图如何转换为关系模型？</p>
<p>（1）一个 1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的码；如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。（联系本身的属性？）</p>
<p>（2）一个 1：n 联系可以转换为一个独立的关系模式，<strong>也可以与 n 端对应的关系模式合并</strong>。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为 n 端实体的码</p>
<p>（3）一个 m：n 联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分</p>
<p><strong>数据模型的优化</strong></p>
<p>数据库逻辑设计的结果不是唯一的。关系数据模型的优化通常以规范化理论为指导。</p>
<p>具体如下：确定数据依赖、分析各关系模式属于第几范式，并不是规范化程度越高的关系就越优，这需要考虑具体情况；</p>
<p>对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率。常用的两种分解方法为水平分解和垂直分解。</p>
<p>水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系</p>
<p>垂直分解：把关系的属性分解为若干个子集合，形成若干子关系模式</p>
<p><strong>设计用户子模式</strong></p>
<p>如果某些局部应用经常要使用某些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图，用户每次只对定义好的视图进行查询即可。</p>
<h3 id="数据库的运行与维护"><a href="#数据库的运行与维护" class="headerlink" title="数据库的运行与维护"></a>数据库的运行与维护</h3><p>从以下几个角度考虑：</p>
<ol>
<li><p>数据库的转储和恢复</p>
</li>
<li><p>数据库的安全性、完整性控制</p>
</li>
<li><p>数据库性能的监督、分析和改造</p>
</li>
<li><p>数据库的重组织和重构造</p>
</li>
</ol>
<h2 id="第-9-章-关系查询处理和查询优化"><a href="#第-9-章-关系查询处理和查询优化" class="headerlink" title="第 9 章 关系查询处理和查询优化"></a>第 9 章 关系查询处理和查询优化</h2><h3 id="查询处理步骤"><a href="#查询处理步骤" class="headerlink" title="查询处理步骤"></a>查询处理步骤</h3><p>RDBMS 查询处理可分为 4 个阶段：查询分析、查询检查、查询优化和查询执行</p>
<p>查询分析：对查询语句进行扫描、词法和语法分析，判断是否符合 SQL 语法规则。</p>
<p>查询检查：根据数据字典对合法的查询语句进行语义检查</p>
<p>查询优化：从多种可供选择的执行策略中选择一个高效执行的查询处理策略</p>
<p>查询执行：代码生成器生成执行这个查询计划的代码</p>
<p><strong>实现查询操作的算法示例</strong></p>
<p>一、选择操作的实现</p>
<ol>
<li><p>简单的全表扫描方法：对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件</p>
</li>
<li><p>索引（或散列）扫描方法：如果选择条件的属性上有索引（如 B + 树索引或 Hash 索引），可以用索引扫描方法，通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组</p>
</li>
</ol>
<p>二、连接操作的实现</p>
<p>例：SELECT * FROM Student, SC WHERE Student.Sno = SC.Sno;</p>
<p><strong>1. 嵌套循环方法（nested loop）</strong>：对外层循环 (Student) 的每一个元组，检索内层循环 (SC) 中的每一个元组，并检查这两个元组在连接属性 (sno) 上是否相等</p>
<p><strong>2. 排序 - 合并方法（sort-merge join 或 merge join）</strong>：尤其适合连接的表已排好序的情况</p>
<p>步骤如下：</p>
<p>①如果连接的表没有排好序，首先对 Student 表和 SC 表按连接属性 Sno 排序</p>
<p>②取 Student 表中第一个 Sno，依次扫描 SC 表中具有相同 Sno 的元组，把它们连接起来</p>
<p>③当扫描到 Sno 不相同的第一个 SC 元组时，返回 Student 表扫描它的下一个元组，再扫描 SC 表中具有相同 Sno 的元组，把它们连接起来。</p>
<p>④重复以上步骤直到 Student 表扫描完</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194126274.png" alt=""></p>
<p><strong>3. 索引连接方法（index join）</strong>：如果内层循环的连接属性上有索引，对于外层关系 r 的每一个元组 tr，利用索引来搜索内层关系 s 中与元组 tr 满足连接条件的元组 。</p>
<p>步骤：</p>
<p>① 在 SC 表上已经建立属性 Sno 的索引。</p>
<p>② 对 Student 中每一个元组，由 Sno 值通过 SC 的索引查找 相应的 SC 元组。</p>
<p>③ 把这些 SC 元组和 Student 元组连接起来 循环执行②③，直到 Student 表中的元组处理完</p>
<p><strong>4.Hash Join 方法</strong></p>
<p>把连接属性作为 hash 码，用同一个 hash 函数把 Student 表和 SC 表中的元组散列到 hash 表中。</p>
<p>划分阶段 (building phase, 也称为 partitioning phase)：</p>
<p>对包含较少元组的表 (如 Student 表) 进行一遍处理把它的元组按 hash 函数分散到 hash 表的桶中</p>
<p>试探阶段 (probing phase, 也称为连接阶段 join phase)</p>
<p>对另一个表 (SC 表) 进行一遍处理</p>
<p>把 SC 表的元组也按同一个 hash 函数（hash 码是连接属性）进行散列</p>
<p>把 SC 元组与桶中来自 Student 表并与之相匹配的元组连接起来</p>
<h3 id="查询优化策略"><a href="#查询优化策略" class="headerlink" title="查询优化策略"></a>查询优化策略</h3><p>查询优化的优点：用户不必考虑如何最好地表达查询以获得较好的效率，系统可以比用户程序的 “优化” 做得更好</p>
<ol>
<li>优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。</li>
<li>如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，而重写程序在实际应用中往往是不太可能的。</li>
<li>优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。</li>
<li>优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动 优化相当于使得所有人都拥有这些优化技术。</li>
</ol>
<h4 id="代数优化"><a href="#代数优化" class="headerlink" title="代数优化"></a>代数优化</h4><p>基于关系代数等价变换规则的优化方法，称为代数优化</p>
<p>①XXX 结合律、交换律……</p>
<p>②查询树的启发式优化</p>
<p>关系代数表达式<strong>典型的启发式规则</strong>有：</p>
<ol>
<li><p>选择运算应尽可能先做。这在优化策略中是最重要、最基本的一条，因为选择运算一般使计算的中间结果大大变小？？？</p>
</li>
<li><p>把投影运算和选择运算同时进行</p>
</li>
<li><p>把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系</p>
</li>
<li><p>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算</p>
</li>
<li><p>找出公共子表达式</p>
</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194144928.png" alt=""></p>
<h4 id="理优化"><a href="#理优化" class="headerlink" title="理优化"></a>理优化</h4><p>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。</p>
<p>选择的方法可以是：</p>
<p>①基于规则的启发式优化：如对于用 OR 连接的析取选择条件，一般使用全表顺序扫描；如果 2 个表都已经按照连接属性排序，则选用排序 - 合并方法等。</p>
<p>②基于代价估算的优化：对各算法通过代价估算公式计算代价选择最优解</p>
<p>③两者结合的优化方法</p>
<p>基于启发式规则的存取路径选择优化</p>
<p><strong>一、选择操作的启发式规则</strong></p>
<ol>
<li><p>对于小关系，使用全表顺序扫描，即使选择列上有索引</p>
</li>
<li><p>对于选择条件是主码 = 值 的查询，查询结果最多是一个元组，可以选择主码索引</p>
</li>
<li><p>对于选择条件是非主属性 = 值的查询，并且选择列上有索引，则要估算查询结果的元组数目，如果比例较小（&lt; 10%）可以使用索引扫描，否则还是使用全表顺序扫描</p>
</li>
<li><p>对于选择条件是属性上的非等值查询或范围查询，并且选择列上有索引，同样要估算查询结果的元组数目。</p>
</li>
<li><p>对于用 AND 连接的合取选择条件，如果有涉及这些属性的组合索引，则优先采用组合索引扫描方法；如果某些属性上有一般的索引？否则使用全表顺序扫描</p>
</li>
<li><p>对于用 OR 连接的析取选择条件，一般使用全表顺序扫描</p>
</li>
</ol>
<p><strong>二、连接操作的启发式规则</strong></p>
<ol>
<li><p>如果 2 个表都已经按照连接属性排序，则选用排序 - 合并方法</p>
</li>
<li><p>如果一个表在连接属性上有索引，则可以选用索引连接方法</p>
</li>
<li><p>如果上面 2 个规则都不适用，其中一个表较小，可以选用 Hash Join</p>
</li>
<li><p>最后可选用循环嵌套，选择其中较小的表作为外表</p>
</li>
</ol>
<h2 id="第-10-章-数据库恢复技术"><a href="#第-10-章-数据库恢复技术" class="headerlink" title="第 10 章 数据库恢复技术"></a>第 10 章 数据库恢复技术</h2><p>尽管数据库系统中采取了各种保护措施来防止数据库的安全性和完整性被破坏以及并发事务的正确执行，但某些故障仍然不可避免，会导致数据库中部分数据的丢失甚至破坏数据库，数据库恢复就是为了将数据库从错误状态恢复到某一已知的正确状态。</p>
<h3 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h3><p>事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。例如在关系数据库中，一个事务可以是一条 SQL 语句、一组 SQL 语句。</p>
<p>事务通常是以 BEGIN TRANSACTION 开始，以 COMMIT 或 ROLLBACK 结束。COMMIT 表示提交，ROLLBACK 表示回滚，在事务运行的过程中发生某种故障事务不能继续执行，系统就会将事务对数据库的已完成操作全部撤销，从而回滚到事务开始时的状态。</p>
<p><strong>事务的特性：</strong></p>
<p>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability），简称 ACID</p>
<ol>
<li><p>原子性：事务是数据库的逻辑工作单位，事务中包括的操作要么都做，要么都不做</p>
</li>
<li><p>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。事务执行过程中出现故障则称这时的数据库处于不一致性状态。</p>
</li>
<li><p>隔离性：一个事务的执行不能被其他事务干扰，并发执行的各个事务之间不能互相干扰</p>
</li>
<li><p>持续性（永久性）：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</p>
</li>
</ol>
<p>事务的 ACID 特性可能遭到破坏的因素有：</p>
<p>(1) 多个事务并行运行时，不同事务的操作交叉执行</p>
<p>(2) 事务在运行过程中被强制停止</p>
<h3 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h3><ol>
<li><p>事务内部的故障：</p>
</li>
<li><p>系统故障：如操作系统故障，CPU 故障，系统断电</p>
</li>
<li><p>介质故障：如磁盘损坏、磁头碰撞、瞬时强磁场干扰等</p>
</li>
<li><p>计算机病毒</p>
</li>
</ol>
<h3 id="恢复的实现技术及策略"><a href="#恢复的实现技术及策略" class="headerlink" title="恢复的实现技术及策略"></a>恢复的实现技术及策略</h3><h4 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h4><p>转储即 DBA 定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据称为后被副本。</p>
<p>转储又分为<strong>静态转储</strong>和<strong>动态转储</strong>：静态转储必须等待正在运行的用户事务结束才能进行；动态转储是指转储期间允许对数据库进行存取或修改，即转储和用户事务可以并发执行。</p>
<p>也可分为<strong>海量转储</strong>和<strong>增量转储</strong>：海量转储即每次转储全部数据库，增量转储即每次只转储上一次转储后更新的数据。</p>
<h4 id="登记日志文件（Logging）"><a href="#登记日志文件（Logging）" class="headerlink" title="登记日志文件（Logging）"></a>登记日志文件（Logging）</h4><p>日志文件是用来记录事务对数据库的更新操作的文件。不同数据库系统采用的日志文件格式并不完全一样，主要有两种格式：<strong>以记录为单位的日志文件</strong>和<strong>以数据块为单位的日志文件</strong></p>
<p>对以记录为单位的日志文件，日志文件中需要登记的内容包括：</p>
<ul>
<li>各个事务的开始（BEGIN TRANSACTION）标记</li>
<li>各个事务的结束（COMMIT 或 ROLLBACK）标记</li>
<li>各个事务的所有更新操作</li>
</ul>
<p>以上每一条内容记为一个日志记录（log record）</p>
<p>每个日志记录的内容主要包括：</p>
<ul>
<li>事务标识（标明是哪个事务）</li>
<li>操作的类型（插入、删除或修改）</li>
<li>操作对象（记录内部标识）</li>
<li>更新前数据的旧值（对插入操作而言，此项为空值）</li>
<li>更新后数据的新值（对删除操作而言，此项为空值）</li>
</ul>
<p>对以数据块为单位的日志文件，日志记录的内容包括事务标识和被更新的数据块。由于将更新前的整个块和更新后的整个块都放入日志文件中，操作的类型和操作对象等信息就不必放入日志记录中了。</p>
<p><strong>日志文件的作用：</strong></p>
<p>日志文件用于事务故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复</p>
<p>具体作用如下：</p>
<ol>
<li>事务故障恢复和系统故障恢复必须用日志文件。</li>
<li>在动态转储方式中必须建立日志文件，备份副本和日志文件结合起来才能有效地恢复数据库。</li>
<li>在静态转储方式中，也可以建立日志文件。</li>
</ol>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194208616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p><strong>登记日志文件</strong></p>
<p>为保证数据库是可恢复的，登记日志文件时必须遵循两条规则：</p>
<p>(1) 登记的次序严格按并发事务执行的时间次序</p>
<p>(2) 必须先写日志文件，后写数据库</p>
<p>如果先写了数据库修改，但是没有登记这个日志，那么中途运行故障就无法恢复这个修改了。</p>
<h4 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h4><p>REDO：重做，正向扫描日志文件，对每个 REDO 事务重新执行日志文件登记的操作</p>
<p>UDNO：撤销，反向扫描日志文件，对每个 UNDO 事务的更新操作执行逆操作</p>
<p>COMMIT：提交，将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束</p>
<p>ROLLBACK：回滚，事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成操作全部撤销，回滚到事务开始时的状态</p>
<p><strong>事务故障的恢复：</strong></p>
<p>（1）反向扫描日志文件（即从最后向前扫描日志文件），查找该事务的更新操作</p>
<p>（2）对该事务的更新操作执行逆操作。（来得及或者未来得及写入数据库都没关系）</p>
<p>（3）继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理</p>
<p>（4）如此继续，直到读到该事务的开始标记</p>
<p><strong>系统故障的恢复：</strong></p>
<p>（1）正向扫描日志文件，找出在故障发生前已经提交的事务（这些事务既有 BEGIN TRANSACTION 记录，也有 COMMIT 记录），将其事务标记记入 REDO 队列；同时找出故障发生时尚未完成的事务（这些事务只有 BEGIN TRANSACTION 记录，无相应的 COMMIT 记录），将其事务标记记入 UNDO 队列</p>
<p>（2）对撤销队列中的各个事务执行 UNDO 操作</p>
<p>（3）对重做队列中的各个事务执行 REDO 操作</p>
<p>为什么要 REDO？考虑已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库（磁盘）。</p>
<p><strong>介质故障的恢复：</strong></p>
<p>（1）装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态</p>
<p>（2）装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务，即扫描日志文件找出需要重做和撤销的事务</p>
<h4 id="具有检查点的恢复技术"><a href="#具有检查点的恢复技术" class="headerlink" title="具有检查点的恢复技术"></a>具有检查点的恢复技术</h4><p><img data-src="https://img-blog.csdnimg.cn/20190629194229242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>在故障发生时还未完成的事务需要撤销，在检查点和故障点之间完成的事务需要重做，因为它们对数据库所做的修改在故障发生时可能还在缓冲区中。</p>
<h2 id="第-11-章-并发控制概述"><a href="#第-11-章-并发控制概述" class="headerlink" title="第 11 章 并发控制概述"></a>第 11 章 并发控制概述</h2><p>并发控制概述：事务是并发控制的基本单位，并发控制用于保证事务的隔离性和一致性。</p>
<p>事务读数据 x 一般记为 R(x)，写数据 x 一般记为 W(x)</p>
<p>如果不对并发操作进行正确调度，可能导致数据的不一致性问题，主要包括丢失修改、不可重复读和读 “脏” 数据。</p>
<ol>
<li><p>丢失修改：两个事务读入同一数据并修改，其中一个事务的修改会丢失</p>
</li>
<li><p>不可读重复：事务 T1 读取数据后，T2 执行更新操作，使 T1 无法再现前一次读取结果</p>
</li>
<li><p>读脏数据：“脏”数据指事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1 由于某种原因被撤销，则 T2 读取到的数据就为 “脏” 数据，即不正确的数据。</p>
</li>
</ol>
<h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><p>封锁即事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其他的事务不能更新此数据对象。</p>
<p>排它锁（写锁，X 锁）：若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。这就保证了其他事务在 T 释放 A 上的锁前不能再读取和修改 A</p>
<p>共享锁（读锁，S 锁）：若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁而不能加 X 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改</p>
<h3 id="活锁和死锁"><a href="#活锁和死锁" class="headerlink" title="活锁和死锁"></a>活锁和死锁</h3><p>活锁即一个事务可能永远等待（系统总是先批准其他事务的锁请求），可以采用先来先服务的策略解决。</p>
<p>死锁即两个事务互相申请对方锁住的资源导致两个事务永远不能结束。</p>
<p><strong>预防策略：</strong></p>
<p>(1) 一次性封锁法：一次性封锁发要求每个事务必须一次将所有要使用的数据全部加锁</p>
<pre><code>   缺点：势必扩大封锁的范围，从而降低了系统的并发度；
</code></pre><p>(2) 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</p>
<pre><code>   缺点；难以事先确定封锁顺序
</code></pre><p><strong>死锁解除策略：</strong></p>
<p>(1) 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁；</p>
<pre><code>   缺点：可能误判死锁，事务因为其他原因使等待时间超过时限；若时限设置得太长，死锁发生后不能及时发现
</code></pre><p>(2) 等待图法：并发控制子系统周期性地生成事务等待图，并进行检测，如果发现图中存在回路，则发生了死锁。</p>
<p>如果检测到死锁，一般采用的方法是选择一个处理死锁代价较小的事务，将其撤销，释放此事务持有的所有的锁，之后对撤销的事务所执行的数据修改操作必须加以恢复。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194256202.png" alt=""></p>
<h3 id="并发调度的可串行性"><a href="#并发调度的可串行性" class="headerlink" title="并发调度的可串行性"></a>并发调度的可串行性</h3><p>定义：多个事务的并发执行是正确的，当<strong>且仅当其结果与按某一次序串行地执行这些事务时的结果相同</strong>，称这种调度策略为可串行化的调度。</p>
<p>可串行性（Serializability）是并发事务正确调度的准则，按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</p>
<p><strong>冲突可串行化调度</strong></p>
<p>冲突操作是指不同的事务对同一个数据的读写操作和写写操作：</p>
<p>Ri (x) 与 Wj(x) /<em> 事务 Ti 读 x，Tj 写 x，其中 i≠j</em>/</p>
<p>Wi(x) 与 Wj(x) /<em> 事务 Ti 写 x，Tj 写 x，其中 i≠j</em>/</p>
<p>不能交换 (Swap) 的动作：</p>
<ul>
<li>同一事务的两个操作</li>
<li>不同事务的冲突操作</li>
</ul>
<p>一个调度 Sc 在<strong>保证冲突操作的次序不变</strong>的情况下，通过<strong>交换两个事务不冲突操作的次序</strong>得到 另一个调度 Sc’ ，如果 Sc’是串行的，称调度 Sc 为<strong>冲突可串行化的调度</strong></p>
<p>一个调度时冲突可串行化的，那么它一定是可串行化的调度，因此，可以用这种方法来判断一个调度是否是冲突可串行化的。</p>
<p>冲突可串行化调度是可串行化调度的<strong>充分条件</strong>，不是必要条件，还有不满足冲突可串行化条</p>
<p>件的可串行化调度</p>
<p>Sc1=r1(A)w1(A)r2(A)w2(A)r1(B)w1(B)r2(B)w2(B)</p>
<p>把 w2(A) 与 r1(B)w1(B) 交换，得到：</p>
<p>r1(A)w1(A)r2(A)r1(B)w1(B)w2(A)r2(B)w2(B)</p>
<p>再把 r2(A) 与 r1(B)w1(B) 交换：</p>
<p>Sc2＝r1(A)w1(A)r1(B)w1(B)r2(A)w2(A)r2(B)w2(B)</p>
<p>Sc2 等价于一个串行调度 T1，T2，Sc1 冲突可串行化的调度</p>
<h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p><strong>封锁协议（Locking Protocol）</strong>即对数据对象加锁时约定的一些规则，如何时申请封锁、持锁时间、何时释放锁等。两段锁协议是最常用的一种封锁协议，使用两段锁协议产生的是可串行化调度（充分条件）。</p>
<p>两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁</p>
<p>(1) 在对任何数据进行读、写操作之前，首先要申请并获取对该数据的封锁</p>
<p>(2) 在释放一个封锁之后，事务不得再申请和获得任何其他封锁</p>
<p>简单来说，申请锁和释放锁必须是连续的</p>
<p>例：</p>
<p>事务 T1 遵守两段锁协议，其封锁序列是：</p>
<p>Slock A Slock B Xlock C Unlock B Unlock A Unlock C；</p>
<p>l← 扩展阶段 →l l← 收缩阶段 →l</p>
<p>事务 T2 不遵守两段锁协议，其封锁序列是：</p>
<p>Slock A Unlock A Slock B Xlock C Unlock C Unlock B</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><ol>
<li><p>关系代数中的等值连接操作是由选择和笛卡尔积这两个操作组成的</p>
</li>
<li><p>事务日志一般用于保存对数据的更新操作</p>
</li>
<li><p>设有一个关系：DEPT(DNO,DNAME)，如果要找出倒数第三个字母为 W，并且至少包含 4 个字母的 DNAME，则查询条件子句应写成 WHERE DNAME LIKE （B）</p>
</li>
</ol>
<p><code>（A）&#39;_ _W_%&#39; （B） &#39;_%W_ _&#39; （C） &#39;_W_ _&#39; （D） &#39;_W_%&#39;</code></p>
<p>PS：</p>
<p>‘_’匹配单个任意字符，’%’匹配 0 个或多个任意字符, ‘[]’匹配括号内所列字符中的一个, ‘<sup><a href="#fn_" id="reffn_"></a></sup>’匹配不在括号内所列字符中的单个字符</p>
<p>4、以下（D ）不属于实现数据库系统安全性的主要技术和方法。</p>
<p>（A）存取控制技术 （B）视图技术 （C）审计技术 （D）并发控制技术</p>
<p>PS：</p>
<p>实现数据库安全性的技术和方法有多种，如存取控制技术、视图技术和审计技术</p>
<p>并发控制技术用于保证事务的隔离性和一致性</p>
<p>5、有两个关系 R（A，B，C）和 S（B，C，D），则 R÷S 结果的属性个数是（C ）。</p>
<p>（A）3 （B）2 （C）1 （D）不一定</p>
<p>6、设 U 是所有属性的集合，X、Y、Z 都是 U 的子集，且 Z＝U－X－Y。下面关于多值依赖的叙述中，不正确的是（？？？ ）。</p>
<p>（A）若 X→→Y，则 X→→Z （B）若 X→Y，则 X→→Y （C）若 X→→Y，且 Y′∈Y，则 X→→Y′ （D）若 Z＝Φ，则 X→→Y</p>
<p>[解析] 多值依赖的性质包括：</p>
<p>（1）多值依赖具有对称性 即若 X→→Y，则 X→→Z，其中 Z＝U－X－Y</p>
<p>（2）多值依赖具有传递性 即若 X→→Y，Y→→Z， 则 X→→Z –Y</p>
<p>（3）函数依赖是多值依赖的特殊情况。 即若 X→Y，则 X→→Y。</p>
<p>（4）若 X→→Y，X→→Z，则 X→→YZ。</p>
<p>（5）若 X→→Y，X→→Z，则 X→→Y∩Z。</p>
<p>（6）若 X→→Y，X→→Z，则 X→→Y-Z，X→→Z-Y。</p>
<p>多值依赖的定义：设 R(U) 是一个属性集 U 上的一个关系模式， X、 Y 和 Z 是 U 的子集，并且 Z＝U－X－Y。关系模式 R(U) 中多值依赖 X→→Y（Y 多值依赖于 X）成立， 当且仅当对 R(U) 的任一关系 r，给定的一对（x，z）值，有一 组 Y 的值，这组值仅仅决定于 x 值而与 z 值无关</p>
<p>7、现有一个关系：借阅（书号、书名，库存数，读者号，借期，还期），假如同一本书允许一个读者多次借阅，但不能同时对一种书借多本。则该关系模式的码是（C ）。</p>
<p>（A）书号 （B）读者号 （C）书号 + 读者号 （D）书号 + 读者号 + 借期</p>
<p>9、设有关系 R（A，B，C）的值如下：</p>
<table border="1" cellspacing="0"><tbody><tr><td><p>A</p></td><td><p>B</p></td><td><p>C</p></td></tr><tr><td><p>2</p></td><td><p>2</p></td><td><p>3</p></td></tr><tr><td><p>2</p></td><td><p>3</p></td><td><p>4</p></td></tr><tr><td><p>3</p></td><td><p>3</p></td><td><p>5</p></td></tr></tbody></table>

<p>下列叙述正确的是（B）</p>
<p>A．函数依赖 A→B 在上述关系中成立 B．函数依赖 BC→A 在上述关系中成立</p>
<p>C．函数依赖 B→A 在上述关系中成立 D．函数依赖 A→BC 在上述关系中成立</p>
<p>【解析】：判断一个函数依赖是否成立即对每个决定因素（左边的）其右边的值唯一</p>
<p>10、设有事务 T1 和 T2，其并发操作顺序如下图所示，该并发操作带来的问题是:（A）</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194359393.png" alt=""></p>
<p>A. 丢失更新 B. 读 “脏数据” C. 事务不能提交 D. 不能重复读</p>
<p>11、关系代数表达式的优化策略中，首先要做的是（B）</p>
<p>（A）对文件进行预处理 （B）尽早执行选择运算 （C）尽早执行笛卡尔积运算 （D）尽早执行投影运算</p>
<p>12、在 DB 的三级模式中，外模式（D ）。</p>
<p>（A）只有一个 （B）不能有多个 （C）至多一个 （D）可以有多个</p>
<p>13、在 SELECT 语句中，需对分组情况满足的条件进行判断时，应使用（ D）。</p>
<p>（A）WHERE （B）GROUP BY （C）GROUP CONDITION （D）HAVING</p>
<p>14、若两个实体间的关系是 1:m，则进行逻辑设计时实现 1:m 联系的方法是（ A）</p>
<p>（A）在 “m” 端实体转换的关系中加入 “1” 端实体转换的关系的码</p>
<p>（B）将 “m” 端实体转换的关系的码加入 “1” 端实体转换的关系中</p>
<p>（C）在两个实体转换的关系中，分别加入另外一个关系的码</p>
<p>（D）将两个实体转换成一个关系</p>
<p>【解析】：考察 E-R 图转换为关系模式，1：n 关系可以独自成一个表，也可以与 n 端关系模式合并</p>
<p>其规则如下：注意联系独自成表（关系模式）时合并的是实体的码（而不是所有属性）</p>
<p>（1）一个 1:1 联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的码；如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。（联系本身的属性？）</p>
<p>（2）一个 1：n 联系可以转换为一个独立的关系模式，<strong>也可以与 n 端对应的关系模式合并</strong>。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为 n 端实体的码</p>
<p>（3）一个 m：n 联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，各实体的码组成关系的码或关系码的一部分</p>
<p>15、若数据库中只包含成功事务提交的结果，则此数据库处于（<strong>B</strong> ）状态。</p>
<p>（A）安全 （B）一致 （C）不安全 （D）不一致</p>
<p>16、关系数据库的规范化理论主要解决的问题是（<strong>A</strong>）</p>
<p>（A）如何构造合适的数据逻辑结构 （B）如何构造合适的数据物理结构 （C）如何构造合适的应用程序 （D）如何控制不同用的操作权限</p>
<p>【解析】：概念结构是画 E-R 图，逻辑结构是建表，物理结构是选择存储结构和存取方法等</p>
<p>规范化理论是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决数据冗余、插入异常、更新异常、删除异常这些问题。说白了就是改造表。</p>
<p>17、DBMS 普遍采用（ <strong>C</strong>）方法来保证调度的正确性。</p>
<p>（A）索引 （B）授权 （C） 封锁 （D） 日志</p>
<p>18、X→Ai 成立（i=l，2，…，k）是 X→A1 A2…Ak 成立的（<strong>C</strong> ）。</p>
<p>（A）充分条件 （B）必要条件 （C）充要条件 （D）既不充分也不必要</p>
<p>19、在进行授权时，数据对象的（<strong>A</strong> ），授权子系统就越灵活。</p>
<p>（A）粒度越小 （B）粒度越大（C）约束越细（D）约束越粗</p>
<p>【解析】：粒度？约束？粒度理解为范围？如数据库、表、表操作等；约束理解为规定的细致与否？</p>
<p>20、数据库的概念模型独立于（ <strong>A</strong>）。</p>
<p>（A）具体的机器和 DBMS （B）E-R 图 （C）信息世界 （D）现实世界</p>
<p>22、如果一个关系 R 中的属性全部都是主属性，则 R 至少可以达到（<strong>B</strong> ）。</p>
<p>（A）2NF （B）3NF （C）BCNF （D）4NF</p>
<p>【解析】一个全部是主属性的关系必然不会有非主属性部分或者传递依赖的问题，故至少是 3NF。但此关系无法保证每一个非平凡的多值依赖或者函数依赖都包含码，所以 R 的最高范式至少是 3NF。</p>
<p>23、在 E-R 模型中，如果有 3 个不同的实体集，3 个多对多的联系， 则应转换为（<strong>B</strong> ）个关系模式。</p>
<p>（A）3 （B）6 （C）9 （D）4</p>
<p>24、关于死锁，下列说法正确的是（ <strong>D</strong>）</p>
<p>（A）死锁是操作系统中的问题，数据库中不存在</p>
<p>（B）数据库中防止死锁的方法是禁止两个用户同时访问数据库</p>
<p>（C）当两个用户竞争相同的资源时不会发生死锁</p>
<p>（D）只有出现并发操作时，才有可能出现死锁</p>
<p>25、写一个修改到数据库中，与写一个表示这个修改的记录到日志文件中的操作，应该（ <strong>C</strong>）。 （A）前者先做 （B）由程序员安排 （C）后者先做 （D）由系统决定哪一个先做</p>
<p>26、在第一个事务以 S 封锁方式读数据 A 时，第二个事务对数据 A 的读取 方式会遭到失败的是（<strong>A</strong> ）。</p>
<p>（A）实现 X 封锁的读 （B）实现 S 封锁的读 （C）不加锁的读 （D）实现意向共享锁的读</p>
<p>27、视图建立后，在数据字典中存放的是（ <strong>C</strong>）。</p>
<p>（A）查询语句 （B）组成视图的表的内容 （C）视图的定义 （D）视图对应的表的定义</p>
<h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><p>1、什么是视图？使用视图有什么好处？</p>
<p>【答】： 视图是从一个或几个基本表（或视图）导出的表，数据库只存放视图的定义而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中数据发生变化，从视图查询出的数据也会随之改变。</p>
<p>视图的作用：</p>
<p>①简化用户的操作：用户所做的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无须了解。</p>
<p>②使用户能以多种角度来看待同一数据：当许多不同种类的用户共享同一个数据库时，这种灵活性是非常有必要的。</p>
<p>③对重构数据库提供了一定的逻辑独立性：即使重构数据库也不一定需要修改应用程序。</p>
<p>④能够对机密数据提供安全保护：只允许用户查询提供给他的视图而不是直接查询表，可以隐藏表中的机密数据</p>
<p>⑤适当的利用视图可以更清晰地表达查询语句：利用视图来表达查询语句</p>
<p>2、发生介质故障时，应该如何恢复数据库？</p>
<p>【答】：（1）装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态</p>
<p>（2）装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务，即扫描日志文件找出需要重做和撤销的事务</p>
<p>3、什么是数据库的审计？它有什么作用？</p>
<p>【答】：数据库的审计即每当用户对数据库执行操作（CRUD）时就在审计文件中增加一条记录（包含谁执行了什么操作），启用一个专用的审计日志（Audit Log），将用户对数据库的所有操作记录在上面；</p>
<p>审计的作用：</p>
<p>(1) 保证数据库的安全性，数据库管理员可以根据审计文件观察是否有人执行了不安全的操作。审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容</p>
<p>(2) 利于查错，可以通过观察执行了哪些操作来找出错误的来源</p>
<ul>
<li>审计很费时间和空间</li>
<li>DBA 可以根据应用对安全性的要求，灵活地打开或关闭审计功能</li>
<li>审计功能主要用于安全性要求较高的部门</li>
</ul>
<p>4、什么是数据库中的事务？它有哪些特性？这些特性的含义是什么</p>
<p>【答】：事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。例如在关系数据库中，一个事务可以是一条 SQL 语句、一组 SQL 语句。</p>
<p>事务的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability），简称 ACID</p>
<ol>
<li><p>原子性：事务是数据库的逻辑工作单位，事务中包括的操作要么都做，要么都不做</p>
</li>
<li><p>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。事务执行过程中出现故障则称这时的数据库处于不一致性状态。</p>
</li>
<li><p>隔离性：一个事务的执行不能被其他事务干扰，并发执行的各个事务之间不能互相干扰</p>
</li>
<li><p>持续性（永久性）：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</p>
</li>
</ol>
<p>5、如何判断一个关系是否属于第三范式？</p>
<p>【答】：判断一个关系是否属于第三范式首先判断它是否属于第二范式，即非主属性是否部分依赖于码，如果属于第二范式再看非主属性是否传递依赖于码，如果两个都是否，则该关系属于第三范式。（1NF：每个属性对应的值域都是不可分的）；另外，如果该关系为全码，则它肯定属于第三范式</p>
<p>6、在数据库设计时，什么是数据字典？数据字典中通常有哪些内容？</p>
<p>【答】：<strong>数据流图表达了数据和处理的关系，数据字典是系统中各类数据描述的集合</strong></p>
<p>数据字典通常包括数据项、数据结构、数据流、数据存储、处理过程 5 个部分</p>
<p>①数据项：数据项描述 = {数据项名，数据项含义说明，别名，数据类型，取值范围……}</p>
<p>②数据结构：数据结构反映了数据之间的组合关系。数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}</p>
<p>③数据流：数据流是数据结构在系统内传输的路径。数据流描述 = {数据流名，数据流来源，数据流去向，平均流量，高峰期流量，组成：{数据结构}}</p>
<p>④数据存储：数据存储是数据结构停留或保存的地方。数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}</p>
<p>⑤处理过程：处理过程的具体处理逻辑一般用判定表或判定树来描述。处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}} 概念结构设计</p>
<p>7、在数据库的查询优化中，什么是代数优化？什么是物理优化？</p>
<p>【答】：代数优化即通过一些定律或启发式规则对关系代数操作（选择、投影、连接等）做替换（顺序）、合并等从而达到优化的效果；物理优化即通过使用合适的存储方式及存取方法来实现优化（如选择操作是使用全表扫描还是索引扫描，连接操作是使用嵌套循环还是排序 - 合并方法等）</p>
<p>基于关系代数等价变换规则的优化方法，称为代数优化</p>
<p>物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标</p>
<p>8、在基于检查点的数据库恢复技术中，检查点记录的内容应该包括哪些？</p>
<p>【答】：检查点记录的内容包括</p>
<p>①建立检查点时刻所有正在执行的事务清单</p>
<p>②这些事务最近一个日志记录的地址</p>
<p>9、什么是数据库中的死锁？如何解决死锁问题</p>
<p>【答】：死锁即两个事务互相申请对方锁住的资源导致两个事务永远不能结束</p>
<p>解决死锁有以下方案：</p>
<p>(1) 一次性封锁法：一次性封锁发要求每个事务必须一次将所有要使用的数据全部加锁</p>
<pre><code>   缺点：势必扩大封锁的范围，从而降低了系统的并发度；
</code></pre><p>(2) 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</p>
<pre><code>   缺点；难以事先确定封锁顺序
</code></pre><p>10、举例说明连接操作的排序 - 合并实现方法</p>
<p>【答】：假设有两个表 Student 表和 SC 表，其有相同属性列 Sno 表示学生学号</p>
<p>步骤如下：</p>
<p>①如果连接的表没有排好序，首先对 Student 表和 SC 表按连接属性 Sno 排序</p>
<p>②取 Student 表中第一个 Sno，依次扫描 SC 表中具有相同 Sno 的元组，把它们连接起来</p>
<p>③当扫描到 Sno 不相同的第一个 SC 元组时，返回 Student 表扫描它的下一个元组，再扫描 SC 表中具有相同 Sno 的元组，把它们连接起来。</p>
<p>④重复以上步骤直到 Student 表扫描完</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194655241.png" alt=""></p>
<p>11、在学习了关系数据库以后，你觉得它主要的好处是什么？它又有哪些缺陷导致它无法胜任某些应用？</p>
<p>【答】：好处：①对现实事务中的关系描述很清晰 ②数据定义语言和数据操作语言语义化程度较好 ③便于数据库设计的规范化</p>
<ol>
<li>保持数据的一致性；</li>
<li>由于以标准为前提，数据更新的开销小（相同的字段基本都是只有一处）；</li>
<li>存在很多实际成果和专业技术信息（成熟的技术）；</li>
<li>容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</li>
<li>使用方便：通用的 SQL 语言使得操作关系型数据库非常方便，可以进行 join 等复杂查询。</li>
</ol>
<p>缺陷：</p>
<ol>
<li>为了维护一致性所付出的巨大代价就是其读写性能比较差；</li>
<li>当有数据更新的表做索引或对表结构进行变更时，性能差；</li>
<li>对简单查询需要快速返回结果的处理；</li>
<li>高并发读写需求；</li>
<li>当字段不固定时，关系型数据库处理起来很麻烦；</li>
<li>进行大量数据的写入处理时。</li>
</ol>
<h3 id="应用题"><a href="#应用题" class="headerlink" title="应用题"></a>应用题</h3><p>设有关系模式如下：S(Sno, Sname, Age, Sex), SC(Sno, Cno, Grade), C(Cno, Cname, Teacher)。其中 S 表示学生，C 表示课程，SC 表示 选课。Sno 代表学号，Sname 代表学生姓名，Age 代表学生年龄， Sex 代表学生性别，Cno 代表课程号，Grade 代表成绩，Cname 代 表课程名，Teacher 代表任课教师姓名。用 SQL 语句完成：（共 10 分）</p>
<p>1、查询平均成绩大于 85 分的学生的姓名及其平均成绩（5 分）。</p>
<p>2、把三个表的查询和插入权限授予用户张明，并允许张明进一步 把这些权限授予其他用户（5 分）。</p>
<p>【解析】：</p>
<p>1.</p>
<p>SELECT Sname, AVG(Grade) FROM</p>
<p>(SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade</p>
<p>FROM Student, SC</p>
<p>WHERE Student.Sno = SC.Sno); /<em> 自然连接 </em>/</p>
<p>GROUP BY Sname HAVING AVG(Grade) &gt; 85</p>
<ol>
<li>授权</li>
</ol>
<p>GRANT SELECT, INSERT</p>
<p>ON TABLE S,SC,C</p>
<p>TO ZHANGMING</p>
<p>WITH GRANT OPTION</p>
<p>2、设关系模式 R（A，B，C，D，E），F 是 R 上成立的依赖集，F={AB→C，BC→A，AC →B，D→E}，试写出 R 的所有候选码，并说明理由。</p>
<p>【解析】：（A,B,D）（A,C,D）（B,C,D）</p>
<p>3、设有关系 R(W, X, Y, Z)，依赖关系 F={X→Z，WX→Y}，判断该关系模式符合第几范式，并说明理由。</p>
<p>【解析】：因为其存在非主属性部分依赖于码</p>
<p><img data-src="https://img-blog.csdnimg.cn/2019062919484538.png" alt=""></p>
<p>，所以其符合第一范式</p>
<p>4、在数据库系统中有如下一个调度 S，它涉及到 5 个不同的事务 T1、T2、T3、T4 和 T5。 判断调度 S 是否为冲突可串行化。如果调度 S 是冲突可串行化的，就请给出与之等价的一 个串行调度序列。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194912297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>【解析】：目前的调度为</p>
<p>S = r2(A) r1(Q) r5(C) w1(Q) r4(A) w2(Q) w1(B) r3(Q) r3(M) r4(Q) r4(M) r5(M) w5(M)</p>
<p>冲突操作是指不同的事务对同一个数据的读写操作和写写操作：</p>
<p>Ri (x) 与 Wj(x) /<em> 事务 Ti 读 x，Tj 写 x，其中 i≠j</em>/</p>
<p>Wi(x) 与 Wj(x) /<em> 事务 Ti 写 x，Tj 写 x，其中 i≠j</em>/</p>
<p>不能交换 (Swap) 的动作：</p>
<ul>
<li>同一事务的两个操作</li>
<li>不同事务的冲突操作</li>
</ul>
<p>S 能否交换为一个串行化的调度？</p>
<p>其可以交换为 T1T2T3T4T5（具体过程略）</p>
<p>序列：r1(Q)w1(Q)w1(B)………</p>
<p>6、在查询优化的代数优化方法中，你认为哪条启发式规则是最重要的？为什么？请举例 说明。</p>
<p>【解析】：选择运算应尽可能先做。这在优化策略中是最重要、最基本的一条，因为选择运算一般使计算的中间结果大大变小</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190629194956602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjA1NzA4,size_16,color_FFFFFF,t_70" alt=""></p>
<p>如图，先选择之后再做连接操作可以减小数据量</p>
<p>SELECT Sname FROM Student, SC</p>
<p>WHERE Student.Sno = SC.Sno AND Cno = ‘2’</p>
<p>原址链接 <a href="https://blog.csdn.net/qq_37205708/article/details/94194465?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">https://blog.csdn.net/qq_37205708/article/details/94194465?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p>
]]></content>
  </entry>
  <entry>
    <title>概念</title>
    <url>/posts/0/</url>
    <content><![CDATA[<h2 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点 :"></a>数据库系统的特点 :</h2><p>（1）数据结构化。<br>（2）数据共享性高、冗余少且易扩充。<br>（3）数据独立性高。<br>（4）数据由 DBMS 统一管理和控制。</p>
<h2 id="数据库的应用"><a href="#数据库的应用" class="headerlink" title="数据库的应用"></a>数据库的应用</h2><ul>
<li>管理信息系统</li>
<li>数据挖掘</li>
<li>决策支持系统</li>
<li>大数据</li>
</ul>
<h2 id="关系模型中有三类完整性约束-："><a href="#关系模型中有三类完整性约束-：" class="headerlink" title="关系模型中有三类完整性约束 ："></a>关系模型中有三类完整性约束 ：</h2><p>实体完整性（Entity Integrity）：关系模型以主码作为唯一性标识，主码中的属性即主属性不能取空值<br>参照完整性（Referential Integrity）：外码<br>用户自定义完整性（User-defined Integrity）：反映某一具体应用所涉及的数据必须满足的语义要求</p>
<p>数据定义语言（DDL）<br>数据查询语言(DQL)<br>数据操纵语言（DML）<br>数据库控制语言（DCL）</p>
<p>一个1:1的联系转换为一个关系，相连实体的关键字都是关系的候选关键字： 一个 1: n 的联系转换为一个关系，多方实体的关键字是关系的关键字；一个 n: m 的联系转换为一个关系，相连实体的关键字的组合组成关系的关键字 (复合关键字)。</p>
<h2 id="锁？"><a href="#锁？" class="headerlink" title="锁？"></a>锁？</h2><p>S 是共享锁，X 是排他锁。<br>如果对一个事物加了 X 锁，则不能加任何锁。<br>如果对一个事物加了 S 锁，则只能加 S 锁不能加 X 锁。</p>
<h2 id="脏数据，丢失修改？"><a href="#脏数据，丢失修改？" class="headerlink" title="脏数据，丢失修改？"></a>脏数据，丢失修改？</h2><p>（1）丢失修改</p>
<pre><code>    当两个或多个事物读入同一数据并修改，会发生丢失更新问题，即后一个事物更新的结果被前一事务所做更新覆盖 即当事务A和B同事进行时，事务A对数据已经改变但并未提交时B又对同一数据进行了修改（注意此时数据是A还未提交改变的数据），到时A做的数据改动丢失了
</code></pre><p>（2）不可重复读</p>
<pre><code>  当两个数据读取某个数据后，另一事务执行了对该数据的更新，当前一事务再次读取该数据（希望与第一次读取的是相同的值）时，得到的数据与前一次的不一样，这是由于第一次读取数据后，事务B对其做了修改，导致再次读取数据时与第一次读取的数据不想同
</code></pre><p>（3）读‘脏数据’</p>
<pre><code> 当一个事务修改某个数据后，另一事务对该数据进行了读取，由于某种原因前一事务撤销了对改数据的修改，即将修改过的数据恢复原值，那么后一事务读到的数据与数据可得不一致，称之为读脏数据
</code></pre><p>注意：还有一个叫“幽灵数据”  幽灵数据与脏数据类似，不过幽灵数据是指事务提交之后读到的数据，但是在读取之后又进行了对前一事务的恢复，而脏数据是指并未提交前读取的数据</p>
<h2 id="E-R-图合并冲突"><a href="#E-R-图合并冲突" class="headerlink" title="E-R 图合并冲突"></a>E-R 图合并冲突</h2><h3 id="一、属性冲突"><a href="#一、属性冲突" class="headerlink" title="一、属性冲突"></a>一、属性冲突</h3><p>①属性域冲突: 不同的子 E-R 图中，同一属性的数据类型、取值范围或者取值集合不同。<br>②属性单位冲突: 不同的子 E-R 图中，同一属性的单位不同，如一个是厘米，一个是米。</p>
<h3 id="二、命名冲突"><a href="#二、命名冲突" class="headerlink" title="二、命名冲突:"></a>二、命名冲突:</h3><p>①同名异义: 不同的子 E-R 图中具有相同的属性（对象）名，但是意义不一样。<br>②异名同义: 不同的子 E-R 图中，不同的属性（对象）名具有相同的意义。</p>
<h3 id="三、结构冲突"><a href="#三、结构冲突" class="headerlink" title="三、结构冲突:"></a>三、结构冲突:</h3><p>①同一对象在不同的子 E-R 图中具有不同的抽象，如其中一个是实体，一个是属性。解决方法是把实体变属性或者属性变成实体。<br>②同一实体在不同的子 E-R 图中具有不同的属性列，或者属性列顺序不同。解决方案是两个实体取并集。<br>③实体间的联系在不同的子 E-R 图中具有不同的类型，如 E 1，E 2 在这里是一对一关系，而在另外一个子 E-R 图中是一对多关。解决方法是根据语义进行综合调整。</p>
<h2 id="NOSQL-数据库"><a href="#NOSQL-数据库" class="headerlink" title="NOSQL 数据库"></a>NOSQL 数据库</h2><ul>
<li>键值 (Key-Value)数据库(Riak、Redis、Memcached、Amazon’s Dynamo、Project Voldemort)</li>
<li>面向文档(Document-Oriented)数据库(MongoDB、CouchDB、RavenDB)</li>
<li>列存储 (Wide Column Store/Column-Family)数据库(Cassandra、HBase)</li>
<li>图 (Graph-Oriented)数据库(Neo 4 J、Infinite Graph、OrientDB)<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2>关系代数的连接=笛卡尔乘积+选择<br>![[../../../../images/Z-attachment/Pasted image 20231229215627.png]]</li>
</ul>
<h2 id="数据独立性-："><a href="#数据独立性-：" class="headerlink" title="数据独立性 ："></a>数据独立性 ：</h2><p>数据独立性是数据与程序间的互不依赖性, 即数据库中数据独立于应用程序而不依赖于应用程序。也就是说, 数据的逻辑结构、存储结构与存取方式的改变不会影响应用程序</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>解决并发操作带来的数据不一致问题普遍采用【封锁】技术。<br>为了防止一个用户的工作不适当地影响另一个用户，应该采取【并发控制】<br>下列不属于并发操作带来的问题是【死锁】<br>DBMS 普遍采用【封锁】方法来保证调度的正确性<br>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放，这是【一级封锁协议】<br>如果事务 T 获得了数据项 Q 上的排他锁，则 T 对 Q【既可读又可写】<br>设事务 T 1 和 T 2，对数据库中地数据 A 进行操作，可能有如下几种情况，请问哪一种不会发生冲突操作【T 1 正在读 A，T 2 也要读 A】<br>如果有两个事务，同时对数据库中同一数据进行操作，不会引起冲突的操作是【两个都是 SELECT】<br>在数据库系统中，死锁属于【事务故障】</p>
<p>FULL JOIN 不等价于 CROSS JOIN。<br>CROSS JOIN 是对两个表进行笛卡尔积，返回所有可能的组合。<br>FULL JOIN 是将两个表中的所有记录都组合起来，没有匹配的记录则用 NULL 填充。</p>
<h2 id="SQL-——T-SQL"><a href="#SQL-——T-SQL" class="headerlink" title="SQL ——T-SQL"></a>SQL ——T-SQL</h2><p>![[../../../../images/Z-attachment/6c3d656f5eb640521af8fc151959f57b.png]]</p>
<h2 id="E-R-图"><a href="#E-R-图" class="headerlink" title="E-R 图"></a>E-R 图</h2><p>![[../../../../images/Z-attachment/Pasted image 20231230213933.png]]</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络复习</title>
    <url>/posts/2f0367e4/</url>
    <content><![CDATA[<p><meta name="referrer" content="no-referrer"/><br><a href="https://www.kdocs.cn/l/cdL7LN7LgIx2">计算机网络知识汇总（超详细整理）</a> docs 文档<br><a href="https://img-blog.csdnimg.cn/20210705160715108.png">思维导图</a></p>
<p><img data-src="https://img-blog.csdnimg.cn/20210705160715108.png" alt="思维导图"></p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>当谈到不同的计算机网络系统时有</p>
<ul>
<li>PAN（个人局域网）personal Area Network</li>
<li>LAN（局域网）Local</li>
<li>MAN（城域网）Metropolitan</li>
<li>WAN（广域网）wide</li>
</ul>
<p>一些协议：</p>
<ul>
<li>SMTP（Simple Mail Transfer Protocol）：SMTP 是一种用于在网络上发送和接收电子邮件的通信协议。它定义了邮件传输的规则和格式，确保电子邮件能够准确地发送到收件人的电子邮箱服务器。</li>
<li>FTP（File Transfer Protocol）：FTP 是一种用于在网络上传输文件的标准协议。它允许用户从一个计算机向另一个计算机传输文件，可以用于上传、下载或管理文件，是一个在 Internet 上常见的文件传输方式。</li>
<li>SNMP（Simple Network Management Protocol）：SNMP 是一种用于网络设备管理的标准协议，它允许网络管理系统收集信息、监控和修改网络设备的行为。通过 SNMP，网络管理员可以远程监视设备的运行状态、收集性能数据以及对设备进行配置变更。</li>
<li>HTTP（Hypertext Transfer Protocol）：HTTP 是用于在网络上传输超文本的协议。它是 Web 服务器和客户端之间进行通信的基础，用于在浏览器和服务器之间传递网页、图像、视频或其他内容，是 World Wide Web 的核心协议。</li>
</ul>
<h2 id="杂项-："><a href="#杂项-：" class="headerlink" title="杂项 ："></a>杂项 ：</h2><ul>
<li>$Mb,Gb,Kb$ 单位换算的问题</li>
<li>集线器工作在物理层</li>
<li>交换机属于数据链路层，网桥工作在数据链路层</li>
<li>已知 10 BaseT 以太网的争用期时间片为 51.2µs，若网卡在发送某帧时发生了连续 4 次冲突，则基于二进制指数避退算法确定的再次尝试重发该帧前等待的最长时间是（   ($2^n-1$) $\times T$）µs。</li>
<li>CSMA/CD 协议与 CSMA/CA 协议</li>
<li>假设一个采用 CSMA/CD 协议的 100 Mpbs 局域网，最小帧长是 128 B，则在一个冲突域内两个站点之间的单向传播时延最大是（  ($\frac{128\times8bit}{100Mb}=10.24us$)/2 ）µs。</li>
<li>==时延的计算==</li>
<li>==差错检测==：若甲向乙发送数据时采用 CRC 校验，生成多项式为 G (x)=X^4+X+1 (即 G (x)=10011)，则乙收到下列比特串时，可以断定在其传输过程中未发生错误的是（     ）。<br>A. 1 0111 1100<br>B. 1 0111 0100<br>C. 1 0111 0000<br>D. 1 0111 1000</li>
<li>以太网帧的最大长度是 (1518 )字节,最小长度是 (64 )字节。</li>
<li>若两台主机在同一子网中, 则两台主机的 IP 地址分别与它们的子网掩码相“与”的结果一定相同</li>
<li>信息传输的基本单元是数据分组</li>
<li>A (0-127), B (128-191), C (192-255) 类地址, 其中哪些地址不能使用？<ul>
<li>0.0.0.0</li>
<li>127.0.0.0</li>
<li>255.255.255.255</li>
</ul>
</li>
<li>ARP 协议的功能是(根据 IP 地址查询 MAC 地址)</li>
<li>==路由器下一跳的问题==，得到的网络与子网掩码相与，看与目的网络是否相同。</li>
<li>基于距离向量的路由协议是 RIP</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>期末复习</title>
    <url>/posts/0/</url>
    <content><![CDATA[<p>![[../../../../images/Z-attachment/Pasted image 20231207110155.png]]<br>![[../../../../images/Z-attachment/Pasted image 20231207110533.png]]<br>![[../../../../images/Z-attachment/Pasted image 20231207110935.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207111215.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207111646.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207112515.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207113518.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207114447.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207114823.png]]<br>![[../../../../images/Z-attachment/Pasted image 20231207114852.png]]</p>
<h2 id="1-信号量机制"><a href="#1-信号量机制" class="headerlink" title="1 信号量机制"></a>1 信号量机制</h2><p>![[../../../../images/Z-attachment/Pasted image 20231207115257.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207120324.png]]</p>
<h3 id="1-1-生产者-消费者"><a href="#1-1-生产者-消费者" class="headerlink" title="1.1 生产者 -消费者"></a>1.1 生产者 -消费者</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207121244.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207122315.png]]</p>
<h3 id="1-2-吸烟者问题"><a href="#1-2-吸烟者问题" class="headerlink" title="1.2 吸烟者问题"></a>1.2 吸烟者问题</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207122846.png]]</p>
<h3 id="1-3-读者-——写者问题"><a href="#1-3-读者-——写者问题" class="headerlink" title="1.3 读者 ——写者问题"></a>1.3 读者 ——写者问题</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207131617.png]]</p>
<h3 id="1-4-哲学家就餐问题"><a href="#1-4-哲学家就餐问题" class="headerlink" title="1.4 哲学家就餐问题"></a>1.4 哲学家就餐问题</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207133957.png]]</p>
<h2 id="2-死锁"><a href="#2-死锁" class="headerlink" title="2 死锁"></a>2 死锁</h2><p>![[../../../../images/Z-attachment/Pasted image 20231207135211.png]]</p>
<h3 id="2-1-死锁产生的条件"><a href="#2-1-死锁产生的条件" class="headerlink" title="2.1 死锁产生的条件"></a>2.1 死锁产生的条件</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207135737.png]]</p>
<h3 id="2-2-死锁的概念"><a href="#2-2-死锁的概念" class="headerlink" title="2.2 死锁的概念"></a>2.2 死锁的概念</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207135917.png]]</p>
<h3 id="2-3-死锁处理策略"><a href="#2-3-死锁处理策略" class="headerlink" title="2.3 死锁处理策略"></a>2.3 死锁处理策略</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207140018.png]]</p>
<h3 id="2-4-银行家算法"><a href="#2-4-银行家算法" class="headerlink" title="2.4 银行家算法"></a>2.4 银行家算法</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207141435.png]]</p>
<h3 id="2-5-死锁的检测和解除"><a href="#2-5-死锁的检测和解除" class="headerlink" title="2.5 死锁的检测和解除"></a>2.5 死锁的检测和解除</h3><p>![[../../../../images/Z-attachment/Pasted image 20231207141856.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207142026.png]]</p>
<h2 id="3-动态分区分配算法"><a href="#3-动态分区分配算法" class="headerlink" title="3 动态分区分配算法"></a>3 动态分区分配算法</h2><p>![[../../../../images/Z-attachment/Pasted image 20231207144733.png]]</p>
<p>![[../../../../images/Z-attachment/Pasted image 20231207160336.png]]</p>
]]></content>
  </entry>
  <entry>
    <title>复习</title>
    <url>/posts/0/</url>
    <content><![CDATA[<p><a href="https://www.kdocs.cn/l/cdL7LN7LgIx2">计算机网络知识汇总（超详细整理）</a> docs 文档</p>
<p>思维导图<br><img data-src="https://img-blog.csdnimg.cn/20210705160715108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70" alt="100"></p>
]]></content>
  </entry>
  <entry>
    <title>337</title>
    <url>/posts/95ba42e4/</url>
    <content><![CDATA[<p><meta name="referrer" content="no-referrer"/><br>又被打爆了 $\dots$<br>补题!</p>
<h2 id="C-Lining-Up-2"><a href="#C-Lining-Up-2" class="headerlink" title="C - Lining Up 2"></a>C - Lining Up 2</h2><p>给出一个数组 $a$，其中</p>
<ul>
<li>$a_{i}=-1$,则 ${i}$ 在最前面</li>
<li>$a<em>{i}\neq-1$,则 $i$ 的前面是 $a</em>{i}$</li>
</ul>
<p>输出从前到后的数字。</p>
<p>我连 ABC C 题都写不出了 $\dots$ 我的水平退化挺严重的，或者是说根本就没有水平过 $\dots$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>暴力是 $n^2$ 过不了。</p>
<p>因此我就想通过 <code>upper_bound</code> 直接来找到相应的索引并输出，但是发现排序后的数组的索引就变化了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first;</span><br><span class="line">        a[i].second = i;</span><br><span class="line">        <span class="keyword">if</span> (a[i].first == <span class="number">-1</span>)</span><br><span class="line">            head = i, cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="built_in">make_pair</span>(head, <span class="number">-1</span>)) - a.<span class="built_in">begin</span>();</span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>, head = j;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>水平太低导致的🤣</p>
<p>官方题解：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(N, N)</span></span>; <span class="comment">// B[i] 表示人 i 的下一个人（如果不存在则为 N）</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> A;</span><br><span class="line">        cin &gt;&gt; A;</span><br><span class="line">        --A; <span class="comment">// 将其转换为从0开始编号</span></span><br><span class="line">        <span class="keyword">if</span> (A &lt; <span class="number">0</span>)<span class="comment">//A==-2</span></span><br><span class="line">            front = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            B[A] = i; <span class="comment">// 第 i 个人的前一个是 A ⇔ A 的后一个人是 i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front &lt; N)</span><br><span class="line">    &#123; <span class="comment">// 直到达到 N（= 没有下一个人）为止一直重复向后移动。</span></span><br><span class="line">        cout &lt;&lt; front + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        front = B[front];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="D-Cheating-Gomoku-Narabe"><a href="#D-Cheating-Gomoku-Narabe" class="headerlink" title="D - Cheating Gomoku Narabe"></a>D - Cheating Gomoku Narabe</h2><p>(待更 $\dots$)</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>334</title>
    <url>/posts/cb3135e/</url>
    <content><![CDATA[<h2 id="B-Christmas-Trees"><a href="#B-Christmas-Trees" class="headerlink" title="B-Christmas Trees"></a>B-Christmas Trees</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有一条向东西两侧无限延伸的道路，从这条道路上的某一参考点向东 $x$ 米处的点的<strong>坐标</strong>定义为 $x$。其中，从参考点向西 $x$ 米处的一点的坐标为 $-x$。</p>
<p>斯努克将从坐标为 $A$ 的点开始，以 $M$ 米的间隔在路上的各点摆放圣诞树。换句话说，他将在每一个可以用某个整数 $k$ 表示为 $A+kM$ 的点上摆放一棵圣诞树。</p>
<p>高桥和青木分别站在坐标为 $L$ 和 $R$ 的点上。$(L\leq R)$。求在高桥和青木之间（包括他们所站的点）将会有多少棵圣诞树。</p>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul>
<li>$-10^{18}\leq A \leq 10^{18}$</li>
<li>$1\leq M \leq 10^9$</li>
<li>$-10^{18}\leq L\leq R \leq 10^{18}$</li>
<li>All input values are integers.<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3>$\boxed{\begin{align}&amp;A&amp;M&amp;&amp;L&amp;&amp;R\end{align}}$<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3>打印将在高桥和青木之间设置的圣诞树数量（包括他们所站的位置）。<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3 -1 6</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3>首先，让我们通过从 $L$ 和 $R$ 中减去 $A$ 来简化问题，这样圣诞树就站在坐标的倍数上。</li>
</ul>
<p>设 $k$ 为站在坐标 $kM$ 处的树的索引。设 $l$ 为站在严格小于 $L$ 的坐标处的最东边的树的索引，</p>
<p>而 $r$ 则是站在坐标小于或等于 $R$ 的最东边的树的索引。那么答案就是 $r-l$。</p>
<p>现在剩下的是找到站在小于或等于 $x$ 的坐标处的最东边的树的索引，对于某个 $x$；这简单地表示为 $\lfloor\frac{x}{M}\rfloor$。请注意，当 $x$ 为负数时，根据编程语言的不同，找到 $\lfloor\frac{x}{M}\rfloor$ 的方法也有所不同。（例如，在 C++中，你不能简单地写 <code>x/M</code>。）此外，通过对浮点数进行求值以获得实数然后进行取下限可能会因为精度误差而导致错误的值，所以请小心。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><code>ans=(R - A - ((R - A) % M + M) % M) / M - (L - 1 - A - ((L - 1 - A) % M + M) % M) / M</code><br>官方题解是<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function">ll <span class="title">floor</span><span class="params">(ll x, ll m)</span> </span>&#123;</span><br><span class="line">    ll r = (x % m + m) % m;</span><br><span class="line">    <span class="keyword">return</span> (x - r) / m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, m, l, r;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; m &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    l -= a, r -= a;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">floor</span>(r, m) - <span class="built_in">floor</span>(l - <span class="number">1</span>, m) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="C-Socks-2"><a href="#C-Socks-2" class="headerlink" title="C-Socks 2"></a>C-Socks 2</h2><h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p>高桥有 $N$ 双袜子，其中 $i$ 双由两只颜色为 $i$ 的袜子组成。一天，高桥在整理抽屉时发现自己丢失了 $A_1, A_2, \dots, A_K$ 种颜色的袜子各一只，于是他决定用剩下的 $2N-K$ 只袜子做 $\lfloor\frac{2N-K}{2}\rfloor$ 双新袜子，每双由两只袜子组成。一双颜色为 $i$ 的袜子和一双颜色为 $j$ 的袜子的<strong>怪异度</strong>定义为 $|i-j|$，高桥希望将总怪异度最小化。</p>
<p>求用剩下的袜子做成 $\lfloor\frac{2N-K}{2}\rfloor$ 对时，总奇异度的最小值。请注意，如果 $2N-K$ 是奇数，那么将有一只袜子不包含在任何一对袜子中。</p>
<h3 id="Constraints-1"><a href="#Constraints-1" class="headerlink" title="Constraints"></a>Constraints</h3><ul>
<li>$1\leq K\leq N \leq 2\times 10^5$</li>
<li>$1\leq A_1 &lt; A_2 &lt; \dots &lt; A_K \leq N$</li>
<li>All input values are integers.<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3>$\boxed{\begin{align}&amp;N\ \ \ \ \ \ K\&amp;A<em>{1}\ \ \ \ A</em>{2}&amp;\dots A_{K}\end{align}}$<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3>将最小总怪异度打印为整数。<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample  Output"></a>Sample  Output</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3>下面，让 $(i,j)$ 表示一对颜色为 $i$ 的袜子和一对颜色为 $j$ 的袜子。<br>颜色为 $1, 2, 3, 4$ 的袜子分别有 $1, 2, 1, 2$ 只。创建 $(1,2),(2,3),(4,4)$ 这对袜子后，总奇异度为 $|1-2|+|2-3|+|4-4|=2$，即最小奇异度。</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>首先，最优的方案是匹配他没有丢失的袜子。</p>
<blockquote>
<p>[!success]- 证明<br>对于他没有使用过的颜色 $p$，考虑一个情况，其中两只颜色为 $p$ 的袜子没有配对。当它们和颜色为 $A_i$ 和 $A_j$ 的袜子一起时，根据三角不等式 $|A_i-A_p| + |A_j-A_p| \geq |A_i-A_j| = |A_i-A_j| + |A_p-A_p|$，所以通过将 $(A_p,A_p)$ 和 $(A_i,A_j)$ 配对，而不是 $(A_p,A_i),(A_p,A_j)$，总的奇异度不会增加。当一个颜色为 $p$ 的袜子没有与任何袜子配对，而另一个袜子配对的颜色是另一个颜色 $A_i$ 时，总的奇异度不会增加，通过将 $(A_p, A_p)$ 配对，而不是将 $(A_p, A_i)$ 配对后留下 $A_p$ 未配对。因此，我们可以假设两只颜色为 $A_p$ 的袜子会在最优解中始终配对。</p>
</blockquote>
<p>因此，这个问题可以被看作是一个问题，要求从颜色 $A_1,A_2,\dots,A_K$ 中的每一个颜色中挑选一只袜子，制造 $\lfloor \frac{K}{2} \rfloor$ 对袜子。</p>
<p>如果 $K$ 是偶数，最优的配对方式似乎是配对 $(A<em>1,A_2),(A_3,A_4),\dots,(A</em>{K-1},A_K)$，这是确实的情况。</p>
<blockquote>
<p>[!success]- 证明<br>我们通过归纳进行证明。只要证明在最优解中颜色 $A_1$ 总是与颜色 $A_2$ 配对。</p>
<p>我们通过反证法证明上面的结论。在一个最优解中，假设颜色 $A_1$ 与颜色 $A_i\ (i &gt; 2)$ 配对，并且颜色 $A_2$ 与颜色 $A_j$ 配对。那么由于 $A_1 &lt; A_2 &lt; A_i, A_j$，我们有 $|A_i-A_1| + |A_j-A_2| &gt; |A_2-A_1| + |A_j-A_i|$，所以将 $(A_1,A_2)$ 和 $(A_i,A_j)$ 配对，而不是配对 $(A_1,A_i)$ 和 $(A_2,A_j)$ 会减小总的奇异度，这违反了最优性。</p>
</blockquote>
<p>当 $K$ 是奇数时，问题就出现了。在这种情况下，我们可以在剩下的袜子中暴力解决唯一没有配对的颜色的问题，最优的方法可以像我们处理偶数 $K$ 一样找到。当剩下的袜子配对时，最小的总奇异度可以在 $O(N)$ 的时间内找到，但这导致了 $O(N^2)$ 的复杂度。而实际上，我们可以预先计算当前几只袜子配对时的总的奇异度，例如 $\mathrm{presum}[2]=(A_2-A_1),\mathrm{presum}[4]= (A_4-A_3)+(A_2-A_1), \mathrm{presum}[6]=(A_6-A_5)+(A_4-A_3)+(A_2-A_1),\dots$，以类似前缀和的方式。同样，可以找到“后缀和”。因此，通过这种方法，问题可以在总共 $O(N)$ 的时间内解决。</p>
<p>额外信息：当 $K$ 是奇数时，相比于对每只未配对的袜子暴力尝试，我们可以只尝试 $A_1,A_3,A_5,\dots,A_K$（证明省略）。在下面的示例代码中，我们采用了这种方法来简化实现。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>需要计算前缀(pre)和后缀(suf)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i: a) cin &gt;&gt; i;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(k + <span class="number">1</span>)</span>, <span class="title">suf</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) pre[i] += a[i - <span class="number">1</span>] - a[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        suf[i] = suf[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ((k - i) % <span class="number">2</span> == <span class="number">0</span>) suf[i] += a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i += <span class="number">2</span>) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, pre[i] + suf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>abc</category>
      </categories>
      <tags>
        <tag>补题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第 1 章（概述） - 简书</title>
    <url>/posts/10aba81c/</url>
    <content><![CDATA[<p><meta name="referrer" content="no-referrer"/><br><a href="https://www.jianshu.com/c/f627e74e6ff3">计算机网络整理笔记 - 专题 - 简书</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1c4411d7jb">计算机网络微课堂</a>的笔记整理<br>笔记也放到了<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FBloothOfYouth%2FComputer-Network-Notes">我的 github</a> 和<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2FBloothOfYouth%2FComputer-Network-Notes">我的 gitee</a> 上</p>
<h1 id="图示说明"><a href="#图示说明" class="headerlink" title="图示说明"></a>图示说明</h1><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-e0e87b70819258a9.png" alt="100"></p>
<p>image-20201007143815954</p>
<p>代表着主机</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-0315bfe09f51c84e.png" alt="100"></p>
<p>image-20201007144130208</p>
<p>代表服务器</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-aede75c722baf2b9.png" alt="100"></p>
<p>image-20201007143904153</p>
<p>代表着路由器</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-36c5de5c08c1d8ea.png" alt="100"></p>
<p>image-20201007143936128</p>
<p>代表着网络</p>
<h1 id="1-1、计算机网络在信息时代的作用"><a href="#1-1、计算机网络在信息时代的作用" class="headerlink" title="1.1、计算机网络在信息时代的作用"></a>1.1、计算机网络在信息时代的作用</h1><ul>
<li><p>计算机网络已由一种<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></p>
</li>
<li><p>计算机网络已经像水，电，煤气这些基础设施一样，成为我们<strong>生活中不可或缺</strong>的一部分</p>
</li>
</ul>
<h2 id="1-我国互联网发展状况"><a href="#1-我国互联网发展状况" class="headerlink" title="1 我国互联网发展状况"></a>1 我国互联网发展状况</h2><p><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cnnic.net.cn">中国互联网络信息中心 CNNIC</a></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-762604e225775be9.png" alt=""></p>
<p>image-20201006160618748</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-67cef530fb12b5d9.png" alt=""></p>
<p>image-20201006160645887</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-dbf8fb050bcdbf8b.png" alt=""></p>
<p>image-20201006160715764</p>
<h1 id="1-2、因特网概述"><a href="#1-2、因特网概述" class="headerlink" title="1.2、因特网概述"></a>1.2、因特网概述</h1><h2 id="1-1、网络、互连网（互联网）和因特网"><a href="#1-1、网络、互连网（互联网）和因特网" class="headerlink" title="1 1、网络、互连网（互联网）和因特网"></a>1 1、网络、互连网（互联网）和因特网</h2><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-4fcd41d225b201be.png" alt=""></p>
<p>image-20201006163406232</p>
<p>互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为 “网络的网络（Network of Networks）”。</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-ff49fa2ef0245745.png" alt=""></p>
<p>image-20201006163857236</p>
<p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-ee181b01ca4c6f8e.png" alt=""></p>
<p>image-20201006164114523</p>
<p><strong>internet 与 Internet 的区别</strong></p>
<ul>
<li><p><strong>internet(互联网或互连网)</strong> 是一个通用名词，它泛指<strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</p>
</li>
<li><p><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用 TCP/IP 协议族作为通信的规则，其前身是美国的 ARPANET。</p>
</li>
</ul>
<p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网 (internet) ，而不是互联网 (Internet)。</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-cb6c0dd7a1f70e3e.png" alt=""></p>
<p>image-20201010233227407</p>
<h2 id="2-2、因特网发展的三个阶段"><a href="#2-2、因特网发展的三个阶段" class="headerlink" title="2 2、因特网发展的三个阶段"></a>2 2、因特网发展的三个阶段</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-0ee6522bfae940b5.png" alt=""></p>
<p>image-20201006164655173</p>
<p><strong>因特网服务提供者<code>ISP</code>(<code>I</code>nternet <code>S</code>ervice <code>P</code>rovider)</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-332e68bc46bc59ab.png" alt=""></p>
<p>image-20201006165117756</p>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过 ISP 接入因特网</strong></p>
<p>ISP 可以从因特网管理机构申请到成块的 IP 地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从 <strong>ISP 的得到所需要的 IP 地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有 IP 地址才能进行通信，这样就可以通过该 ISP 接入到因特网</strong></p>
<p><strong>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-ce38a42cfcab9872.png" alt=""></p>
<p>image-20201006165738879</p>
<p><strong>基于 ISP 的三层结构的因特网</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-1ccdf3defcff4ef1.png" alt=""></p>
<p>image-20201006170140504</p>
<p>一旦某个用户能够接入到因特网，那么他也可以成为一个 ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p>
<h2 id="3-3、因特网的标准化工作"><a href="#3-3、因特网的标准化工作" class="headerlink" title="3 3、因特网的标准化工作"></a>3 3、因特网的标准化工作</h2><ul>
<li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p>
</li>
<li><p>因特网在指定其标准上的一个很大的特点是<strong>面向公众。</strong></p>
<ul>
<li><p>因特网所有的 <strong>RFC</strong>(Request For Comments) 技术文档都可从因特网上免费下载；</p>
</li>
<li><p>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</p>
</li>
</ul>
</li>
<li><p><strong>因特网协会 ISOC</strong> 是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p>
<ul>
<li><p>因特网体系结构委员会 IAB，负责管理因特网有关协议的开发；</p>
</li>
<li><p>因特网工程部 IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</p>
</li>
<li><p>因特网研究部 IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</p>
</li>
</ul>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-92960e033eb18c8d.png" alt=""></p>
<p>image-20201006170959060</p>
<ul>
<li><p>制订因特网的正式标准要经过一下 <strong>4 个阶段</strong>：</p>
<p>1、因特网草案（在这个阶段还不是 RFC 文档）</p>
<p>2、建议标准（从这个阶段开始就成为 RFC 文档）</p>
<p>3、草案标准</p>
<p>4、因特网标准</p>
</li>
</ul>
<h2 id="4-4、因特网的组成"><a href="#4-4、因特网的组成" class="headerlink" title="4 4、因特网的组成"></a>4 4、因特网的组成</h2><ul>
<li><p>边缘部分</p>
<p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p>
</li>
<li><p>核心部分</p>
<p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-3065474a4377aff0.png" alt=""></p>
<p>image-20201006180725282</p>
<p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p>
<p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为<strong>端系统 (end system)</strong>。</p>
<p><strong>端系统在功能上可能有很大的差别：</strong></p>
<ol>
<li><p>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</p>
</li>
<li><p>大的端系统则可以是一台非常昂贵的大型计算机。</p>
</li>
<li><p>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP。</p>
</li>
</ol>
<h3 id="4-1-补充："><a href="#4-1-补充：" class="headerlink" title="4.1 补充："></a>4.1 补充：</h3><p><strong>端系统之间通信的含义</strong></p>
<p>“主机 A 和主机 B 进行通信” 实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即 “主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为 “计算机之间通信”。</strong></p>
<p>端系统之间的通信方式通常可划分为两大类：</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-4ee005d739f54581.png" alt=""></p>
<p>image-20201010234145371</p>
<p><strong>客户 - 服务器方式：</strong></p>
<ul>
<li><p>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</p>
</li>
<li><p>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</p>
</li>
<li><p>客户是服务的请求方，服务器是服务的提供方。</p>
</li>
</ul>
<p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p>
<p><strong>对等连接方式：</strong></p>
<ul>
<li><p><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</p>
</li>
<li><p>只要两个主机都运行了对等连接软件 (P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</p>
</li>
<li><p>双方都可以下载对方已经存储在硬盘中的共享文档。</p>
</li>
</ul>
<h1 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h1><p>网络核心部分是互联网中最复杂的部分。</p>
<p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p>
<p>在网络核心部分起特殊作用的是<strong>路由器</strong> (router)。</p>
<p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p>
<h2 id="1-1、电路交换（Circuit-Switching）"><a href="#1-1、电路交换（Circuit-Switching）" class="headerlink" title="1 1、电路交换（Circuit Switching）"></a>1 1、电路交换（Circuit Switching）</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-cbb94cf7d6bc6f8b.png" alt=""></p>
<p>image-20201006182240000</p>
<p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p>
<p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-7ad293b2ca19158b.png" alt=""></p>
<p>image-20201006182634249</p>
<ul>
<li><p>电话交换机接通电话线的方式称为电路交换；</p>
</li>
<li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p>
</li>
<li><p>电路交换的三个步骤：</p>
<p>1、建立连接（分配通信资源）</p>
<p>2、通话（一直占用通信资源）</p>
<p>3、释放连接（归还通信资源）</p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-acb87df045723236.png" alt=""></p>
<p>image-20201006183020317</p>
<p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p>
<p>这是因为计算机数据是突发式地出现在传输线路上的。</p>
<p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p>
<h2 id="2-2、分组交换（Packet-Switching）"><a href="#2-2、分组交换（Packet-Switching）" class="headerlink" title="2 2、分组交换（Packet Switching）"></a>2 2、分组交换（Packet Switching）</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-c57bf61052cb33f0.png" alt=""></p>
<p>image-20201006183312843</p>
<p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p>
<p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为 “包”，相应地，首部也可称为 “包头”。</p>
<p>首部包含了<strong>分组的目的地址</strong></p>
<p>分组从源主机到目的主机，可走不同的路径。</p>
<p>发送方</p>
<ul>
<li><p>构造分组</p>
</li>
<li><p>发送分组</p>
</li>
</ul>
<p>路由器</p>
<ul>
<li><p>缓存分组</p>
</li>
<li><p>转发分组</p>
</li>
<li><p>简称为 “分组转发”</p>
</li>
</ul>
<p>在路由器中的输入和输出端口之间没有直接连线。</p>
<p>路由器处理分组的过程是：</p>
<ol>
<li><p>把收到的分组先<strong>放入缓存（暂时存储）；</strong></p>
</li>
<li><p><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</p>
</li>
<li><p>把分组送到适当的端口<strong>转发</strong>出去。</p>
</li>
</ol>
<p>接收方</p>
<ul>
<li><p>接收分组</p>
</li>
<li><p>还原报文</p>
</li>
</ul>
<h2 id="3-3、报文交换（Message-Switching）"><a href="#3-3、报文交换（Message-Switching）" class="headerlink" title="3 3、报文交换（Message Switching）"></a>3 3、报文交换（Message Switching）</h2><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p>
<h2 id="4-三种交换方式的对比"><a href="#4-三种交换方式的对比" class="headerlink" title="4 三种交换方式的对比"></a>4 三种交换方式的对比</h2><p>假设 A，B，C，D 是分组传输路径所要经过的 4 个结点交换机，纵坐标为时间</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-e655a213714d1871.png" alt=""></p>
<p>image-20201006184451671</p>
<p>分析：</p>
<p>电路交换：</p>
<ul>
<li><p>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</p>
</li>
<li><p>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</p>
</li>
</ul>
<p>报文交换：</p>
<ul>
<li><p>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</p>
</li>
<li><p>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</p>
</li>
</ul>
<p>分组交换：</p>
<ul>
<li><p>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</p>
</li>
<li><p>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-c56f91f290cbc92b.png" alt=""></p>
<p>image-20201006185601460</p>
<h1 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h2><ul>
<li><p>计算机网络的精确定义并未统一</p>
</li>
<li><p>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。</p>
<ul>
<li><p>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</p>
</li>
<li><p>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</p>
</li>
<li><p>集合：是指至少需要两台计算机；</p>
</li>
</ul>
</li>
<li><p>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机 CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。</p>
<ul>
<li><p>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</p>
</li>
<li><p>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><p><strong>按交换技术分类：</strong></p>
<ul>
<li><p>电路交换网络</p>
</li>
<li><p>报文交换网络</p>
</li>
<li><p>分组交换网络</p>
</li>
</ul>
<p><strong>按使用者分类：</strong></p>
<ul>
<li><p>公用网</p>
</li>
<li><p>专用网</p>
</li>
</ul>
<p><strong>按传输介质分类：</strong></p>
<ul>
<li><p>有线网络</p>
</li>
<li><p>无线网络</p>
</li>
</ul>
<p><strong>按覆盖范围分类：</strong></p>
<ul>
<li>广域网 WAN（Wide Area Network）</li>
</ul>
<p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p>
<ul>
<li>城域网 MAN</li>
</ul>
<p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p>
<ul>
<li>局域网 LAN</li>
</ul>
<p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右）</p>
<ul>
<li>个域网 PAN</li>
</ul>
<p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p>
<p><strong>按拓扑结构分类：</strong></p>
<ul>
<li>总线型网络</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-4ed63e74d9ced719.png" alt=""></p>
<p>image-20201007005149993</p>
<ul>
<li>星型网络</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f6a1849bcc443935.png" alt=""></p>
<p>image-20201007005203129</p>
<ul>
<li>环形网络</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-ca133aaaf8fe8659.png" alt=""></p>
<p>image-20201007005212345</p>
<ul>
<li>网状型网络</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-d0d30cddc7356396.png" alt=""></p>
<p>image-20201007005249137</p>
<h1 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h1><h2 id="1-速率"><a href="#1-速率" class="headerlink" title="1 速率"></a>1 速率</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-ba6c4e627a62c05e.png" alt=""></p>
<p>image-20201007012419698</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-0c0d70a808407ca2.png" alt=""></p>
<p>image-20201007012439769</p>
<h2 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2 带宽"></a>2 带宽</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f4b18e0039f4a6c6.png" alt=""></p>
<p>image-20201007012943970</p>
<h2 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3 吞吐量"></a>3 吞吐量</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-0910421c209252b1.png" alt=""></p>
<p>image-20201007013119621</p>
<p>带宽 1 Gb/s 的以太网，代表其额定速率是 1 Gb/s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽 1 Gb/s 的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低。</p>
<p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p>
<h2 id="4-时延"><a href="#4-时延" class="headerlink" title="4 时延"></a>4 时延</h2><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p>
<p>网络时延由几部分组成：</p>
<ul>
<li>发送时延</li>
</ul>
<p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p>
<ul>
<li>传播时延</li>
</ul>
<p>电磁波在信道中传播一定的距离需要花费的时间。</p>
<ul>
<li>处理时延</li>
</ul>
<p>主机或路由器在收到分组时要花费一定时间进行处理</p>
<ul>
<li>排队时延</li>
</ul>
<p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p>
<p>有时会把排队时延看成<strong>处理时延 一部分</strong></p>
<p>总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-5f9bf4982c20ad4f.png" alt=""></p>
<p>image-20201007014139333</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-dd48cf5be5b2a7f7.png" alt=""></p>
<p>image-20201007015401505</p>
<p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p>
<h2 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5 时延带宽积"></a>5 时延带宽积</h2><p>时延带宽积 = 传播时延 * 带宽</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-bdca296e77c59e48.png" alt=""></p>
<p>image-20201007115317347</p>
<h2 id="6-往返时间"><a href="#6-往返时间" class="headerlink" title="6 往返时间"></a>6 往返时间</h2><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-73f29eb38db9983c.png" alt=""></p>
<p>image-20201007115647631</p>
<h2 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7 利用率"></a>7 利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-62d6da59682ef67f.png" alt=""></p>
<p>image-20201012164544306</p>
<h2 id="8-丢包率"><a href="#8-丢包率" class="headerlink" title="8 丢包率"></a>8 丢包率</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f8fc02096f0952b7.png" alt=""></p>
<p>image-20201007132900210</p>
<h1 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h1><h2 id="1-1、常见的计算机网络体系结构"><a href="#1-1、常见的计算机网络体系结构" class="headerlink" title="1 1、常见的计算机网络体系结构"></a>1 1、常见的计算机网络体系结构</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-b5174af1551d6cee.png" alt=""></p>
<p>image-20201007133848212</p>
<p>如今用的最多的是 TCP/IP 体系结构，现今规模最大的、覆盖全球的、基于 TCP/IP 的互联网并未使用 OSI 标准。</p>
<p>TCP/IP 体系结构相当于将 OSI 体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p>
<p>TCP/IP 在网络层使用的协议是 IP 协议，IP 协议的意思是网际协议，因此 <strong>TCP/IP 体系结构的网络层称为网际层</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f647ab572971d89a.png" alt=""></p>
<p>image-20201007135220030</p>
<p>在用户主机的操作系统中，通常都带有符合 TCP/IP 体系结构标准的 TCP/IP 协议族。</p>
<p>而用于网络互连的路由器中，也带有符合 TCP/IP 体系结构标准的 TCP/IP 协议族。</p>
<p>只不过路由器一般只包含网络接口层和网际层。</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-6800e214b18c47c3.png" alt=""></p>
<p>image-20201007135518050</p>
<p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的 WIFI 接口等。</p>
<p><strong>网际层</strong>：它的核心协议是 IP 协议。</p>
<p><strong>运输层</strong>：TCP 和 UDP 是这层的两个重要协议。</p>
<p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p>
<p><strong>IP 协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的 <strong>TCP 协议和 UDP 协议（运输层）</strong>提供网络互连服务</p>
<p>而 <strong>TCP 协议</strong>在享受 IP 协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p>
<p><strong>UDP 协议</strong>在享受 IP 协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p>
<p>TCP/IP 体系结构中最重要的是 <strong>IP 协议</strong>和 <strong>TCP 协议</strong>，因此用 TCP 和 IP 来表示整个协议大家族。</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-82255e6c6d5f29bf.png" alt=""></p>
<p>image-20201007141110338</p>
<p>教学时把 TCP/IP 体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p>
<h2 id="2-2、计算机网络体系结构分层的必要性"><a href="#2-2、计算机网络体系结构分层的必要性" class="headerlink" title="2 2、计算机网络体系结构分层的必要性"></a>2 2、计算机网络体系结构分层的必要性</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-466a303e1e5cc42a.png" alt=""></p>
<p>image-20201007141318411</p>
<p><strong>物理层问题</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-0274083e0bf0da85.png" alt=""></p>
<p>image-20201007141806675</p>
<p>这图说明</p>
<ul>
<li><p>第一，严格来说，传输媒体并不属于物理层</p>
</li>
<li><p>计算机传输的信号，并不是图示的方波信号</p>
</li>
</ul>
<p>这样举例只是让初学者容易理解</p>
<p><strong>数据链路层问题</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f0d9f2816d7bab9d.png" alt=""></p>
<p>image-20201007142049812</p>
<p><strong>网络层问题</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f55f86e0a78ffe23.png" alt=""></p>
<p>image-20201007142408792</p>
<p><strong>运输层问题</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-20174ff3821a739b.png" alt=""></p>
<p>image-20201007142631029</p>
<p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是 QQ 进程</p>
<p><strong>应用层问题</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-edab6d1f00b0ab15.png" alt=""></p>
<p>image-20201007142755720</p>
<p>应用层该用什么方法（应用层协议）去解析数据</p>
<p><strong>总结</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-96bdae8525215011.png" alt=""></p>
<p>image-20201007204006284</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-d29fee34f68a16b9.png" alt=""></p>
<p>image-20201007143138937</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-1cf0ec9780d80019.png" alt=""></p>
<p>image-20201007195641140</p>
<h2 id="3-3、计算机网络体系结构分层思想举例"><a href="#3-3、计算机网络体系结构分层思想举例" class="headerlink" title="3 3、计算机网络体系结构分层思想举例"></a>3 3、计算机网络体系结构分层思想举例</h2><p>例子：主机的浏览器如何与 Web 服务器进行通信</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-33e3c614a6ac37d0.png" alt=""></p>
<p>image-20201007144900565</p>
<p><strong>解析：</strong></p>
<p>主机和 Web 服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与 Web 服务器中的 <strong>Web 服务器应用进程</strong>之间基于<strong>网络的通信</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-8c5d1b3fdc1b7111.png" alt=""></p>
<p>image-20201007145242020</p>
<p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p>
<p><strong>1、发送方发送</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-ac36f7a9544dde9f.png" alt=""></p>
<p>image-20201007145441370</p>
<p>第一步：</p>
<ul>
<li><p><strong>应用层</strong>按照 HTTP 协议的规定构建一个 <strong>HTTP 请求报文</strong></p>
</li>
<li><p>应用层将 <strong>HTTP 请求报文</strong>交付给<strong>运输层</strong>处理</p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-cc2b73b1736d5809.png" alt=""></p>
<p>image-20201007145720661</p>
<p>第二步：</p>
<ul>
<li><p><strong>运输层</strong>给 <strong>HTTP 请求报文</strong>添加一个 <strong>TCP 首部</strong>，使之成为 <strong>TCP 报文段</strong></p>
</li>
<li><p><strong>TCP 报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</p>
</li>
<li><p><strong>运输层</strong>将 T<strong>CP 报文段</strong>交付给<strong>网络层</strong>处理</p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-dc02183dcf759d9e.png" alt=""></p>
<p>image-20201007150234909</p>
<p>第三步：</p>
<ul>
<li><p><strong>网络层</strong>给 <strong>TCP 报文段</strong>添加一个 <strong>IP 首部</strong>，使之成为 <strong>IP 数据报</strong></p>
</li>
<li><p><strong>IP 数据报的首部格式</strong>作用是使 <strong>IP 数据报</strong>可以在互联网传输，也就是被路由器转发</p>
</li>
<li><p><strong>网络层</strong>将 <strong>IP 数据报</strong>交付给<strong>数据链路层</strong>处理</p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f8cf8ce4a6bfdb54.png" alt=""></p>
<p>image-20201007150723365</p>
<p>第四步：</p>
<ul>
<li><p><strong>数据链路层</strong>给 <strong>IP 数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</p>
</li>
<li><p>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</p>
</li>
<li><p>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</p>
</li>
<li><p><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-e7285afa504bce0d.png" alt=""></p>
<p>image-20201007151342502</p>
<p>第五步：</p>
<ul>
<li><p><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络 N1 假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p>
</li>
<li><p><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</p>
</li>
<li><p><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-8ffee68ffe58b8a1.png" alt=""></p>
<p>image-20201007151900254</p>
<p>第六步：</p>
<ul>
<li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li>
</ul>
<p><strong>2、路由器转发</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-b9824f4625354b9b.png" alt=""></p>
<p>image-20201007152029458</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-09a0b27933c9895e.png" alt=""></p>
<p>image-20201007152138961</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-6eace5a882cca26d.png" alt=""></p>
<p>image-20201007152253899</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-92d182edd57d1054.png" alt=""></p>
<p>image-20201007152627778</p>
<p>在路由器中</p>
<ul>
<li><p><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></p>
</li>
<li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是 <strong>IP 数据报</strong></p>
</li>
<li><p><strong>网络层</strong>解析 <strong>IP 数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></p>
</li>
</ul>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-bc79de20a0c4b57c.png" alt=""></p>
<p>image-20201007152650863</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-33d09406bfc433e0.png" alt=""></p>
<p>image-20201007152812431</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-28228b60dd019bb5.png" alt=""></p>
<p>image-20201007153714840</p>
<p>在路由器中</p>
<ul>
<li><p>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</p>
</li>
<li><p><strong>网络层</strong>将 <strong>IP 数据报</strong>交付给<strong>数据链路层</strong></p>
</li>
<li><p><strong>数据链路层</strong>给 <strong>IP 数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></p>
</li>
<li><p><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></p>
</li>
<li><p><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络 N2 假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p>
</li>
<li><p>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达 <strong>Web 服务器</strong></p>
</li>
</ul>
<p><strong>3、接收方接收</strong></p>
<p>和发送方（主机）发送过程的封装正好是反着来</p>
<p>在 Web 服务器上</p>
<ul>
<li><p><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></p>
</li>
<li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为 <strong>IP 数据报</strong>，将其交付给<strong>网络层</strong></p>
</li>
<li><p><strong>网络层</strong>将 <strong>IP 数据报</strong>的<strong>首部</strong>去掉后成为 <strong>TCP 报文段</strong>，将其交付给<strong>运输层</strong></p>
</li>
<li><p><strong>运输层</strong>将 <strong>TCP 报文段</strong>的<strong>首部</strong>去掉后成为 <strong>HTTP 请求报文</strong>，将其交付给<strong>应用层</strong></p>
</li>
<li><p><strong>应用层</strong>对 <strong>HTTP 请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></p>
</li>
</ul>
<p><strong>发回响应报文的步骤和之前过程类似</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-d9f5b6ce408c252b.png" alt=""></p>
<p>image-20201007155051275</p>
<h2 id="4-4、计算机网络体系结构中的专用术语"><a href="#4-4、计算机网络体系结构中的专用术语" class="headerlink" title="4 4、计算机网络体系结构中的专用术语"></a>4 4、计算机网络体系结构中的专用术语</h2><p>以下介绍的专用术语来源于 OSI 的七层协议体系结构，但也适用于 TCP/IP 的四层体系结构和五层协议体系结构</p>
<p><strong>实体</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-b4c748c8f731e416.png" alt=""></p>
<p>image-20201007155444920</p>
<p><strong>协议</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-01d621fd0afde0a2.png" alt=""></p>
<p>image-20201007155545934</p>
<p>协议：控制两个对等实体进行逻辑通信的规则的集合</p>
<p>协议三要素：</p>
<ul>
<li><p>语法：定义所交换信息的格式</p>
</li>
<li><p>语义：定义收发双方所要完成的操作</p>
</li>
<li><p>同步：定义收发双发的时序关系</p>
</li>
</ul>
<p><strong>服务</strong></p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-b3d7eb63257d9914.png" alt=""></p>
<p>image-20201007160246561</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f24a75796ed2c7f6.png" alt=""></p>
<p>image-20201016104750288</p>
<p><img data-src="http://upload-images.jianshu.io/upload_images/24878825-f9bd7898a7f2dadd.png" alt=""></p>
<p>image-20201007162620250</p>
]]></content>
  </entry>
</search>
